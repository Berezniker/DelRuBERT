Московский Государственный Университет
имени М. В. Ломоносова
Факультет Вычислительной Математики и Кибернетики
Кафедра Математической Кибернетики

Дискретная математика
(II семестр)
лектор — профессор В. Б. Алексеев
составитель — А. Д. Поспелов

Москва 2002

Содержание
Глава I. Функции алгебры логики
§1. Функции алгебры логики. Равенство функций. Тождества для элементарных функций
§2. Теорема о разложении функции алгебры логики по переменным. Теорема о совершенной
дизъюнктивной нормальной форме
§3. Полные системы. Примеры полных систем
§4. Теорема Жегалкина о представимости функции алгебры логики полиномом
§5. Понятие замкнутого класса. Замкнутость классов T0, T1 и L
§6. Двойственность. Класс самодвойственных функций, его замкнутость
§7. Класс монотонных функций, его замкнутость
§8. Лемма о несамодвойственной функции
§9. Лемма о немонотонной функции
§10. Лемма о нелинейной функции
§11. Теорема Поста о полноте системы функций алгебры логики
§12. Теорема о максимальном числе функций в базисе алгебры логики
§13. Теорема о предполных классах
§14. k-значные функции. Теорема о существовании конечной полной системы в множестве
k-значных функций

3
5
6
6
8
9
10
10
11
11
12
12
13
13

Глава II. Основы теории графов
§15. Основные понятия теории графов. Изоморфизм графов. Связность
§16. Деревья. Свойства деревьев
§17. Корневые деревья. Верхняя оценка их числа
§18. Геометрическая реализация графов.
Теорема о реализации графов в трёхмерном пространстве
§19. Планарные (плоские) графы. Формула Эйлера
§20. Доказательство непланарности графов K5 и K3,3. Теорема Понтрягина-Куратовского
§21. Теорема о раскраске планарных графов в пять цветов

15
16
17
18
19
20
21

Глава III. Основы теории управляющих систем
§22. Схемы из функциональных элементов. Реализация функций алгебры логики схемами
§23. Сумматор. Верхняя оценка сложности сумматора. Вычитатель
§24. Метод Карацубы построения схемы для умножения, верхняя оценка её сложности
§25. Дешифратор. Асимптотика сложности дешифратора. Верхняя оценка сложности
реализации произвольной функции алгебры логики
§26. Мультиплексор. Верхняя оценка сложности мультиплексора. Метод Шеннона
§27. Шифратор. Верхняя оценка сложности шифратора

23
25
26
28
29
31

Глава IV. Основы теории кодирования
§28. Алфавитное кодирование.
Теорема Маркова о взаимной однозначности алфавитного кодирования
§29. Неравенство Макмиллана
§30. Существование префиксного кода с заданными длинами кодовых слов
§31. Оптимальные коды, их свойства
§32. Теорема редукции
§33. Коды с исправлением r ошибок. Оценка функции Mr (n).
§34. Коды Хэмминга. Оценка функции M1 (n)

32
33
33
34
35
36
37

Глава V. Основы теории конечных автоматов
§35. Понятие ограниченно детерминированных (автоматных) функций, их представление
диаграммой Мура. Единичная задержка
§36. Схемы из функциональных элементов и элементов задержки. Автоматность
осуществляемых ими отображений
§37. Моделирование автоматной функции схемой из функциональных элементов и элементов
задержки
§38. Теорема Мура. Теорема об отличимости состояний двух автоматов

2

39
40
41
42

Глава I. Функции алгебры логики.
§1. Функции алгебры логики. Равенство функций.
Тождества для элементарных функций.
1°. Функции алгебры логики.
Определение 1. Пусть E2 = {0, 1} — основное множество (исходный алфавит значений
переменных), тогда E2n = {(α1, …, αn) | ∀i αi∈E2}. Тогда всюду определённой булевой функцией назовём отображение f (x1, …, xn): E2n → E2. Такую функцию можно задать таблично, а
можно как суперпозицию других, более простых функций. Например, для n = 1:
x 0 1 x x
0 0 1 0 1
1 0 1 1 0
При этом функция 0 называется константой нулём, функция 1 — константой единицей, функция x — тождественной, а функция x — отрицанием x. При этом для последней
функции допускается также иное обозначение: x ≡ ¬x .
Для n = 2:
x
0
0
1
1

y
0
1
0
1

f1
0
1
1
1

f2
0
0
0
1

f3
0
1
1
0

f4
1
1
0
1

f5
1
0
0
1

f6
1
1
1
0

f7
1
0
0
0

При заполнении таблицы столбцы переменных заполняются в лексикографическом порядке (по возрастанию двоичных чисел).
f1 — дизъюнкция, функция «или», логическое сложение: f1 = x ∨ y.
f2 — конъюнкция: f2 = x · y = x & y = xy.
f3 — сложение по модулю 2 (исключающее «или»): f3 = x ⊕ y = x + y.
f4 — импликация: f4 = x → y.
f5 — эквивалентность: f5 = x ~ y = x ⊕ y .
f6 — штрих Шеффера: f6 = x | y = xy .
f7 — стрелка Пирса: f7 = x ↓ y = x ∨ y .
Лемма (о числе слов). В алфавите A = {a1, …, ar} из r букв можно построить ровно rm
различных слов длины m.
Доказательство. Проведём индукцию по m. Для m = 1 утверждение очевидно. Пусть
утверждение леммы верно для m – 1, то есть существует ровно rm – 1 различных слов длины
m – 1. Для каждого такого слова длины m – 1 существует ровно r возможностей добавить одну букву в конец. Так как всего слов длины m – 1 — rm – 1, то различных слов длины m получится r · rm – 1 = rm. Лемма доказана.
Рассмотрим таблицу некоторой функции алгебры логики от n переменных.
x1 x2 ! xn
f
α0 
0 0 ! 0
0 0 ! 1
α1  2n
n
2 
2
!
! ! ! !
 1 1 ! 1 α 2n −1 

3

Для её задания необходимо и достаточно определить её значения на 2n наборах. Таким образом, получаем, что всего различных функций от n переменных столько, сколько существует
n
различных наборов из нулей и единиц длины 2n, т.е. 2 2 .
Используя последний факт можно, например, получить оценку числа функций от 10 пе-

( )

ременных. Всего таких функций будет 22 = 21024 > 21000 = 210
> (1000 ) = 10300 . Таким образом, при росте числа переменных число функций возрастает очень быстро, и их табличное
задание становится неудобным.
2°. Равенство функций. В обычной алгебре справедливо равенство x + y – y = x, несмотря на то, что в левой части записана функция от двух переменных, а в правой — от одной. Таким образом, функции от разного числа переменных могут быть одинаковыми, что
даёт повод ввести понятие существенных и фиктивных переменных.
Определение 2. Переменная xi называется существенной переменной функции алгебры
логики f (x1, …, xn), если существуют такие α1, …, αi – 1, αi + 1, …, αn∈E2, что
100

10

100

f (α1, …,αi – 1, 0, αi + 1,…, αn) ≠ f (α1, …, αi – 1, 1, αi + 1, …, αn).
Такие наборы, отличающиеся лишь одной переменной xi, называются соседними по xi. В противном случае переменная xi называется фиктивной.
Если xi — фиктивная переменная функции f, то функция f однозначно определяется некоторой функцией g (x1, …, xi – 1, xi + 1, …, xn). Таблицу любой функции можно расширить
введением любого числа фиктивных переменных.
Определение 3. Две функции алгебры логики называются равными, если одну из
них можно получить из другой путём добавления и изъятия любого числа фиктивных
переменных.
3°. Формулы.
Определение 4. Пусть имеется некоторое множество функций
A = {f1 (…), f2 (…), …, fn (…), …}.
Введем понятие формулы над A:
1) Любая функция из A называется формулой над A.
2) Если f (x1, …, xn) ∈ A и для любого i Hi — либо переменная, либо формула над A, то
выражение вида f (H1, H2, …, Hn) является также формулой над A.
3) Только те объекты называются формулами над A, которые можно построить с помощью пунктов 1 и 2 данного определения.
Замечание. Среди H1, H2, …, Hn вполне могут быть одинаковые.
4°. Основные эквивалентности.
1. Коммутативность:
2. Ассоциативность:
x∨y=y∨x;
(x ∨ y) ∨ z = x ∨ (y ∨ z) = x ∨ y ∨ z ;
xy = yx ;
(xy) z=x (yz)=xyz ;
x⊕y=y⊕x;
(x ⊕ y) ⊕ z = x ⊕ (y ⊕ z) = x ⊕ y ⊕ z.
x~y=y~x.
3. Дистрибутивность:
4. x = x ,
(x ⊕ y) z = (xz) ⊕ (yz) ;
правила де Моргана:
(x ∨ y) z = (xz) ∨ (yz) ;
x∨ y = x⋅y ,
(xy) ∨ z = (x ∨ z)·(y ∨ z).
x⋅ y = x ∨ y .

4

5. Законы поглощения.
x∨x=x
x·x=x
x ∨ x =1
x⋅x = 0
x∨1=1
x·1=x
x∨0=x
x · 0 = 0.

6. x y = x ⋅ y
x ↓ y = x∨ y
x→ y=x∨ y
x ⊕ y = (x ⋅ y ) ∨ (x ⋅ y )

x ~ y = x ⊕ y = (xy ) ∨ (x y )

Приоритет конъюнкции выше, чем приоритеты дизъюнкции и суммы по модулю 2. Благодаря этому, часто удаётся опустить ряд ненужных скобок. Имеют место следующие очевидные
утверждения:
x1 · x2 · … · xn = 1 ⇔ ∀i xi = 1,
x1 ∨ x2 ∨ … ∨ xn = 1 ⇔ ∃i: xi = 1.
 x, σ = 1 σ
Определение 5. x в степени сигма называется функция xσ = 
; x = 1 ⇔ x = σ.
 x ,σ = 0

§2. Теорема о разложении функции алгебры логики по переменным.
Теорема о совершенной дизъюнктивной нормальной форме.
Теорема 1 (о разложении функции алгебры логики по переменным). Для любой
функции алгебры логики f (x1, …, xn) и для любого k (1 ≤ k ≤ n) справедливо следующее
равенство:
f (x1 ,!, xn ) =

∨

(σ1 ,σ 2 ,!,σ k )∈E2k

x1σ1 ⋅ x2σ 2 ⋅ ! ⋅ xkσ k ⋅ f (σ 1 , σ 2 ,!, σ k , xk +1 ,!, xn ) .

Доказательство. Для любого набора α~ = (α1 ,α 2 ,!,α n ) вычислим значение правой части на этом наборе. Как только хотя бы один из сомножителей будет равен нулю, вся конъюнкция обратится в нуль. Таким образом, из ненулевых конъюнкций останется лишь одна —
та, в которой αi = σi и
∨

(σ 1 ,σ 2 ,!,σ k )∈E2k

α1σ 1 ⋅ α 2σ 2 ⋅ ! ⋅ α kσ k f (σ 1 , σ 2 ,!, σ k ,α k +1 ,!,α n ) = 0 ∨ ! ∨ 0 ∨ α1α1 ⋅ α 2α 2 "α kα k f (α1 ,!,α n ),

а в силу того, что xx = 1, указанное выражение равно f (α1, α2, …, αn). Теорема доказана.
Следствие 1. Разложение произвольной функции алгебры логики по одной переменной
имеет вид f (x1 , x2 ,!, x n ) = x1 f (0, x2 ,!, x n ) ∨ x1 f (1, x2 ,!, xn ).
Следствие 2 (теорема о совершенной дизъюнктивной нормальной форме). Для любой функции алгебры логики f (x1, x2, …, xn), отличной от тождественного нуля, справедливо
следующее представление:
f (x1 ,!, xn ) =

∨

(σ1 ,!,σ n ): f (σ1 ,!,σ n )=1

x1σ1 x2σ 2 " xnσ n .

Доказательство. Пусть функция f (x1, x2,…, xn) отлична от тождественного нуля. Напишем разложение этой функции по k = n переменным:
f (x1 ,!, xn ) =

∨

(σ 1 ,σ 2 ,!,σ n )∈E2n

x1σ1 x2σ 2 ! xnσ n f (σ 1 , σ 2 ,!, σ n ),

что можно переписать в эквивалентном виде
∨

(σ1 ,!,σ n ): f (σ1 ,!,σ n )=1

x1σ1 x2σ 2 ! xnσ n f (σ 1 ,!, σ n ) ∨

5

∨

(σ1 ,!,σ n ): f (σ1 ,!,σ n )=0

x1σ1 x2σ 2 ! xnσ n f (σ 1 ,!, σ n ) .

Учитывая, что в первой дизъюнкции все значения функции равны единице, а вторая обнуляется из-за того, что все значения функции в ней равны нулю, получаем утверждение
следствия. Следствие доказано.
Теорема 2 (о совершенной конъюнктивной нормальной форме). Для любой функции
алгебры логики f (x1, x2, …, xn), отличной от тождественной единицы, справедливо
представление
f (x1 ,!, xn ) =

&

(σ 1 ,σ 2 ,!,σ n )

(x

σ1
1

)

∨ x2σ 2 ∨ ! ∨ xnσ n .

f (σ 1 ,σ 2 ,!,σ n )= 0

§3. Полные системы. Примеры полных систем (с доказательством полноты).
Определение. Множество функций алгебры логики A называется полной системой
(в P2), если любую функцию алгебры логики можно выразить формулой над A.
Теорема 3. Система A = {∨, &, ¬} является полной.
Доказательство. Если функция алгебры логики f отлична от тождественного нуля, то f
выражается в виде совершенной дизъюнктивной нормальной формы, в которую входят лишь
дизъюнкция, конъюнкция и отрицание. Если же f ≡ 0, то f = x ⋅ x . Теорема доказана.
Лемма 2. Если система A — полная, и любая функция системы A может быть выражена
формулой над некоторой другой системой B, то B — также полная система.
Доказательство. Рассмотрим произвольную функцию алгебры логики f (x1, …, xn) и две
системы функций: A = {g1, g2, …} и B = {h1, h2, …}. В силу того, что система A полна, функция f может быть выражена в виде формулы над ней: f (x1 ,!, xn ) = ℑ[g1 , g 2 ,!], где
g i = ℜ i [h1 , h2 ,!], то есть функция f представляется в виде f (x1 ,!, xn ) = ℑ[ℜ1 , ℜ 2 ,!], иначе
говоря, может быть представлена формулой над B. Перебирая таким образом все функции
алгебры логики, получим, что система B также полна. Лемма доказана.
Теорема 4. Следующие системы являются полными в P2:
1) {x ∨ y, x };
2) {x ⋅ y, x };
3) {x | y};
4) {x · y, x ⊕ y , 1}.
Доказательство. 1) Известно (теорема 3), что система A = {x ∨ y, x ⋅ y, x } полна. Покажем, что полна система B = {x ∨ y, x}. Действительно, из закона де Моргана x ⋅ y = x ∨ y по-

лучаем, что x ⋅ y = x ∨ y , то есть конъюнкция выражается через дизъюнкцию и отрицание, и
все функции системы A выражаются формулами над системой B. Согласно лемме 2 система
B полна.
2) Аналогично пункту 1: x ∨ y = x ⋅ y ⇔ x ∨ y = x ⋅ y и из леммы 2 следует истинность
утверждения пункта 2.
3) x | x = x , x ⋅ y = x | y = (x | y ) | (x | y ) и согласно лемме 2 система полна.
4) x = x ⊕ 1 и согласно лемме 2 система полна.
Теорема доказана.

§4. Теорема Жегалкина о представимости функции алгебры логики полиномом.
Определение 1. Монотонной конъюнкцией от переменных x1,…, xn называется любое
выражение вида xi1 ⋅ xi2 ⋅ xi3 " xis , где s ≥ 1, 1 ≤ ij ≤ n ∀j = 1, 2, …, s, все переменные различны
(ij ≠ ik, если j ≠ k); либо просто 1.

6

Определение 2. Полиномом Жегалкина над x1, …, xn называется выражение вида
K1 ⊕ K2 ⊕ K3 ⊕ … ⊕ Kl,
где l ≥ 1 и все Kj суть различные монотонные конъюнкции над x1, …, xn; либо константа 0.
Теорема 5 (теорема Жегалкина). Любую функцию алгебры логики f (x1, …, xn) можно
единственным образом выразить полиномом Жегалкина над x1, …, xn.
Доказательство. 1) Докажем существование полинома. Система {x · y, x ⊕ y, 1} полна,
следовательно, любую функцию алгебры логики f (x1, …, xn) можно реализовать формулой
над {x · y, x ⊕ y, 1}.
a) Пользуясь дистрибутивностью, раскрываем все скобки в этой реализации и получаем, что f (x1, …, xn) = K1′ ⊕ K2′ ⊕ … ⊕ Kl′, где любая Ki′ — конъюнкция переменных
и единиц.
b) Преобразуем все полученные конъюнкции в элементарные, пользуясь при этом
коммутативностью и соотношениями x · x = x, 1 · 1 = 1 и A · 1 = A. Очевидно, все
конъюнкции станут монотонными.
c) Преобразуем полученную сумму в полином Жегалкина, пользуясь при этом соотношениями A ⊕ A = A и A ⊕ 0 = A. В результате получим либо
K i1 ⊕ K i2 ⊕ K i3 ⊕ ! ⊕ K im ,
либо константу 0.
Существование доказано.
2) Докажем единственность представления. Подсчитаем число различных всевозможных монотонных конъюнкций от n переменных. Для этого составим таблицу вида
x1 x2 x4
x2 x3
1

x1
1
0
0

x2
1
1
0

x3
0
1
0

x4
1
,
0
0

где каждой переменной соответствует единица, если она присутствует в монотонной конъюнкции и ноль в противном случае. При этом константе единице поставим в соответствие
нулевой набор. Очевидно, что построенное отображение биективно. Следовательно, всего
различных монотонных конъюнкций от n переменных — 2n. Построим аналогичное биективное отображение между всевозможными суммами монотонных конъюнкций и векторами
длины 2n — числа конъюнкций. Для этого составим таблицу вида
xy x y 1
xy + 1 1 0 0 1 ,
0
0 0 0 0
где под соответствующей монотонной конъюнкцией стоит единица, если она входит в данную сумму, и ноль, если не входит. При этом константе ноль ставится в соответствие нулевой набор. Очевидно, такое отображение биективно. Всего таких различных сумм будет
n
столько, сколько существует различных булевых векторов длины 2n, то есть — 2 2 . Мы получили, что число различных полиномов Жегалкина совпадает с числом функций алгебры
логики. Поскольку отображение из множества полиномов во множество функций сюръективно, то оно и биективно, так как множества полиномов Жегалкина над n переменными и
функций алгебры логики от n переменных равномощны. Единственность доказана.

7

§5. Понятие замкнутого класса. Замкнутость классов T0, T1 и L.
1°. Понятие замкнутого класса.
Определение 1. Пусть A ⊆ P2. Тогда замыканием A называется множество всех функций алгебры логики, которые можно выразить формулами над A.
Обозначение: [A].
Имеют место следующие свойства:
1) [A] ⊇ A;
2) A ⊇ B ⇒ [A] ⊇ [B], причём, если в левой части импликации строгое вложение, то из
него вовсе не следует строгое вложение в правой части — верно лишь
A ⊃ B ⇒ [A] ⊇ [B];
3) [[A]] = [A].
Определение 2. Система функций алгебры логики A называется полной, если [A] = P2.
Определение 3. Пусть A ⊆ P2. Тогда система A называется замкнутым классом, если замыкание A совпадает с самим A: [A] = A.
Утверждение. Пусть A — замкнутый класс, A ≠ P2 и B ⊆ A. Тогда B — неполная система
(подмножество неполной системы будет также неполной системой).
Доказательство. B ⊆ A ⇒ [B] ⊆ [A] = A ≠ P2 ⇒ [B] ≠ P2. Следовательно, B — неполная
система. Утверждение доказано.
2°. Примеры замкнутых классов.
Класс T0 = {f (x1, …, xn) | f (0, …, 0) = 0}.
Классу T0 принадлежат, например, функции 0, x, xy, x ∨ y, x ⊕ y.
Классу T0 не принадлежат функции 1, x , x → y, x | y, x ↓ y, x ~ y.
Подсчитаем число функций в классе T0. Для этого построим следующую таблицу:
x1 ! xn
0 ! 0 0
.
n
! ! ! }2 − 1
Все функции, принадлежащие указанному классу, принимают на нулевом наборе нулевое значение. Таким образом, всего функций в классе T0 столько, сколько существует булевых векторов длины 2n – 1 (первый разряд вектора длины 2n необходимо равен нулю), то есть
n
n
T0 = 2 2 −1 = 12 2 2 .
Теорема 6. Класс T0 —замкнутый.
Доказательство. Пусть f (x1 ,!, xn ), g1 y11 ,!, y1m1 ,!, g n yn1 ,!, ynmn ⊆ T0 . Рассмотрим

( (

{

)

(

(

)

))

(

)}

функцию h( y1 ,!, y r ) = f g1 y11 ,!, y1m1 ,!, g n y n1 ,!, y nmn . Среди переменных функций gi
могут встречаться и одинаковые, поэтому в качестве переменных функции h возьмём все
различные из них. Тогда h (0, …, 0) = f (g1 (0, …, 0), …, gn (0, …, 0)) = f (0, …, 0) = 0 , следовательно, функция h также сохраняет ноль. Рассмотрен только частный случай (без переменных в качестве аргументов). Однако, поскольку тождественная функция сохраняет ноль,
подстановка простых переменных эквивалентна подстановке тождественной функции, теорема доказана.
Класс T1 = {f (x1, …, xn) | f (1, 1, …, 1) = 1}.
Классу T1 принадлежат функции 1, x, xy, x ∨ y, x → y, x ~ y.
Классу T1 не принадлежат функции 0, x , x ⊕ y, x | y, x ↓ y.
Теорема 7. Класс T1 замкнут.
Доказательство повторяет доказательство аналогичной теоремы для класса T0.
8

Класс L линейных функций.
Определение 4. Функция алгебры логики f (x1, …, xn) называется линейной, если
f (x1, …, xn) = a0 ⊕ a1 x1 ⊕ … ⊕ an xn, где ai ∈ {0, 1}.
Иными словами, в полиноме линейной функции нет слагаемых, содержащих конъюнкцию.
Классу L принадлежат функции 0, 1, x = x ⊕ 1 , x ~ y, x ⊕ y.
Классу L не принадлежат функции xy, x ∨ y, x → y, x | y, x ↓ y.
Теорема 8. Класс L замкнут.
Доказательство. Поскольку тождественная функция — линейная, достаточно (как и в
теоремах 6 и 7) рассмотреть только случай подстановки в формулы функций: пусть
f (x1, …, xn) ∈ L и gi ∈ L. Достаточно доказать, что f (g1, …, gn)∈L. Действительно, если не учитывать слагаемых с коэффициентами ai = 0, то всякую линейную функцию можно представить
в виде xi1 ⊕ xi2 ⊕ ! ⊕ xik ⊕ a0 . Если теперь вместо каждого xi j подставить линейное выражение,
то получится снова линейное выражение (или константа единица или нуль).

§6. Двойственность. Класс самодвойственных функций, его замкнутость.
1°. Двойственность.
Определение 1. Функцией, двойственной к функции алгебры логики f (x1, …, xn), называется функция f ∗ (x1 ,!, xn ) = f x1 ,!, xn .
Теорема 9 (принцип двойственности). Пусть

(

)

( (
),!, g (y

(

)

))

Φ( y1 ,!, ym ) = f g1 y11 ,!, y1k1 ,!, g n yn1 ,!, ynkn .

( (

Тогда Φ ∗ ( y1 ,!, ym ) = f ∗ g1∗ y11 ,!, y1k1
Доказательство. Рассмотрим

((

∗
n

n1

))

,!, ynk n .

( (

)

(

))

Φ ∗ ( y1 , ! y m ) = f g1 y11 , ! , y1k1 , ! , g n y n1 ,! , y nk n =

)

)) ( (
(g (y ,!, y ),!, g (y
(

(

)
)).

))

= f g1 y11 ,!, y1k1 ,!, g n yn1 ,!, ynkn = f g1∗ y11 , !, y1k1 ,!, g n∗ yn1 ,!, ynkn =
= f

∗

∗
1

11

∗
n

1k 1

n1

,!, ynk n

Теорема доказана.
Следствие. Пусть функция Φ (y1, …, ym) реализуется формулой над A = {f1, f2, …}. Тогда
если в этой формуле всюду заменить вхождения fi на fi*, то получится формула, реализующая
Φ* (y1, …, ym).
Утверждение. Для любой функции алгебры логики f (x1, …, xn) справедливо равенство
f (x1, …, xn)=f** (x1, …, xn).

[(

Доказательство. f ∗∗ = f x1 ,! , xn

)] = f (x ,!, x ) = f (x ,!, x ) , и утверждение доказано.
∗

1

n

1

n

2°. Класс S самодвойственных функций.
Определение 2. Функция алгебры логики f (x1, …, xn) называется самодвойственной, если
f (x1, …, xn) = f* (x1, …, xn).
Иначе говоря, S = {f | f = f*}.
Классу S принадлежат функции
1, x + y + z ≥ 2
x, x , x ⊕ y ⊕ z ⊕ a, m(x, y, z ) = xy ∨ yz ∨ zx = 
.
0, x + y + z ≤ 1

9

Классу S не принадлежат функции
0 ( f (x ) ≡ 0 ⇒ f ∗ (x ) = f (x ) ≡ 1 ), 1, x ∨ y (поскольку (x ∨ y ) = x ∨ y = x ⋅ y ≠ x ∨ y ), xy.
∗

Теорема 10. Класс S замкнут.
Доказательство. Пусть f (x1, …, xn) ∈ S, ∀i g i yi1 ,!, yiki ∈ S , i = 1, 2, …, n и

(

( (

)

(

)

))

Φ = f g1 y11 ,!, y1k1 ,!, g n yn1 ,!, ynkn .
Тогда из принципа двойственности следует, что

( (

(

)

Φ ∗ = f ∗ g1∗ y11 ,!, y1k1 ,!, g n∗ yn1 ,!, ynkn

)) = f (g1 (…), …, gn (…)).

Таким образом, мы получили, что Φ = Φ* и Φ ∈ S. Теорема доказана.

§7. Класс монотонных функций, его замкнутость.
~
Определение 1. Пусть α~ = (α1 ,α 2 ,! ,α n ) и β = (β1 , β 2 ,!, β n ) . Тогда
~
α~ ≤ β ⇔ ∀i (α i ≤ β i ) .
Замечание. Существуют наборы, для которых неприменимо отношение упорядоченности, определённое выше. Так, например, наборы (0, 0, 1) и (0, 1, 0) несравнимы.
Определение 2. Функция алгебры логики f (x1, …, xn) называется монотонной, если для
~
любых двух сравнимых наборов α~ и β выполняется импликация
~
~
α~ ≤ β ⇒ f (α~ ) ≤ f β .

()

Класс M всех монотонных функций.
Классу M принадлежат функции 0 , 1 , x , xy , x ∨ y, m (x, y, z) = xy ∨ yz ∨ zx.
Классу M не принадлежат функции x , x | y , x ↓ y , x ⊕ y , x ~ y , x → y.
Теорема 11. Класс M замкнут.
Доказательство. Поскольку тождественная функция монотонна, достаточно проверить
лишь случай суперпозиции функций. Пусть f (x1, …, xn) ∈ M, для любого j gj (y1, …, ym)∈M и
Φ (y1, …, ym) = f (g1 (y1, …, ym), …, gn (y1, …, ym)).
~
~
Рассмотрим произвольные наборы α~ = (α1 ,!,α m ), β = (β1 ,!, β m ) такие, что α~ ≤ β . Обозначим

()

~
gi (α~ ) = γ i , g i β = δ i .

()

~
Тогда для любого i имеем gi ∈ M и gi (α~ ) ≤ gi β , то есть ∀i (γ i ≤ δ i ) . Обозначим
~
γ~ = (γ 1 , γ 2 ,!, γ n ), δ = (δ 1 , δ 2 ,!, δ n ).

()

~
~
Тогда по определению γ~ ≤ δ и, в силу монотонности функции f, f (γ~ ) ≤ f δ . Но
~
~
Φ(α~ ) = f (γ 1 ,!, γ n ) = f (γ~ ) , Φ β = f (δ 1 ,!, δ n ) = f δ ,

()

()

()

()

~
~
и неравенство f (γ~ ) ≤ f δ ⇔ Φ(α~ ) ≤ Φ β , следовательно, Ф ∈ M. Теорема доказана.

§8. Лемма о несамодвойственной функции.
Лемма (о несамодвойственной функции). Из любой несамодвойственной функции алгебры логики f (x1, …, xn), подставляя вместо всех переменных функции x и x, можно получить φ (x) ≡ const.
10

(

)

Доказательство. Пусть f ∉ S. Тогда f x1 ,!, xn ≠ f (x1 ,!, xn ) ⇒ ∃σ~ = (σ 1 ,!, σ n ) :

(

)

(

)

f σ 1 ,!, σ n ≠ f (σ 1 ,!, σ n ) ⇔ f σ 1 ,!, σ n = f (σ 1 ,!, σ n ).
Построим функцию φ (x) так: φ (x) = f (x ⊕ σ1, …, x ⊕ σn). Действительно,
ϕ (0) = f (σ1, …, σn), ϕ (1) = f σ 1 ,!σ n
и φ (0) = φ (1) ⇒ φ (x) = const. Заметим, что подстановка удовлетворяет условию теоремы, так
 x, σ = 0
как x ⊕ σ = 
. Лемма доказана.
 x ,σ = 1

(

)

§9. Лемма о немонотонной функции.
Лемма (о немонотонной функции). Из любой немонотонной функции алгебры логики
f (x1, …, xn), подставляя вместо всех переменных функции x, 0, 1, можно получить функцию
ϕ (x ) ≡ x .
Доказательство. Пусть f ∉ M. Тогда существуют такие наборы α~ = (α1 ,!,α n ) и
~
~
~
~
β = (β1 ,!, β n ) , что α~ < β (то есть ∀j (αj ≤ βj) и α~ ≠ β ) и f (α~ ) > f β . Выделим те разряды
~
i1, …, ik наборов α~ и β , в которых они различаются. Очевидно, в наборе α~ эти разряды
~
равны 0, а в наборе β — 1. Рассмотрим последовательность наборов
α~0 ,α~1 ,α~2 ,!,α~k
~
таких, что α~ = α~0 < α~1 < α~2 < ! < α~k = β , где α~i +1 получается из α~i заменой одного из нулей,
расположенного в одной из позиций i1, …, ik, на единицу (при этом наборы α~i и α~i +1 — со~
седние). Поскольку f (α~ ) = 1 , а f β = 0 , среди наборов α~0 ,α~1 ,α~2 ,!,α~k найдутся два соседних α~i и α~i +1 , такие что f (α~i ) = 1 и f (α~i+1 ) = 0 . Пусть они различаются в r-ом разряде:
α~i = (α1 ,α 2 ,!,α r −1 ,0,α r +1 ,!,α n ), α~i+1 = (α1 ,α 2 ,!,α r −1 ,1,α r +1 ,!,α n ) . Тогда определим функцию
φ (x) так: φ (x) = f (α1, α2, …, αr – 1, x, αr + 1, …, αn). Действительно, тогда ϕ (0) = f (α~i ) = 1 ,
ϕ (1) = f (α~i+1 ) = 0 и ϕ (x ) ≡ x . Лемма доказана.

()

()

§10. Лемма о нелинейной функции.
Лемма (о нелинейной функции). Из любой нелинейной функции алгебры логики
f (x1, …, xn), подставляя вместо всех переменных x, x , y, y , 0, 1, можно получить φ (x, y) = x·y
или ϕ (x, y ) = x ⋅ y .
Доказательство. Пусть f (x1, …, xn) ∉ L. Рассмотрим полином Жегалкина этой функции.
Из её нелинейности следует, что в нём присутствуют слагаемые вида xi1 ⋅ xi2 ⋅ ! . Не ограничивая общности рассуждений, будем считать, что присутствует произведение x1 · x2 · …. Таким образом, полином Жегалкина этой функции выглядит так:
f (x1, …, xn) = x1 · x2 · P1 (x3, …, xn) ⊕ x1 · P2 (x3, …, xn) ⊕ x2 · P3 (x3, …, xn) ⊕ P4 (x3, …, xn),
причем P1 (x3, …, xn) ≠ 0.
Иначе говоря, ∃ a3, a4, …, an ∈ E2 = {0, 1} такие, что P1 (a3, a4, …, an) = 1. Рассмотрим вспомогательную функцию f (x1, x2, a3, a4, …, an) = x1 x2 · 1 ⊕ x1 · b ⊕ x2 · c ⊕ d. Тогда функция
f (x ⊕ с, y ⊕ b, a3, a4, …, an) = (x ⊕ c)(y ⊕ b) ⊕ (x ⊕ c)b ⊕ (y ⊕ b)c ⊕ d =
 xy, bc ⊕ d = 0
= xy ⊕ x · b ⊕ y · c ⊕ b · c ⊕ x · b ⊕ b · c ⊕ y · c ⊕ b · c ⊕ d = xy ⊕ (bc ⊕ d) = 
.
 xy, bc ⊕ d = 1
Лемма доказана.

11

§11. Теорема Поста о полноте системы функций алгебры логики.
Теорема 12 (теорема Поста). Система функций алгебры логики A = {f1, f2, …} является
полной в P2 тогда и только тогда, когда она не содержится целиком ни в одном из следующих классов: T0, T1, S, L, M.
Доказательство. Необходимость. Пусть A — полная система, N — любой из классов
T0, T1, S, L, M и пусть A ⊆ N. Тогда [A] ⊆ [N] = N ≠ P2 и [A] ≠ P2. Полученное противоречие
завершает обоснование необходимости.
Достаточность. Пусть A ⊄ T0, A ⊄ T1, A ⊄ M, A ⊄ L, A ⊄ S. Тогда в A существуют функции
f0 ∉ T0, f1 ∉ T1, fM ∉ M, fL ∉ L, fS ∉ S. Достаточно показать, что [A] ⊇ [f0, f1, fM, fL, fS] = P2. Разобьём доказательство на три части: получение отрицания, констант и конъюнкции.
a) Получение x . Рассмотрим функцию f0 (x1, …, xn) ∉ T0 и введём функцию φ0 (x) =
= f0 (x, x, …, x). Так как функция f0 не сохраняет нуль, φ0 (0) = f (0, 0, …, 0) = 1. Возможны два случая: либо ϕ 0 (x ) = x , либо φ0 (x) ≡ 1. Рассмотрим функцию
f1 (x1, …, xn) ∉ T1 и аналогичным образом введём функцию φ1 (x) = f1 (x, x, …, x). Так
как функция f1 не сохраняет единицу, φ1 (1) = f (1, 1, …, 1) = 0. Возможны также два
случая: либо ϕ1 (x ) = x , либо φ1 (x) ≡ 0. Если хотя бы в одном случае получилось искомое отрицание, пункт завершён. Если же в обоих случаях получились константы,
то согласно лемме о немонотонной функции, подставляя в функцию fM ∉ M вместо
всех переменных константы и тождественные функции, можно получить отрицание.
Отрицание получено.
b) Получение констант 0 и 1. Имеем fS ∉ S. Согласно лемме о несамодвойственной
функции, подставляя вместо всех переменных функции fS отрицание (которое получено в пункте a) и тождественную функцию, можно получить константы:
[fS, x ] ∋ [0, 1]. Константы получены.
c) Получение конъюнкции x · y. Имеем функцию fL ∉ L. Согласно лемме о нелинейной
функции, подставляя в функцию fL вместо всех переменных константы и отрицания
(которые были получены на предыдущих шагах доказательства), можно получить
либо конъюнкцию, либо отрицание конъюнкции. Однако на первом этапе отрицание
уже получено, следовательно, всегда можно получить конъюнкцию:
[fL, 0, 1, x ] ∋ [xy, xy ]. Конъюнкция получена.
В результате получено, что [ f 0 , f1 , f M , f L , f S ] ⊇ [x , xy ] = P2 . Последнее равенство следует
из пункта 2 теоремы 4. В силу леммы 2 достаточность доказана.

§12. Теорема о максимальном числе функций в базисе алгебры логики.
Определение. Система функций алгебры логики A ⊆ P2 называется базисом (в P2), если
1) [A] = P2;
2) ∀f ∈ A ([A \ {f}] ≠ P2).
Теорема 13. Максимальное число функций в базисе алгебры логики равно 4.
Доказательство. 1) Докажем, что из любой полной системы можно выделить полную
подсистему, содержащую не более четырёх функций. Действительно, если A — полная система ([A] = P2), то согласно теореме Поста в ней существуют пять функций f0 ∉ T0, f1 ∉ T1,
fS ∉ S, fM ∉ M, fL ∉ L. По теореме Поста система функций {f0, f1, fS, fM, fL} полна. Рассмотрим
функцию f0 (x1, …, xn) ∉ T0 (f0 (0, 0, …, 0) = 1). Возможны два случая:
a) f0 (1, 1, …, 1) = 1 ⇒ f0 ∉ S ⇒ [f0, f1, fL, fM] = P2 и система {f0, f1, fL, fM} полна.
b) f0 (1, 1, …, 1) = 0 ⇒ f0 ∉ M, T1 ⇒ [f0, fL, fS] = P2 и система {f0, fL, fS} полна.

12

2) Покажем, что существует базис алгебры логики из четырёх функций. Действительно,
рассмотрим систему функций {0, 1, x · y, x ⊕ y ⊕ z}. Эта система функций полная, так как
0 ∉ T1, S, 1 ∉ T0, x · y ∉ L, x ⊕ y ⊕ z ∉ M (0 ⊕ 0 ⊕ 1 = 1, 0 ⊕ 1 ⊕ 1 = 0). Однако, любая её подсистема не полна:
{0, 1, x · y} ⊆ M
{0, 1, x ⊕ y ⊕ z} ⊆ L
{0, xy, x ⊕ y ⊕ z} ⊆ T0
{1, xy, x ⊕ y ⊕ z} ⊆ T1.
Теорема доказана.

§13. Теорема о предполных классах.
1 . Предполные классы.
Определение. Пусть A ⊆ P2. A называется предполным классом, если
1) [A] ≠ P2;
2) ∀f∈P2 ( f∉A ⇒ [A∪{f}] = P2).
Теорема 14. В P2 предполными являются лишь следующие 5 классов: T0, T1, S, L, M.
Доказательство. 1) Покажем сначала, что ни один из этих пяти классов не содержится в
другом. Для этого достаточно для каждого из пяти вышеперечисленных классов указать четыре функции, принадлежащие данному классу, но не принадлежащие остальным четырем:
∉
∈

T0 T1
L
M
T0
0
xy
x⊕y
T1 1
xy
x⊕y⊕1
L 1 0
x⊕y
M 1 0
xy
x
S x x xy ⊕ yz ⊕ zx

S
0
1
0
0

2) Докажем, что все классы — T0, T1, S, L, M являются предполными. Действительно,
пусть N ∈ {T0 , T1 , L, M , S} и f ∉ N. Тогда система N ∪ {f} не содержится ни в одном из пяти
классов Поста (так как N не содержится в четырёх из них, а f не содержится в N). Следовательно, система N ∪ {f} — полная и N — предполный класс.
3) Пусть A — предполный класс. Тогда [A] ≠ P2 ⇒ ∃ N∈{T0, T1, L, M, S}: A ⊆ N. Если
A ≠ N, то ∃ f (f ∈ N, f ∉ A): A ∪ {f} ⊆ N ⇒ [A ∪ {f}] ≠ P2. Полученное противоречие завершает доказательство.
2 . Результаты Поста.
1) В P2 существует ровно счётное число замкнутых классов.
2) В любом замкнутом классе существует конечный базис.

§14. k-значные функции. Теорема о существовании конечной полной системы
в множестве k-значных функций.
1°. k-значные функции. Будем рассматривать конечный алфавит Ek = {0, 1, 2, …, k – 1}.
Функцией k-значной логики назовём отображение вида f (x1, x2, …, xn): Ekn → Ek .
Некоторые функции k-значной логики.
1) Константы 0, 1, 2, …, k – 1 (всего — k);
2) Тождественная функция f (x) = x;
3) Отрицания: f (x) = x = x + 1 (mod k)
— отрицание Поста,
f (x) = ~ x = (k – 1) – x
— отрицание Лукасевича;
4) Сложение по модулю k: f (x, y) = x + y (mod k);
5) Умножение по модулю k: f (x, y) = xy (mod k);
13

6) Максимум: max (x, y);
7) Минимум: min (x, y);
k − 1, x = σ
8) J σ (x ) = 
.
 0, x ≠ σ
Теорема 15. Система {0, 1, …, k – 1, max (x, y), min (x, y), J0 (x), J1 (x), …, Jk – 1 (x)} полна в Pk.
Доказательство. Утверждается, что для любой функции f (x1, …, xn) ∈ Pk справедливо
представление
f (x1 ,!, xn ) =

max

(σ1 ,!,σ n )∈Ekn

{min(J (x ),", J (x ), f (σ ,σ
σ1

1

σn

n

1

2

)}

, !, σ n ) .

Действительно, для любого набора α~ = (α1 ,α 2 ,!,α n ) ∈ Ekn рассмотрим значение правой части: если существует такое i , что σi ≠ αi, то Jσ i (α i ) = 0 и весь минимум станет равным нулю.
Таким образом, правая часть станет равна

{

(

)

}

max 0,0,!,0, min J α1 (α1 ), Jα 2 (α 2 ),!, J α n (α n ), f (α1 , α 2 ,!, α n ) ,0,!,0 ,
а учитывая то, что в Pk
Ja (a) = k – 1,
получим, что правая часть равна просто f (α1 ,α 2 ,!,α n ) . Теорема доказана.
Замечание. min (x1, x2, x3) = min (x1, min (x2, x3)); min (x1, x2, …, xn) = min (x1, min (x2, … ,xn)).
Аналогично определяется функция максимума от n переменных.
2°. Особенности k-значной логики.
1) В Pk существует континуум замкнутых классов (при k ≥ 3).
2) В Pk существуют замкнутые классы с бесконечным базисом (при k ≥ 3).
3) В Pk существуют замкнутые классы, не имеющие базиса (при k ≥ 3).

14

Глава II. Основы теории графов.
§15. Основные понятия теории графов. Изоморфизм графов. Связность.
Определение 1. Графом называется произвольное множество элементов V и произвольное семейство E пар из V. Обозначение: G = (V, E).
В дальнейшем будем рассматривать конечные графы, то есть графы с конечным множеством элементов и конечным семейством пар.
Определение 2. Если элементы из E рассматривать как неупорядоченные пары, то граф
называется неориентированным, а пары называются рёбрами. Если же элементы из E рассматривать как упорядоченные, то граф ориентированный, а пары — дуги.
Определение 3. Пара вида (a, a) называется петлёй, если пара (a, b) встречается в семействе E несколько раз, то она называется кратным ребром (кратной дугой).
Определение 4. В дальнейшем условимся граф без петель и кратных рёбер называть неориентированным графом (или просто графом), граф без петель — мультиграфом, а мультиграф, в котором разрешены петли — псевдографом.
Определение 5. Две вершины графа называются смежными, если они соединены ребром.
Определение 6. Говорят, что вершина и ребро инцидентны, если ребро содержит вершину.
Определение 7. Степенью вершины (deg v) называется количество рёбер, инцидентных
данной вершине. Для псевдографа полагают учитывать петлю дважды.
2

5

1
7

4

3

.

8

6

Утверждение 1. В любом графе (псевдографе) справедливо следующее соотношеp

ние: ∑ deg vi = 2q , где p — число вершин, а q — число рёбер.
i =1

Доказательство. Когда мы считаем степень одной вершины, мы считаем все рёбра, выходящие из неё. Вычисляя сумму всех степеней, мы получаем, что каждое ребро считается
дважды, так как оно инцидентно двум вершинам (петли по определению степени также посчитаются дважды). Поэтому общая сумма будет равна удвоенному числу рёбер. Утверждение доказано.
Определение 8. Пусть множество вершин графа V = {v1, v2, …, vp}. Тогда матрицей
смежности этого графа назовём матрицу A = ||aij||, где aij = 1, если вершины vi и vj смежны
(2, 3, … для мультиграфа или псевдографа) и 0 в противном случае, aii при этом равно числу
петель в вершине vi.
Определение 9. Два графа (или псевдографа) G1 = (V1 , E1 ) и G2 = (V2 , E2 ) называются изоморфными, если существуют два взаимно однозначных отображения φ1 : V1 → V2 и
φ2: E1 → E2 такие, что для любых двух вершин u и v графа G1 справедливо φ2 (u, v) =
= (φ1 (u), φ1 (v)).
Определение 10 (изоморфизм графов без петель и кратных рёбер). Два графа G1 =
= (V1, E1) и G2 = (V2, E2) называются изоморфными, если существует взаимно однозначное
отображение φ1: V1 → V2 такое, что (u, v) ∈ E1 ⇔ (φ (u), φ (v)) ∈ E2.
Определение 11. Граф G1 = (V1 , E1 ) называется подграфом графа G = (V, E), если
V1 ⊆ V, E1 ⊆ E.

15

Определение 12. Путём в графе G = (V, E) называется любая последовательность вида
v0, (v0, v1), v1, (v1, v2), …, vn – 1, (vn – 1, vn), vn.
Число n в данных обозначениях называется длиной пути.
Определение 13. Цепью называется путь, в котором нет повторяющихся рёбер.
Определение 14. Простой цепью называется путь без повторения вершин.
Утверждение 2. Пусть в G = (V, E) v1 ≠ v2 и пусть P — путь из v1 в v2. Тогда в P можно
выделить подпуть из v1 в v2, являющийся простой цепью.
Доказательство. Пусть данный путь — не простая цепь. Тогда в нём повторяется некоторая вершина v, то есть он имеет вид: P1 = v0C1vC2vC3v2. Тогда он содержит подпуть P2 =
= v0C1vC3v2. Если в P2 повторяется некоторая вершина, то аналогично удалим ещё кусок и
так далее. Процесс должен закончиться, так как P1 — конечный путь. Утверждение доказано.
Определение 15. Путь называется замкнутым, если v0 = vn.
Определение 16. Путь называется циклом, если он замкнут, и рёбра в нём не
повторяются.
Определение 17. Путь называется простым циклом, если v0 = vn и вершины не повторяются.
Определение 18. Граф G = (V, E) называется связным, если для любых вершин vi, vj ∈ V
(vi ≠ vj) существует путь из vi в vj.
Рассмотрим отношение vi → vj существования пути из vi в vj. Оно
1) симметрично, так как (vi → vj) ⇒ (vj → vi),
2) транзитивно, так как (vi → vj) & (vj → vk) ⇒ (vi → vk),
3) рефлексивно, так как ∀i (vi → vi).
Таким образом, получено, что vi → vj — отношение эквивалентности и множество вершин
разбивается на конечное число классов эквивалентности: V → V1 ∪ V2 ∪ … ∪ Vk, Vi ∩ Vj = ∅ ⇐
⇐ i ≠ j. При этом граф G разбивается на связные подграфы, которые называются компонентами
связности.
V1

V2

Vk

…

Связные компоненты графа G

§16. Деревья. Свойства деревьев.
Определение 1. Деревом называется связный граф без циклов.
Определение 2. Подграф G1 = (V1, E1) графа G = (V, E), называется остовным деревом в
графе G = (V, E), если G1 = (V1, E1) — дерево и V1 = V.
Лемма 1. Если граф G = (V, E) связный и ребро (a, b) содержится в некотором цикле в
графе G, то при выбрасывании из графа G ребра (a, b) снова получится связный граф.
Доказательство. Это утверждение следует из того, что при выбрасывании из графа G
ребра (a, b) вершины a и b всё равно остаются в одной связной компоненте, поскольку из a в
b можно пройти по оставшейся части цикла. Лемма доказана.
Теорема 1. Любой связный граф содержит хотя бы одно остовное дерево.
Доказательство. Если в G нет циклов, то G является искомым остовным деревом. Если в G есть циклы, то удалим из G какое-нибудь ребро, входящее в цикл. Получится некоторый подграф G1. По лемме 1 G1 — связный граф. Если в G1 нет циклов, то G1 и есть искомое остовное дерево, иначе продолжим этот процесс. Процесс должен завершиться, так
как E — конечное множество. Теорема доказана.
16

Лемма 2. Если к связному графу добавить новое ребро на тех же вершинах, то появится цикл.
Доказательство. Рассмотрим произвольный связный граф G = (V, E). Пусть u ∈ V,
v ∈ V, (u, v) ∉ E. Так как G — связный граф, то в нём есть путь из v в u. Тогда в G есть и простая цепь C из v в u. Поэтому в полученном графе есть цикл C, (u, v), v. Лемма доказана.
Лемма 3. Пусть в графе G = (V, E) p вершин и q рёбер. Тогда в G не менее p – q связных
компонент. Если при этом в G нет циклов, то G состоит ровно из p – q связных компонент.
Доказательство. Пусть к некоторому графу H, содержащему вершины u и v, добавляется ребро (u, v). Тогда если u и v лежат в разных связных компонентах графа H, то число связных компонент уменьшится на 1. Если u, v лежат в одной связной компоненте графа H, то
число связных компонент не изменится. В любом случае, число связных компонент уменьшается не более чем на 1. Значит, при добавлении q рёбер число связных компонент уменьшается не более чем на q. Так как граф G получается из графа G1 = (V, ∅) добавлением q рёбер, то в G не менее p – q связных компонент. Пусть теперь в G нет циклов, и пусть в процессе получения G из G1 добавляется ребро (u, v). Если бы u, v лежали уже в одной связной
компоненте, то в G, согласно лемме 2, возникал бы цикл. Следовательно, u, v лежат в разных
связных компонентах и при добавлении ребра (u, v) число связных компонент уменьшается
ровно на 1. Тогда G состоит ровно из p – q связных компонент. Лемма доказана.
Теорема 2 (о различных определениях дерева). Следующие пять определений эквивалентны (p — число вершин, q — число рёбер):
1) G — дерево;
2) G — без циклов и q = p – 1;
3) G — связный граф и q = p – 1;
4) G — связный граф, но при удалении любого ребра становится несвязным;
5) G — без циклов, но при добавлении любого ребра на тех же вершинах появляется цикл.
Доказательство. Докажем следующие переходы: 1) ⇒ 2) ⇒ 3) ⇒ 4) ⇒ 5) ⇒ 1), откуда
будет следовать, что из любого условия вытекает любое другое.
1) ⇒ 2): так как G — связный граф и G не содержит циклов, то p – q = 1 по лемме 3. Отсюда q = p – 1.
2) ⇒ 3): по лемме 3 в G число связных компонент равно p – q = 1, то есть G — связный граф.
3) ⇒ 4): при удалении одного ребра p – q = 2. Тогда по лемме 3 число связных компонент не менее чем p – q = 2.
4) ⇒ 5): если G имеет цикл, то согласно лемме 1 можно выбросить одно ребро так, что
граф останется связным. Согласно лемме 2, если добавить любое новое ребро к связному
графу G на тех же вершинах, то появится цикл.
5) ⇒ 1): если G не связный граф и вершины u, v лежат в разных связных компонентах
графа G, то добавление к G ребра (u, v), очевидно, не порождает циклов, что противоречит
5). Отсюда следует, что G — связный граф. Теорема доказана.

§17. Корневые деревья. Верхняя оценка их числа.
Определение 1. Любое дерево, в котором выделена одна вершина, называемая корнем,
называется корневым деревом.
Определение 2. 1) Граф, состоящий из одной вершины, которая выделена, называется
корневым деревом.
2) Пусть имеются корневые деревья D1, D2, …, Dm с корнями v1, v2, …, vm, Di = (Vi, Ei),
Vi ∩ Vj = ∅ (i ≠ j). Тогда граф D = (V, E), полученный следующим образом:
V = V1 ∪ V2 ∪ … ∪ Vm ∪ {v} (v ∉ Vi, ∀i ), E = E1 ∪ E2 ∪ … ∪ Em ∪ {(v, v1), (v, v2), …,(v, vm)}
и в котором выделена вершина v, называется корневым деревом.
3) Только те объекты являются корневыми деревьями, которые можно построить согласно пунктам 1) и 2).

17

При таком определении D1,D2,…,Dm называются поддеревьями дерева D.
v1
D1

…

v2
D2

vm
Dm

…

v

Утверждение. Определения 1 и 2 эквивалентны.
Определение 3. Упорядоченным корневым деревом называется корневое дерево, в
котором
1) задан порядок поддеревьев и
2) каждое поддерево Di является упорядоченным поддеревом.
Дерево с одной вершиной также является упорядоченным поддеревом.
Теорема 3. Число упорядоченных корневых деревьев с q рёбрами не превосходит 4q.
Доказательство. Рассмотрим алгоритм обхода упорядоченного дерева, называемого
«поиском в глубину». Этот обход описывается рекурсивно следующим образом:
1) Начать с корня. Пока есть поддеревья выполнять:
2) перейти в корень очередного поддерева, обойти это поддерево «в глубину».
3) Вернуться в корень исходного поддерева.
В результате обход «в глубину» проходит по каждому ребру дерева ровно 2 раза: один
раз при переходе в очередное поддерево, второй раз при возвращении из этого поддерева. В
соответствии с обходом «в глубину» будем строить последовательность из нулей и единиц,
записывая на каждом шаге нуль или единицу, причём нуль будем записывать, если происходит переход в очередное поддерево, а единицу, если мы возвращаемся из поддерева. Получим последовательность из 0 и 1 длины 2q, которую назовём кодом дерева. По этому коду
однозначно восстанавливается дерево, поскольку каждый очередной разряд однозначно указывает, начинать ли строить новое очередное поддерево или возвращаться на ярус ближе к
корню. Таким образом, упорядоченных корневых деревьев с q рёбрами не больше, чем последовательностей из 0 и 1 длины 2q, а их число равно 22q = 4q. Теорема доказана.
Изоморфизм корневых деревьев определяется так же, как и изоморфизм графов, но с
дополнительным требованием: корень должен отображаться в корень. Для упорядоченных
корневых деревьев также требуется сохранение порядка поддеревьев.
Следствие. Число неизоморфных корневых деревьев с q рёбрами и число неизоморфных деревьев с q рёбрами не превосходит 4q.
Доказательство. Выделяя в неизоморфных деревьях по одной вершине, мы получим
неизоморфные корневые деревья. Упорядочивая поддеревья в неизоморфных корневых деревьях, мы получим различные упорядоченные корневые деревья. Поэтому число неизоморфных деревьев с q рёбрами не превосходит числа неизоморфных корневых деревьев с q
рёбрами, которое, в свою очередь, не превосходит числа различных упорядоченных корневых деревьев с q рёбрами. Отсюда и из теоремы следует утверждение следствия. Следствие
доказано.

§18. Геометрическая реализация графов.
Теорема о реализации графов в трёхмерном пространстве.
Определение. Пусть задан некоторый неориентированный граф G = (V, E). Пусть любой вершине vi графа G сопоставлена некоторая точка ai: vi → ai, ai ≠ aj (i ≠ j), а любому ребру
e = (a, b) сопоставлена некоторая непрерывная кривая L, соединяющая точки ai и aj и не проходящая через другие точки ak (k ≠ i, j). Тогда если все кривые, сопоставленные рёбрам, не
18

имеют общих точек, кроме концевых, то говорят, что задана геометрическая реализация
графа G.
геометрическая реализация графа K 4

не является геометрической реализацией графа K 4

Теорема 4. Для любого графа существует его реализация в трёхмерном пространстве.
Доказательство. Возьмём в пространстве любую прямую l и разместим на ней все вершины графа G. Пусть в G имеется q рёбер. Проведём связку из q различных полуплоскостей
через l. После этого каждое ребро графа G можно изобразить линией в своей полуплоскости
и они, очевидно, не будут пересекаться. Теорема доказана.

§19. Планарные (плоские) графы. Формула Эйлера.
Определение 1. Граф называется планарным, если существует его геометрическая реализация на плоскости.
Определение 2. Если имеется планарная реализация графа и мы «разрежем» плоскость
по всем линиям этой планарной реализации, то плоскость распадётся на части, которые называются гранями этой планарной реализации (одна из граней бесконечна, она называется
внешней гранью).
Теорема 5 (формула Эйлера). Для любой планарной реализации связного планарного
графа G = (V, E) с p вершинами, q рёбрами и r гранями выполняется равенство: p – q + r = 2.
Доказательство. Докажем теорему при фиксированном p индукцией по q. Так как G —
связный граф, то q ≥ p – 1.
a) Базис индукции: q = p – 1. Так как G — связный и q = p – 1, то согласно пункту 3
теоремы 2 G — дерево, то есть, в G нет циклов. Тогда r = 1. Отсюда p – q + r =
= p – (p – 1) + 1 = 2.
b) Пусть для q: p – 1 ≤ q < q0 теорема справедлива. Докажем, что для q = q0 она также
справедлива. Пусть G — связный граф с p вершинами и q0 рёбрами и пусть в его
планарной реализации r граней. Так как q0 > p – 1, то G — не дерево. Следовательно,
в G есть цикл. Пусть ребро e входит в цикл. Тогда к нему с двух сторон примыкают
разные грани. Удалим ребро e из G. Тогда две грани сольются в одну, а полученный
граф G1 останется связным. При этом получится планарная реализация графа G1 с p
вершинами и q0 – 1 рёбрами и r – 1 гранями. Так как q0 – 1 < q0, то, по предположению индукции, для G1 справедлива формула Эйлера, то есть p – (q0 – 1) + (r – 1) = 2,
откуда p – q0 + r = 2. Что и требовалось доказать.
Следствие 1. Формула Эйлера справедлива и для геометрической реализации связных
графов на сфере.
Доказательство. Пусть связный граф G с p вершинами и q рёбрами реализован на сфере S так, что число граней равно r. Пусть точка A на сфере не лежит на линиях этой геометрической реализации. Пусть P — некоторая плоскость. Поставим сферу S на плоскость P так,
чтобы точка A была самой удалённой от плоскости. Спроектируем S на P центральным проектированием с центром в точке A. Тогда на плоскости P мы получим геометрическую реализацию связного графа с p вершинами и q рёбрами, причём число граней будет равно r
(грань на сфере, содержащая A, отображается на внешнюю грань на плоскости). По теореме
получаем p – q + r = 2. Следствие доказано.

19

Следствие 2. Для любого выпуклого многогранника справедливо равенство p – q + r = 2,
где p — число вершин, q — число рёбер, r — число граней.
Доказательство. Пусть выпуклый многогранник M имеет p вершин, q рёбер и r граней.
Пусть O — внутренняя точка многогранника. Разместим сферу S с центром в точке O настолько большого радиуса, чтобы M целиком содержался в S. Рассмотрим центральное проектирование с центром в точке O, и спроектируем вершины и рёбра M на S. Тогда на S мы
получим геометрическую реализацию некоторого связного графа с p вершинами, q рёбрами
и r гранями. Отсюда согласно следствию 1 p – q + r = 2. Следствие 2 доказано.

§20. Доказательство непланарности графов K5 и K3,3.
Теорема Понтрягина-Куратовского (доказательство в одну сторону).
Определение 1. Графом K5 называется граф с пятью вершинами, в котором каждая пара
вершин соединена ребром.

K5

Теорема 6. Граф K5 не планарен.
Доказательство. Допустим, что для графа K5 существует планарная реализация. Так как
граф K5 связен, то для этой планарной реализации справедлива формула Эйлера p – q + r = 2.
Поскольку в графе K5 имеем p = 5 и q = 10, то число всех граней должно равняться r = 2 – p +
+ q = 7. Пусть грани занумерованы 1, 2, …, r и пусть при обходе i-ой грани по периметру (по
её краю) проходится qi рёбер. Так как при этом каждое ребро обходится дважды (оно являетr
ся стороной для двух граней), то ∑i =1 qi = 2q = 20 . Но в каждой грани не менее трёх сторон.
Поэтому qi ≥ 3 для всех i. Отсюда

∑

r
i =1

qi ≥ 3r = 21 . Получаем 20 ≥ 21 — противоречие. Зна-

чит, для графа K5 не существует планарной реализации.
Определение 2. Графом K3,3 называется граф с шестью вершинами a1, a2, a3, b1, b2, b3, в
котором каждая вершина ai соединена ребром с каждой вершиной bj и других рёбер нет.
a1

a2

a3

b1

b2

b3

K3,3

Теорема 7. Граф K3,3 не планарен.
Доказательство. Допустим, что для графа K3,3 существует планарная реализация. Так
как граф K3,3 связен, то для этой планарной реализации справедлива формула Эйлера p – q +
+ r = 2. Поскольку в графе K3,3 имеем p = 6 и q = 9, то число всех граней должно равняться
r = 2 – p + q = 5. Так же, как в доказательстве предыдущей теоремы, получаем, что
r
∑i =1 qi = 2q = 18 , где qi — число сторон в i-ой грани. Но в графе K3,3 нет циклов длины 3. По-

20

этому в каждой грани не менее 4 сторон. Следовательно, qi ≥ 4 для всех i. Отсюда
r
∑i=1 qi ≥ 4r = 20 . Получаем 18 ≥ 20 — противоречие. Значит, для графа K3,3 не существует
планарной реализации.
Определение 3. Подразделением ребра (a, b) называется операция, состоящая в следующих действиях:
1) удаление (a, b),
2) добавление новой вершины c,
3) добавление рёбер (a, c) и (c, b).
Определение 4. Граф H называется подразделением графа G, если H можно получить из
G путём конечного числа подразделений своих рёбер.
Определение 5. Два графа называются гомеоморфными, если существуют их подразделения, которые изоморфны.
Теорема 8 (Понтрягина-Куратовского). Граф является планарным тогда и только тогда, когда он не содержит ни одного подграфа, гомеоморфного графам K5 или K3,3.
Доказательство. Необходимость. Пусть G — планарный. Допустим, что он содержит
подграф G1, гомеоморфный графу K5 или K3,3. Рассмотрим планарную реализацию графа G.
Удалив лишние вершины и рёбра, мы получим планарную реализацию подграфа G1. Но G1
геометрически — это граф K5 или K3,3 с точками на рёбрах. Если проигнорировать эти точки,
то мы получим планарную реализацию графа K5 или K3,3. Но это невозможно в силу теорем 1
и 2. Необходимость доказана.
Достаточность без доказательства.

§21. Теорема о раскраске планарных графов в пять цветов.
Лемма 1. Для любой геометрической реализации на плоскости связного планарного графа с q рёбрами выполняется равенство:
r

∑q
i =1

i

= 2q ,

где суммирование ведётся по всем граням (включая внешнюю).
Доказательство. Равенство следует из того, что у каждого ребра две стороны и при
суммировании qi каждое ребро учитывается дважды: либо оно входит в границы двух соседних граней, либо оно дважды учитывается в одной грани. Лемма доказана.
Теорема 9. Если в связном планарном графе G = (V, E) с p вершинами и q рёбрами, отличном от дерева, нет циклов длины меньше k (k ≥ 3), то q ≤ k −k 2 ( p − 2) .
Доказательство. Так как по условию qi ≥ k, то из леммы получаем 2q ≥ kr и r ≤

2q
k

. Из

формулы Эйлера r = 2 – p + q. Отсюда 2 − p + q ≤ 2kq . Далее (k – 2)q ≤ k(p – 2) и q ≤ k −k 2 ( p − 2) .
Теорема доказана.
Следствие. В любом связном планарном графе G = (V, E) без петель и кратных рёбер с
p ≥ 3 вершинами и q рёбрами справедливо неравенство: q ≤ 3( p – 2).
Определение 1. Подмножество V1 ⊆ V вершин графа G = (V, E) называется независимым, если никакие две вершины из V1 не соединяются ребром.
Определение 2. Пусть есть некоторое множество C = {C1, C2, …, Cm} — множество
цветов. Тогда раскраской графа G = (V, E) (вершинной) называется любое отображение
φ: V → C. Раскраска называется правильной, если для любого цвета вершины этого цвета образуют независимое множество.
Лемма 2. В планарном графе без петель и кратных рёбер существует вершина v:
deg v ≤ 5.

21

Доказательство. Пусть G — планарный граф с p вершинами и q рёбрами. Пусть в G нет
вершин степени 0 и 1. Тогда q ≤ 3(p – 2) < 3p. Пусть dmin — минимальная степень вершин в
G. Тогда получаем
p

6 p > 2q = ∑ deg vi ≥ pd min .
i =1

Отсюда dmin < 6, то есть dmin ≤ 5. Лемма доказана.
Теорема 10. Вершины любого планарного графа можно правильно раскрасить в не более чем 5 цветов.
Доказательство. Проведём индукцию по числу вершин p.
1) Базис индукции: p = 1 — очевидно.
2) Пусть для p < p0 утверждение справедливо и пусть G = (V, E) — планарный граф с
|V| = p0. Согласно лемме 2 в G есть вершина v степени не более 5. Рассмотрим укладку на
плоскости графа G без пересечения рёбер. Удалим из G вершину v и все инцидентные ей
рёбра. Получим планарный граф G1 с числом вершин p0 – 1. По предположению индукции
его вершины можно правильно раскрасить в 5 цветов C1, C2, C3, C4, C5. Пусть в G вершина v
смежна с v1, v2, …, vk, где k ≤ 5. Возможны два случая:
a) Среди цветов вершин v1, v2, …, vk в G нет цвета Ci (1 ≤ i ≤ 5). Тогда вершине v
припишем цвет Ci и получим правильную раскраску графа G в 5 цветов.
b) Степень вершины v равна 5 и среди вершин v1, v2, …, v5 в G1 есть все 5 цветов.
Без ограничения общности будем считать, что в укладке графа G рёбра (v, v1),
(v, v2), (v, v3), (v, v4), (v, v5) выходят из v в порядке по часовой стрелке и что
C (vi) = Ci, i = 1, …, 5. Пусть A — множество всех вершин в G1, до которых можно
дойти из v1 по рёбрам графа G1, используя только вершины цветов C1 и C3. Возможны два варианта:
i) v3∉A. Тогда в A поменяем цвета C1 → C3, C3 → C1. Так как вершины из A не
смежны с другими вершинами цветов C1 и C3, то останется правильная раскраска и среди v1, v2, v3, v4, v5 не будет цвета C1. Тогда вершине v припишем
цвет C1.
ii) v3∈A. Это значит, что в A есть цепь из v1 в v3, все вершины которой имеют
цвета C1 и C3. Эта цепь вместе с рёбрами (v3, v) и (v, v1) образует цикл в G,
причём вершины v2 и v4 лежат по разные стороны от этого цикла. Это значит,
что из v2 нельзя пройти в v4 в графе A только по вершинам цветов C2 и C4.
Пусть B — множество всех вершин в G, до которых можно дойти из v2 по
рёбрам графа G, используя только вершины цветов C2 и C4. Тогда v4∉B и далее поступаем как в i).
В любом случае вершины графа G можно правильно раскрасить в не более чем 5 цветов,
и теорема доказана.

22

Глава III. Основы теории управляющих систем.
§22. Схемы из функциональных элементов.
Реализация функций алгебры логики схемами.
Определение 1. Вершины орграфа, в которые не входит ни одной дуги, называются
истоками.
Определение 2. Орграф называется ациклическим, если в нем нет ориентированных
циклов.
Определение 3. В ациклическом орграфе глубиной вершины v называется максимальное
число дуг в ориентированном пути из какого-нибудь истока в вершину v.
Если в ациклическом орграфе есть дуга (v1, v2), то глубина v2 больше глубины v1.
Определение 4. Орграф называется упорядоченным, если для каждой вершины vi, в которую входит ki дуг, задан порядок e1 , e2 ,!, eki этих дуг.
Определение 5. Систему Б = {g1, g2, …, gm}, где все gi — функции алгебры логики, будем называть базисом функциональных элементов.
Определение 6. Схемой из функциональных элементов в базисе Б называется ациклический упорядоченный орграф, в котором:
1) каждому истоку приписана некоторая переменная, причем разным истокам приписаны разные переменные (истоки при этом называются входами схемы, а приписанные им переменные — входными переменными);
2) каждой вершине, в которую входят k ≥ 1 дуг, приписана функция из базиса Б, зависящая от k переменных (вершина с приписанной функцией при этом называется функциональным элементом);
3) некоторые вершины выделены как выходы (истоки одновременно могут являться
выходами).
Индукцией по глубине q вершины v определяется функция fv, реализуемая в данной
вершине. Если q = 0, то есть v — исток, и v приписана переменная xi, то fv ≡ xi. Пусть реализуемые функции уже определены для всех вершин глубины меньшей, чем q0, и глубина v
равна q0. Пусть в v входят дуги e1, e2, …, ek из вершин v1, v2, …, vk и в них реализуются функции f1, f2, …, fk. Пусть вершине v приписана функция g (x1, …, xk). Тогда в v реализуется
функция fv = g (f1, f2, …, fk).
Определение 7. Будем говорить, что схема реализует систему функций, реализуемых в
ее выходах.
Определение 8. Сложностью схемы из функциональных элементов называется число
функциональных элементов в схеме.
В дальнейшем по умолчанию будем подразумевать под базисом функциональных элементов систему Б0 = ∨,&, . Так как все эти функции симметричны относительно своих переменных, то дуги, входящие в каждую вершину, можно не упорядочивать.
Пример. Полусумматор. Пусть v и v1 — выходы на рисунке, f v = xy & (x ∨ y ) = x ⊕ y ;
f v1 = xy . Сложность (число элементов) полусумматора равна 4.

{

}

x

y

xy &
xy

_

v1

v2
v &

∨

Полусумматор Σ′

23

x∨y

В дальнейшем при построении схем ячейку полусумматора будем обозначать просто
x

y
Σ′
⊕

&

Ячейка полусумматора Σ′

Пусть есть 2 n-разрядных числа, и требуется найти их сумму (в дальнейших обозначениях xi, yi — разряды чисел, а qi — единицы переноса).
q0
+
z0

q1
x1
y1
z1

q2
x2
y2
z2

!
!
!
!

qn−1
xn−1
yn−1
z n−1

xn
yn
zn

При i = 1, 2, …, n – 1 задача решается системой функций
zi = xi ⊕ yi ⊕ qi ,


qi−1 = m(xi , yi , qi ) = xi yi ∨ yi qi ∨ qi xi .
Таким образом, ячейку сумматора можно построить следующим образом:
x

y

q

Σ′
·

Σ′
⊕

·

⊕
v′′

∨
v′
Ячейка сумматора Σ1

где fv′′ = (x ⊕ y) ⊕ q, fv′ = xy ∨ (x ⊕ y) · q = xy ∨ (x ∨ y) · q = m (x, y, q). Ячейку сумматора будем
обозначать Σ1 и в дальнейшем в схемах подставлять вместо ячейки сумматора символ Σ1 с
тремя входами (x, y, z) и двумя выходами (z, q′).
x

y

q

Σ1
q′

z

Ячейка сумматора Σ1

Заметим, что сложность схемы, реализующей ячейку сумматора равна L (Σ1) = 9. Очевидно,
zn = xn ⊕ yn, qn – 1 = xnyn, z0 = q0.

24

§23. Сумматор. Верхняя оценка сложности сумматора. Вычитатель.
Для набора α~ = (α1 ,α 2 ,! ,α n ) будем обозначать α~ = (α1α 2 !α n )2 .
Определение 1. Сумматором Sn порядка n называется схема с 2n входами x1, x2, …, xn,
y1, y2, …, yn и n + 1 выходом z0, z1, z2, …, zn такая, что ~
z = S n (~
x, ~
y) = ~
x+~
y.
Теорема 1. Существует схемный сумматор порядка n в базисе {∨, &, } с числом элементов 9n – 5.
Доказательство. Построим искомый схемный сумматор. Для этого возьмём одну ячейку полусумматора, содержащую четыре элемента и n – 1 ячейку сумматора, каждая из которых содержит девять элементов. Построим из этих частей сумматор.
xn yn
Σ′
zn

xn – 1 yn – 1

xn – 2 yn – 2

Σ1

x1

Σ1

zn – 1

Σ1

…

zn – 2

y1

z1

z0

Сумматор Sn

Вычислим сложность построенной схемы: L (Sn) = 9L (Σ1) + L (Σ′) = 9(n – 1) + 4 = 9n – 5. Теорема доказана.
Определение 2. Вычитателем Wn порядка n называется схема с 2n входами x1, x2, …, xn,
y1, y2, …, yn и n выходами z1, z2, …, zn такая, что при ~
x ≥ ~
y
~
z = W (~
x, ~
y) = ~
x − ~
y .
Теорема 2. Существует схемный вычитатель порядка n в базисе {∨, &,
элементов 11n – 5.
Доказательство. Заметим предварительно, что

α~ = (α1α 2 !α n ) = 2n − 1 − α~ .
Действительно,

(α1α 2 !α n )2
(α1α 2 !α n )2
(1 1 ! 1 )2

+

.
= 2 −1
n

Тогда вычитатель реализуется схемой
x1 … xn y1 … yn
–

–

Sn
–

…

z0 z1

–

zn

Вычитатель Wn

25

} с числом

((

)

)

Wn (~
x, ~
y)= ~
x−~
y = 2 n − 1 − 2n − 1 − ~
x +~
y
и его можно построить, используя 2n отрицаний и 1 сумматор порядка n. При этом L (Wn) =
= 2n + L (Sn) = 2n + (9n – 5) = 11n – 5. Так как ~
x ≥ ~
y , то 2n − 1 − ~
x +~
y ≤ 2n − 1 , и выход вычитателя определен. Теорема доказана.

(

)

§24. Метод Карацубы построения схемы для умножения,
верхняя оценка её сложности.
Определение 1. Умножителем Mn порядка n называется схема с 2n входами x1, x2, …,
xn, y1, y2, …, yn и 2n выходами z1, …, z2n такая, что ~
z = M n (~
x, ~
y) = ~
x⋅~
y . При этом
0 ≤

0 ≤

~
x ≤ 2n − 1 < 2 n
x⋅~
y < 22 n .
⇒~
n
n
~
y ≤ 2 −1 < 2

Определение 2. Через M (n) обозначим наименьшую сложность умножителя порядка n
в базисе {∨, &, }.
Утверждение. Существует схема из функциональных элементов для умножения nразрядного числа X на 1-разрядное число y с числом элементов n.
Доказательство. Действительно, если X = |(x1, x2, …, xn)| и Xy = Z = |(z1, z2, …, zn)|, то zi =
= xiy для всех i = 1, 2, …, n. Следовательно, для реализации такой схемы понадобится ровно n
элементов, реализующих конъюнкцию. Утверждение доказано.
При умножении двух n-разрядных чисел X и Y «в столбик» можно n раз умножить X на
1-разрядное число (всего n2 конъюнкций) и затем n – 1 раз сложить числа длиной не более
2n. Для реализации такой схемы необходим также n – 1 сумматор порядка 2n. Согласно теореме 1, сложность сумматора порядка 2n равна L (S2n) = 9 · 2n – 5 = 18n – 5, и сложность подобного умножителя составит n2 + (n – 1) · (18n – 5) = 19n2 – 23n + 5. Такой алгоритм (схема)
имеет сложность по порядку n2. Следующая теорема показывает, что такой алгоритм умножения «в столбик» не оптимален по порядку.
Лемма 1. Существует такая константа C1 > 0, что M (n + 1) ≤ M (n) + C1 n для всех n.
Доказательство. Пусть требуется перемножить два (n + 1)-разрядных числа
~
x = (x0 x1 ! xn ) и ~
y = ( y0 y1 ! yn ) . Тогда



~
x~
y =  x0 ⋅ 2 n + x1 ! xn  y0 ⋅ 2 n + y1 ! yn  = x0 y0 ⋅ 2 2 n + (x0 ⋅ Y + y0 ⋅ X )⋅ 2 n + X ⋅ Y .

&
#%#
$ 
&
#%#
$
X
Y



Поэтому для вычисления ~
x~
y достаточно использовать умножитель Mn со сложностью M (n)
для вычисления XY, 2n элементов конъюнкции для вычисления x0Y и y0X, 1 элемент конъюнкции для вычисления x0y0 и 3 сумматора порядка не более 2n + 2, так как ~
x~
y < 22 n + 2 . Отметим, что числа x0y0, x0Y и y0X надо подавать на сумматоры со сдвигом, одновременно подавая на младшие разряды 0. При этом 0 можно предварительно получить подсхемой с 2 элементами, реализующей x0 x0 = 0 . Так как сложность каждого сумматора можно сделать не
более 9(2n + 2), а сложность Mn равна M (n), то сложность полученной схемы будет не больше, чем M (n) + C1n для некоторой константы C1. Лемма доказана.
Лемма 2 (основная) [Карацуба А. А.]. Существует константа C2 такая, что
M (2n) ≤ 3M (n) + C2n
для всех n.
Доказательство. Пусть нужно перемножить два 2n-разрядных числа ~
y . Разобьём
x и ~
их на части, содержащие по n разрядов:

26





~
x =  x1 x2 ! xn xn+1 ! x2 n  , ~
y =  y1 y2 ! yn yn+1 ! y2 n  .
&
#%#
$ &#%#
$
&#%#
$ &#%#
$
X1
X2
Y1
Y2




Тогда ~
y = Y1·2n + Y2 и
x = X1·2n + X2, ~
~
x~
y = X1Y1 · 22n + (X1Y2 + X2Y1) · 2n + X2Y2 = X1Y1 · 22n + [(X1 + X2)(Y1 + Y2) – X1Y1 – X2Y2] · 2n + X2Y2.
Так как X1Y2 + X2Y1 ≥ 0, то при вычитании в квадратной скобке не возникнет отрицательных
чисел. Таким образом, схему для умножения ~
x~
y можно построить, используя два умножителя Mn с числом элементов M (n) в каждом для вычисления X1Y1 и X2Y2, умножитель Mn+1 с
числом элементов M (n + 1) для вычисления (X1 + X2)(Y1 + Y2), 4 сумматора порядка не более
4n (так как ~
x~
y < 24 n ) и два вычитателя порядка 2n + 2. В некоторых сумматорах опять на
младшие разряды надо подавать 0, который реализуем подсхемой с 2 элементами: 0 = xx ,
где x — любая входная переменная. Для построения схемы M2n с учётом леммы 1 получим
для некоторых констант C и C2:
M (2n) ≤ 2 M (n) + M (n + 1) + Cn ≤ 3 M (n) + C1n + Cn = 3 M (n) + C2n.
Лемма доказана.
Лемма 3. Существует такая константа C3 > 0, что для любого натурального k верно
M (2k) ≤ C33k.
k
Доказательство. Положим f (k ) = M3(2k ) . Тогда из леммы 2 имеем

( )

( )

M 2k
M 2 k −1 C2  2 
≤
+  
3k
3k −1
3 3
C  2
f (k ) ≤ f (k −1) + 2  
3  3

k −1

C  2
≤ f (k − 2) + 2  
3  3

k −2

C  2
+ 2 
3  3

k −1

k −1

и

2
k −1
C2  2  2 
 2 
≤ ! ≤ f (1) +  +   + ! +    ≤ C3
3  3  3 
 3  

для некоторой константы C3, поскольку сумма в квадратных скобках не превосходит сумму 2
бесконечно убывающей геометрической прогрессии с первым членом 23 и знаменателем 23 .
Таким образом,

( ) ≤ C и M (2k) ≤ C 3k. Лемма доказана.
3
3

M 2k
3k

Теорема 3. Существует схемный умножитель в базисе {∨, &, } с числом элементов

(

)

O nlog 2 3 .
Доказательство. Пусть n — любое натуральное число и n>1. Тогда существует натуральное k такое, что 2k–1 < n ≤ 2k. Для умножения n-разрядных чисел будем использовать схему M 2 k с числом элементов M (2k), подавая на старшие 2k – n разрядов обоих сомножителей 0,
предварительно реализованный подсхемой из 2 элементов. Тогда имеем, исходя из леммы 3

( )

M (n ) ≤ M 2 k + 2 ≤ C3 3k + 2 = 3C3 3k −1 + 2 = 3C3 2(k −1)log 2 3 + 2 < 3C3n log 2 3 + 2 ≤ Cn log 2 3
для некоторой константы C. Теорема доказана.
Замечание. Существует практически применимый метод Шёнхаге-Штрассена умножения с оценкой сложности O (n log n · log log n).

27

§25. Дешифратор. Асимптотика сложности дешифратора. Верхняя оценка
сложности реализации произвольной функции алгебры логики.
Определение. Дешифратором Qn порядка n называется схема из функциональных элементов с n входами x1, x2, …, xn и 2n выходами z0 , z1 ,!, z 2n −1 такая, что если |x1x2…xn| = i, то
1, x1 ! xn = i
zi = 1 и zj = 0 при i ≠ j: zi (x1 ,!, xn ) = 
.
0, x1 ! xn ≠ i
Заметим, что если i = (i1, i2, …, in)2, то zi (x1 ,!, xn ) = x1i1 x2i2 " xnin .
Лемма 4. Существует дешифратор Qn с числом элементов, не превосходящим n2n + 1.
Доказательство. Для реализации каждой zi достаточно взять ровно n–1 конъюнкций и
не более n отрицаний, то есть всего менее, чем 2n функциональных элементов. Всего различных конъюнкций ровно 2n, и сложность дешифратора не превосходит n2n + 1. Лемма доказана.
Теорема 4. Сложность минимального схемного дешифратора порядка n не меньше, чем

( )
n

2n и асимптотически не больше, чем 2n + O n ⋅ 2 2 .
Доказательство. 1) Поскольку у дешифратора Qn ровно 2n выходов, на которых реализуются различные функции, не равные входным переменным, сложность минимального дешифратора не меньше, чем 2n.
x1
…
xk
xk + 1
…
xn
Qk′

Qn′′− k

y0 y1 … Q′[j] … y 2k −1

y′0 y′1 … Q′′[l] … y ′2n − k −1

&

&

Qn [1]

Qn [i]

( )
n

2) Докажем существование дешифратора со сложностью 2 n + O n ⋅ 2 2 . Разобьём набор
входных переменных x = (x1, …, xn) на поднаборы x′ = (x1, …, xk) и x′′ = (xk + 1, …, xn), где k —
некоторый параметр и 1 ≤ k ≤ n – 1. Пусть Q′ и Q′′ —функциональные дешифраторы порядка
k и n – k от базовых переменных x′ и x′′, а Σ′ и Σ′′ — соответствующие им схемные дешифраторы, построенные по лемме. Легко видеть, что любую конъюнкцию Qn [i], 1 ≤ i ≤ 2n, можно
представить в виде Qn [i] = Q ′[j]·Q′′ [l], где i = 2n – k(j – 1) + l и 1 ≤ j ≤ 2k, 1 ≤ l ≤ 2n – k. Дешифратор Σ порядка n от базовых переменных x содержит дешифраторы Σ′ и Σ′′ в качестве подсхем и реализует каждую функцию алгебры логики Qn [i], 1 ≤ i ≤ 2n, с помощью одного
функционального элемента &, входы которого присоединены к выходам Σ′ и Σ′′ в соответствии с формулой Qn [i] = Q′ [j]·Q′′ [l]. Из построения Σ следует, что L (Σ) = 2n + L (Σ′) + L (Σ′′) ≤
n
≤ 2n + k·2k + 1 + (n – k)2n – k + 1, и поэтому при k = n2  получим: L(Σ ) ≤ 2 n + O n ⋅ 2 2 . Теорема
доказана.
Следствие. Для любой функции алгебры логики f(x1,…,xn) существует реализация её
схемой из функциональных элементов в базисе {∨,&, } со сложностью, не превосходящей

( )

( )
n

2 ⋅ 2n + O n ⋅ 2 2 .
Доказательство. Если f ≡ 0, то реализуем f = x1 ⋅ x1 . Если f ≠ 0, то
f (x1 ,!, xn ) =

∨

(σ1 ,!,σ n )

( )

x1σ1 " xnσ n , и L ≤ L(Qn ) + 2 n − 1 ≤ 2 ⋅ 2n + O n ⋅ 2 2 .
n

f (σ~ )=1

Следствие доказано.
28

§26. Мультиплексор. Верхняя оценка сложности мультиплексора.
Метод Шеннона.
Определение 1. Мультиплексором µn порядка n называется схема из функциональных
элементов с n + 2n входами x1 ,! xn , y0 , y1 ,!, y2n −1 и 1 выходом z такая, что если на входы
&%$ &##%##
$
адресные входы информационные входы

x1, …, xn поступает набор (α1, …, αn), то z = y(α1 ,!,α n )2 .
Теорема 5. Существует мультиплексор µn порядка n с числом элементов

( )

L(µ n ) ≤ 3 ⋅ 2 n + O n ⋅ 2 2 .
n

Доказательство. Заметим, что задачу решает функция
z=

∨

(α1 ,!,α n )

x1α1 ⋅ x2α 2 " xnα n ⋅ y(α1!α n )2 .

Для её вычисления достаточно использовать один дешифратор, 2n конъюнкций и 2n – 1
дизъюнкций и

( )

L(µ n ) ≤ L(Qn ) + 2 n + 2 n − 1 ≤ 3 ⋅ 2n + O n 2 2 .
n

Теорема доказана.
x1 … xn

y0

y1

… y 2 n −1

Qn
&

&

"

&

2n

∨
∨

2n – 1
'

∨

Определение 2. Сложностью L (S) схемы S называется число элементов в ней.
Определение 3. Сложностью функции алгебры логики f (x1, …, xn) называется
L( f ) = min L(S ) .
S реализует f

Определение 4. Функцией Шеннона L(n) для схемы из функциональных элементов называется L(n ) = max L( f ) .
f от x1 ,!, xn

Обозначения: g (n) ≲h (n) ⇔ g (n) ≤ h (n)·(1 +o(1)); g (n) ≳ h (n) ⇔ g (n) ≥ h (n)·(1 +o(1)).
Определение 5. Универсальным многополюсником Un порядка n называется схема из
n
n
функциональных элементов с n входами и 2 2 выходами, на которых реализуются все 22
функций от x1, …, xn.

29

Теорема 6 [Ложкин С. А.]. Минимальная сложность универсального многополюсника
n
порядка n равна 2 2 − n .
n
Доказательство. 1) Очевидно, что L(U n ) ≥ 2 2 − n , так как всего функций алгебры логиn

ки от n переменных, отличных от входных переменных, ровно 2 2 − n .
2) Докажем существование универсального многополюсника с числом элементов
2n
2 − n . Для этого построим какую-нибудь схему из функциональных элементов, реализующую все функции алгебры логики. Затем оставим из каждой группы эквивалентных вершин
(в которых реализуются одинаковые функции) лишь одну, наиболее близкую к входам, подсоединив выходы удалённых к выходу оставшейся. В результате получим, что в каждой
вершине реализуется уникальная функция алгебры логики. Но всего функций, отличных от
n
n
входных переменных — 2 2 − n . Следовательно, и вершин — 2 2 − n . Теорема доказана.
1
Теорема 7. L(n ) ≲ 6 ⋅ 2 n ⋅ .
n
Доказательство. Рассмотрим произвольную функцию f (x1, …, xn). Выберем некоторое
натуральное k (1 ≤ k ≤ n) и рассмотрим разложение взятой функции по первым k переменным:
f (x1 ,!, xn ) =

∨

(σ1 ,!,σ k )

x1σ1 ⋅ x2σ 2 " xkσ k ⋅ f (σ 1 ,!, σ k , xk +1 ,!, xn ) .

Построим схему из функциональных элементов из универсального многополюсника Un–k порядка n – k от базовых переменных xk + 1, …, xn и мультиплексора µn порядка n с адресными
переменными x1, …, xk, на информационные входы которого подаются выходы Un – k. Мульk
типлексор можно построить так, что его сложность не превзойдёт 3 ⋅ 2k + O k ⋅ 2 2 , а универ-

( )

n− k

сальный многополюсник так, что его сложность будет не больше, чем 2 2 . Итак,

( )

L(n ) = L(µ n ) + L(U n−k ) ≤ 3 ⋅ 2 k + O k ⋅ 2 2 + 2 2 . Следовательно, полагая
k

n−k

k = n − log 2 (n − 2 log 2 n ) (при этом k ≤ n – log2(n – 2log2n) + 1, а n – k ≤ log2(n – 2log2n)),
получим, что 2k ≤ 2 n−log 2 (n−2 log 2 n )+1 = 2 n+1 ⋅

n−k
 2n 
1
2n
2n
~ 2 ⋅ , 2 2 ≤ 2n−2 log 2 n = 2 = o  и в
n − 2 log 2 n
n
n
 n

итоге

 n2   2 n 
2n
2n


L(S ) ≲ 3 ⋅ 2 ⋅ + O n 2  + o  ~ 6 ⋅ .
n
n

  n 

Теорема доказана.
Определение 6. Пусть γ (L, n) — число всех попарно неизоморфных схем из функциональных элементов с входными переменными x1, …, xn и выходной переменной z1, сложность которых не превосходит L.
Лемма 5. В функциональном базисе {&, ∨, } γ (L, n) ≤ (L + n)2L + 4.
Доказательство. Можно выбрать целые неотрицательные числа L1, L2, L3 так, чтобы их
сумма не превосходила L, не более, чем (L + 1)3 способами. Можно взять L1 конъюнкций, L2
дизъюнкций, L3 отрицаний, а затем каждый вход каждого из них «присоединить» к выходу
некоторого другого функционального элемента или к входу схемы не более, чем (L + n)2L
способами, и пометить в качестве выхода одну из не более, чем L + n точек.
Тогда γ (L, n) ≤ (L + 1)3·(L + n)2L·(L + n) ≤ (L + n)2L + 4. Лемма доказана.

30

1 2n
⋅ .
2 n
n
Доказательство. Очевидно, γ (L(n ), n ) ≥ 2 2 , но в то же время согласно лемме γ (L, n) ≤

Теорема 8. Для функции Шеннона L (n) справедливо L(n ) ≳
≤ (L + n)2L+4. Следовательно,

(L(n ) + n )2 L (n )+4 ≥ 2 2

n

⇒ (2 L(n ) + 4 )log 2 (L(n ) + n ) ≥ 2 n . Так как

L(n )≲ 6 ⋅ 2 n ⋅ 1n ,то начиная с некоторого номера n, n + L (n) ≤ 2n и 2 L(n ) + 4 ≥
L(n )≳

2n
, откуда
n

1 2n
⋅ . Теорема доказана.
2 n

§27. Шифратор. Верхняя оценка сложности шифратора.
Определение. Шифратором Dn порядка n называется схема из функциональных элементов с 2n входами x0 , x1 , !, x2n −1 и n выходами y1,y2,…,yn такая, что если на вход поступает

набор с одной единицей по переменной xi, то на выходе образуется набор (β1, β2, …, βn)2 = i.
Теорема 9. Существует шифратор Dn порядка n со сложностью, не превосходящей
n·2n – 1.
Доказательство. Задачу решает система функций
yj =

∨
x
(σ1 ,!,σ j −1 ,1,σ j +1 ,!,σ n ) (σ1 ,!,σ j −1 ,1,σ j +1 ,!,σ n )

(например, yn = x1 ∨ x3 ∨ x5 ∨ x7 ∨ ! ∨ x2n −1 ). Всего в каждой дизъюнкции 2n – 1 слагаемых, следовательно, необходимо 2n – 1 – 1 дизъюнкторов, всего таких функций надо реализовать n, то
есть получаем оценку сложности шифратора L (Dn) ≤ (2n – 1 – 1) · n < n · 2n – 1. Теорема
доказана.

31

Глава IV. Основы теории кодирования
§28. Алфавитное кодирование.
Теорема Маркова о взаимной однозначности алфавитного кодирования.
Определение 1. Пусть A = {a1, a2, …, ar} — исходный алфавит, B = {b1, b2, …, bm} —
кодирующий алфавит и
A* = ∅ ∪ A ∪ A2 ∪ A3 ∪ … ∪ An ∪ …, B* = ∅ ∪ B ∪ B2 ∪ B3 ∪ … ∪ Bn ∪ ….
Тогда алфавитным кодированием A* → B* назовём отображение ϕ : A → B* такое, что ai → Bi.
Множество {B1, B2, …, Br} при этом называется множеством кодовых слов (или просто кодом). При этом ϕ : ai1 ai2 ! ais → Bi1 Bi2 ! Bis .
Определение 2. Кодирование A* → B* называется взаимно однозначным (декодируемым,
разделимым), если для любых слов a1 ∈ A∗ и a2 ∈ A∗ a1 ≠ a2 ⇒ ϕ a1 ≠ ϕ a2 .
Определение 3. Код называется равномерным, если длины всех его кодовых слов
одинаковы.
Утверждение 1. Любой равномерный код является взаимно однозначным.
Определение 4. Код называется префиксным, если никакое кодовое слово не является
началом другого.
Утверждение 2. Любое префиксное кодирование является взаимно однозначным.
Определение 5. Код называется постфиксным (суффиксным), если никакое кодовое
слово не является концом другого.
Утверждение 3. Любое постфиксное кодирование является взаимно однозначным.
Определение 6. Слово b ∈ B ∗ называется неприводимым, если b декодируется неоднозначно, однако, при выбрасывании из b любого связного непустого куска получается слово,
которое декодируется не более, чем одним способом.
Теорема 1 [Марков А. А.]. Пусть ϕ: ai → Bi (i = 1, 2, …, r) — некоторое кодирование.
Пусть W — максимальное число кодовых слов, которые «помещаются» подряд внутри кодо-

( ) ( )

r

вого слова. Пусть li — длина слова Bi и L = ∑ li . Тогда если кодирование ϕ не взаимно одноi =1

значно, то существуют два различных слова a' ∈ A*, a'' ∈ A*,
длина(a′) ≤ (W +1)(2L−r +2 )  , длина(a′′) ≤ (W +1)(2L−r + 2 )  и ϕ (a') = ϕ (a'').
Доказательство. Пусть ϕ не является взаимно однозначным. Тогда существует некоторое слово b1 , которое допускает две расшифровки. Если слово b1 не является неприводимым, то выбрасывая из b1 куски несколько раз, получим неприводимое слово b ; иначе, положим b = b1 . Очевидно, это всегда можно сделать. Рассмотрим любые две декодировки
слова b . Разрежем слово b в концевых точках кодовых слов каждого из разбиений. Слова
нового разбиения разделим на два класса: к I классу отнесём слова, являющиеся элементарными кодами, а ко II классу — все остальные слова (то есть слова, являющиеся началами кодовых слов одного разбиения и концами слов второго разбиения).

Лемма. Если b — неприводимое слово, то все слова β1, β2, …, βm II класса различны.
Доказательство. Пусть β' = β''. Тогда, очевидно, слово b не будет неприводимым, поскольку при выкидывании отрезка между β' и β'', вместе с любым из этих слов, получим снова две различные расшифровки этого слова (проверьте). Лемма доказана.
32

Таким образом, все β1, β2, …, βm разные. Тогда число слов второго класса не превосходит числа непустых начал элементарных кодов, то есть не превосходит
(l1 – 1) + (l2 – 1) + … + (lr – 1) = L – r.
Слова из второго класса разбивают слово не более чем на L – r + 1 кусков. Рассмотрим пары
соседних кусков. Тогда согласно одному разбиению в одной половинке уложится не более
одного кодового слова, а в другой — не более W (согласно второму разбиению ситуация симметрична). Всего пар кусков не больше, чем

L −2r +1  ≤ L −2r + 2 ,
а в каждом из них укладывается слов не более чем W + 1. Отсюда число кодовых слов в любом разбиении не превосходит L−2r + 2 (W + 1) , а поскольку число целое, то не превосходит и целой части

(

W +1)(L − r + 2 )
2

. Теорема доказана.

§29. Неравенство Макмиллана.
Теорема 2 (неравенство Макмиллана). Пусть задано кодирование ϕ : ai → Bi
(i = 1, 2, …, r) и пусть в кодирующем алфавите B — q букв и длина (Bi) = li (i = 1, 2, …, r). Тогда если ϕ взаимно однозначно, то
r

1

∑q
i =1

r

Доказательство. Положим x = ∑
i =1

 r 1
x n =  ∑ li
1
 i1 =1 q

 r 1
 ∑ l
 i =1 q i2
 2

li

≤ 1.

1
. Тогда для любого натурального n
q li
  r 1
" ∑ l
  i =1 q in
 n

r
 r r
 = ∑∑ ! ∑ l +l 1+!+l .
 i =1 i =1 i =1 q i1 i2 in
n
 1 2

Обозначая lmax = max li , получим, что эта сумма равна
1≤i ≤ r

n ⋅l max

ck

∑q
k =1

k

.

Лемма. ck ≤ qk (∀k).
Доказательство. За ck обозначено, очевидно, число наборов (i1, …, in) (1 ≤ ij ≤ r), для которых li1 + li2 + ! + lin = k . Но такой сумме соответствует слово Bi1 Bi2 ! Bin и

(

)

длина Bi1 Bi2 ! Bin = li1 + li2 + ! + lin = k .
В силу того, что кодирование взаимно однозначно, различным наборам, соответствуют различные сообщения, а различных сообщений длины k в алфавите из q букв не более qk ⇒ ck ≤ qk (∀k).
Лемма доказана.
nl max
nl max
c
Согласно лемме x n = ∑ kk ≤ ∑1 = nlmax ⇔ x ≤ n nlmax , ∀n . Устремляя n к бесконечности,
k =1 q
k =1
получаем x ≤ 1. Теорема доказана.

§30. Существование префиксного кода с заданными длинами кодовых слов.
Теорема 3. Если |B| = q и натуральные числа l1, l2, …, lr удовлетворяют неравенству
r
1
≤ 1,
∑
li
i =1 q
то существует префиксный код B1, B2, …, Br (в алфавите B) такой, что
длина(Bi) = li (i = 1, 2, …, r).
33

Доказательство. Пусть

r

i =1

то есть

l max

dk

∑q
k =1

k

1

∑q

li

≤ 1 и для любого k существует ровно dk таких i, что li = k,

≤ 1 . Тогда надо построить префиксный код, в котором ровно d1 слов длины 1, d2

слов длины 2, и т. д., dl max слов длины lmax. Имеем ∀m (1 ≤ m ≤ lmax)

m

dk

∑q
k =1

k

≤ 1 , или, что то же

самое,

(

)

d1 d 2
d
d
+ 2 + ! + mm−−11 + mm ≤ 1 ⇔ d m ≤ q m − d1q m−1 + d 2 q m−2 + ! + d m−1q .
q q
q
q
Рассмотрим это неравенство для m = 1: d1 ≤ q. Для слов длины 1 всего предоставляется возможностей в алфавите мощности q — ровно q вариантов. После выбора d1 слов длины 1 рассмотрим неравенство для m = 2: d2 ≤ q2 – d1q. Всего слов длины 2 — q2, однако все они могут
начинаться лишь с тех букв, которые не были выбраны в качестве слов длины 1, следовательно, остаётся ровно q2 – d1q возможностей выбрать слова длины 2, что удовлетворяет условию d2 ≤ q2 – d1q. Пусть уже выбраны d1 слов длины 1, d2 слов длины 2, и т. д., dm – 1 слов
длины m – 1. Тогда для слов длины m разрешено возможностей не меньше, чем
qm – dm – 1q – dm – 2q2 – … – d2qm – 2 – d1qm – 1,
что удовлетворяет условию. Теорема доказана.
Следствие. Если существует взаимно однозначное кодирование со спектром длин слов
l1, l2, …, lr в алфавите B, то в B существует префиксный код с тем же спектром длин слов.

§31. Оптимальные коды, их свойства.
Будем рассматривать кодирование A* → {0, 1}*. Пусть известны некоторые частоты p1,
p2, …, pk появления символов кодируемого алфавита в тексте:
p1 − a1 → B1 − l1
p2 − a2 → B2 − l2
, lj — длина j-го кодового слова, p1 + p2 + … + pk = 1, pj > 0.
(
(
( (
pk − ak → Bk − lk
Определение 1. Ценой (стоимостью, избыточностью) кодирования ϕ называется
k

функция c(ϕ ) = ∑ pili . При кодировании текста длины N его длина становится примерно
i =1

равной
k

k

∑ (Np )l
i =1

i

i

= N ∑ pi li .
i =1

Определение 2. Взаимно однозначное кодирование ϕ называется оптимальным, если на
нём достигается
inf
с(ϕ ).
ϕ −взаимно однозначное

Утверждение 4. Если существует оптимальный код, то существует оптимальный префиксный код с тем же спектром длин слов.
Лемма 1. Если ϕ — оптимальное кодирование и pi > pj, то li ≤ lj.
Доказательство. Допустим, что pi > pj и li > lj. Рассмотрим кодирование ϕ и рассмотрим
 ai → Bi
ai → B j
, ϕ′ : 
.
кодирование ϕ', в котором переставим кодовые слова Bi и Bj: ϕ : 
a j → B j
a j → Bi

34

Тогда c (ϕ) – c (ϕ') = (pili + pjlj) – (pilj + pjli) = (pi – pj)(li – lj) > 0 ⇒ c (ϕ') < c (ϕ) ⇒ ϕ не является
оптимальным — противоречие.
Лемма доказана.
Лемма 2. Если ϕ — оптимальное префиксное кодирование и lmax = max li , длина(Bj) =
1≤i ≤k

= lmax, Bj = Bj'α, где α ∈ {0, 1}, то в коде ϕ существует слово Br такое, что Br = B′jα .
Доказательство. Допустим, что в ϕ нет слова B′jα . Тогда заменим в ϕ Bj'α на Bj'. Получим код ϕ', который является префиксным, но

c(ϕ ) − c(ϕ ′) = p j дл(B′jα )− p j дл(B′j ) = p j ⇒ c(ϕ ′) < c(ϕ ) ,

следовательно, ϕ не является оптимальным — противоречие. Лемма доказана.
Лемма 3. Если ϕ — оптимальное префиксное кодирование и p1 ≥ p2 ≥ … ≥ pk–1 ≥ pk, то
можно так переставить слова в коде ϕ, что получится оптимальное префиксное кодирование
ϕ' такое, что слова Bk′ −1 и Bk′ в нём будут различаться только в последнем разряде.
Доказательство. Пусть p1 ≥ p2 ≥ … ≥ pk–1 ≥ pk. По лемме 2 в коде ϕ есть слова B′0 и B′1
максимальной длины. Поменяем их местами с Bk–1 и Bk. Так как pk–1 ≤ pi и pk ≤ pi для
1 ≤ i ≤ k – 2, то цена кодирования не увеличится и код останется оптимальным (префиксным).
Лемма доказана.
p1 , p2 ,!, pk
p1 , p2 ,!, pk −1 , p′, p′′
Лемма 4. Рассмотрим кодирования ϕ :
и ϕ′ :
,
B1 , B2 ,!, Bk
B1 , B2 ,!, Bk −1 , Bk 0, Bk 1
где p' + p'' = pk. Если один из этих наборов префиксный, то второй также префиксный и
c(ϕ') = c(ϕ) + pk.
Доказательство. Рассмотрим
c(ϕ') – c(ϕ) = p' · дл(Bk0) + p'' · дл(Bk1) – pk · дл(Bk) = p'(lk + 1) + p''(lk + 1) – pklk =
= (p' + p'')lk + (p' + p'') – pklk = pk.
Лемма доказана.

§32. Теорема редукции.
Теорема 4 (теорема редукции). Пусть заданы 2 набора частот и 2 набора слов:

ϕ:

p1 , p2 ,!, pk
p , p ,!, pk −1 , p′, p′′
и ϕ′ : 1 2
.
B1 , B2 ,!, Bk
B1 , B2 ,!, Bk −1 , Bk 0, Bk 1

1) Тогда если ϕ′ — оптимальное префиксное кодирование, то и ϕ — оптимальное префиксное кодирование.
2) Если же ϕ — оптимальное префиксное кодирование и p1 ≥ p2 ≥ … ≥ pk–1 ≥ p′ ≥ p″, то ϕ′
— также оптимальное префиксное кодирование.
Доказательство. 1) Очевидно, из префиксности ϕ′ следует префиксность ϕ. Допустим,
что ϕ не оптимально. Тогда существует префиксный код ϕ1: c(ϕ1) < c(ϕ) для тех же распредеp , p , ! , pk
. Рассмотрим новое кодирование
лений частот. Пусть ϕ1 : 1 2
D1 , D2 ,!, Dk

ϕ1′ :

p1 , p2 ,!, pk −1 , p′, p′′
.
D1 , D2 ,!, Dk −1 , Dk 0, Dk 1

Очевидно, кодирование ϕ1′ также является префиксным и

35

 c(ϕ ′) = c(ϕ ) + pk
⇒ {c(ϕ1 ) < c(ϕ )} ⇒ c(ϕ1′ ) = c(ϕ1 ) + pk < c(ϕ ) + pk = c(ϕ ′).

c(ϕ1′ ) = c(ϕ1 ) + pk
Следовательно, ϕ′ не является оптимальным кодированием, что противоречит условию. Остаётся предположить, что ϕ оптимально.
2) Пусть ϕ — оптимальное префиксное кодирование и p1 ≥ p2 ≥ … ≥ pk–1 ≥ p′ ≥ p′′. Допустим, что ϕ′ не оптимально. Тогда для частот p1, p2, …, pk–1, p′, p′′ существует оптимальное
префиксное кодирование ϕ1′: D1, …, Dk–1, Dk0, Dk1 и c(ϕ1′) < c(ϕ). Тогда для частот
p1, p2, …, pk рассмотрим кодирование ϕ1: D1, …, Dk–1, Dk. Получим
c(ϕ1) = c(ϕ1′) – pk < c(ϕ′) – pk = c(ϕ) ⇒ c(ϕ1) < c(ϕ)
и ϕ не оптимально, что противоречит условию. Теорема доказана.

§33. Коды с исправлением r ошибок. Оценка функции Mr (n).
Будем рассматривать равномерные коды, длины всех слов, равные n, и ошибки типа замещения, то есть вида 0 → 1 и 1 → 0.
Определение 1. Код называется исправляющим r ошибок, если при наличии в любом
кодовом слове не более r ошибок типа замещения можно восстановить исходное кодовое
слово.
Определение 2. Расстоянием Хэмминга (между 2 наборами длины n) называется число
разрядов, в которых эти наборы различаются.
Определение 3. Шаром (сферой) радиуса r с центром в точке α~ = (α1 ,!,α n ) называется множество всех наборов длины n, расстояние от которых до α~ не превосходит r (в точности равно r).
Определение 4. Кодовым расстоянием называется расстояние по Хэммингу
ρ =
ρ (α~ ,α~ ) .
min
min

α i ,α j из кода, α~i ≠α~ j

i

j

Утверждение 1. Код K = {α~1 , α~2 ,!,α~m } исправляет r ошибок тогда и только тогда, когда

ρ min (K ) ≥ 2r + 1 .
Доказательство. Заметим, что условие утверждения эквивалентно тому, что расстояние
между центрами шаров радиуса r (кодовыми словами) не меньше, чем 2r + 1, что эквивалентно тому, что эти шары не пересекаются. Таким образом, на выходе получится слово,
принадлежащее единственному однозначно определённому шару (если в слове не более r
ошибок), что позволяет точно восстановить слово, так как известен центр этого шара. Утверждение доказано.
Определение 5. Код обнаруживает r ошибок, если при наличии в нём не более r ошибок типа замещения можно сказать, были ошибки, или их не было.
Утверждение 2. Код K = {α~1 , α~2 ,!,α~m } обнаруживает r ошибок тогда и только тогда,
когда

ρ min (K) ≥ r + 1.
Доказательство. Условие утверждения эквивалентно тому, что ни один из центров шаров (кодовое слово) не содержится в каком-либо другом шаре, то есть если произошло не более r ошибок, можно в точности установить, что полученное на выходе слово не совпадает с
центром одного из шаров. Утверждение доказано.
Определение 6. Функция Mr (n) есть максимальное число слов длины n, образующих код,
исправляющий r ошибок. Sr (n) — число точек (наборов длины n) в шаре радиуса r.

36

n n
n
Утверждение 3. S r (n ) = 1 +   +   + ! +   .
1  2
r
Доказательство. Точки шара радиуса r — это его центр, множество наборов, отличаюn
щихся от центра в одной координате —   , множество наборов, отличающихся от центра в
1
n
2 координатах —   , и т. д. Получаем утверждение.
 2
2n
.
S 2 r (n )
S r (n )
Доказательство. Рассмотрим произвольный код K = {α~1 , α~2 ,!,α~m }, исправляющий r
ошибок. Из утверждения 1 следует, что шары радиуса r не могут пересекаться, следовательно, число всех точек всех шаров не превосходит числа точек n-мерного куба и
Теорема 5.

2n

≤ M r (n ) ≤

2n
2n
⇒ M r (n ) ≤
.
S r (n )
S r (n )

m ⋅ S r (n ) ≤ 2 n ⇔ m ≤

Теперь будем строить код K = {α~1 ,α~2 ,!}. Выберем произвольно точку α~1 . Для выбора
точки α~2 запрещено S2r(n) точек, так как запрещены все точки одного шара и все точки, расположенные от любой граничной точки на расстояние, не больше, чем r, то есть все точки
шара радиуса 2r с центром в точке α~1 . Пусть уже выбраны наборы α~1 ,!,α~k . Для выбора набора α~k +1 запрещено точек не больше, чем k·S2r (n), то есть, если k·S2r (n) < 2n, то можно выбрать α~k +1 . Тупик наступит при выборе m-го набора, когда
2n

m ⋅ S 2 r (n ) ≥ 2 n ⇔ m ≥

S 2 r (n )

⇒ M r (n ) ≥

2n

S 2 r (n )

.

Теорема доказана.

§34. Коды Хэмминга. Оценка функции M1 (n).
Рассмотрим коды, исправляющие одну ошибку типа замещения в словах длины n. Выберем натуральное k таким, что
 k ≤ log 2 n + 1
2k −1 ≤ n ≤ 2k − 1 ⇔ 
⇔ k = log 2 n + 1 = log 2 (n + 1) .
k ≥ log 2 (n + 1)
Разобьём номера всех разрядов исходного слова на k классов:
Di = {m | m = (mk–1mk–2…m0)2, mi = 1}, 1 ≤ m ≤ n.
так, например, D0 = {1, 3, 5, 7, …}, D1 = {2, 3, 6, 7, …}, D2 = {4, …}.
Определение. Кодом Хэмминга порядка n называется множество наборов
α~ = (α ,α ,!,α ) ∈ E k ,
1

2

n

2

удовлетворяющих системе уравнений (суммы по модулю 2):
 ∑ j∈D α j = 0
0

 ∑ j∈D1 α j = 0
.

(

∑
α =0
 j∈Dk −1 j
37

Теорема 6. Код Хэмминга порядка n содержит 2n – k наборов, где k = log 2 n  + 1 и исправляет одну ошибку.
Доказательство. Рассмотрим систему уравнений из определения кода Хэмминга
α1 ⊕ (α 3 ⊕ !) = 0
 α ⊕ (!) = 0

2
.

(

 α 2k −1 ⊕ (!) = 0
Задаём произвольно αj, кроме α1 ,α 2 ,α 4 ,!,α 2k −1 . Это можно сделать 2n – k способами. Так как

α1 ,α 2 ,α 4 ,!,α 2k −1 в скобках не встречаются, то они однозначно определяются из системы.
Пусть передано кодовое слово α~ = (α1α 2 !α n ) , ошибка произошла в d-ом разряде и
~
пусть d = (γk–1γk–2…γ1γ0)2. Пусть на выходе получено слово β = (β1 β 2 ! β n ) , при этом βi = αi

∑ β ,δ

при i ≠ d, βd = αd ⊕ 1. Обозначим δ 0 =

j

j∈D0

1

=

∑ β ,!, δ
j∈D1

Утверждение. (δk–1δk–2…δ1δ0)2 = d.
Доказательство. Пусть γi = 0 ⇒ d ∉ Di, тогда
Пусть теперь γi = 1 и d ∈ Di. Тогда

∑ β = ∑α
j∈Di

i

j∈Di

∑β
j∈Di

i

j

j

=

k −1

=

∑α
j∈Di

∑β

j∈Dk −1

j

j

.

, следовательно, δi = 0 и δi = γi.

⊕1 = 1 ⇒ δ i = 1 ⇒ δ i = γ i .

Утверждение доказано.
Теорема доказана.
Замечание. Обычно разряды с номерами 1, 2, 4, 8, …, 2k–1 называют проверочными (или
контрольными), остальные — информационными.
2n
2n
Теорема 7.
≤ M 1 (n ) ≤
.
2n
n +1
2n
2n
Доказательство. Имеем
≤ M r (n ) ≤
. Правое неравенство следует из того,
S 2 r (n )
S r (n )
что S1 (n) = n + 1. Заметим предварительно, что аналогично нельзя получить и левое неравенство, так как
n
n(n − 1) n 2
~
S 2 (n ) = 1 + n +   = 1 + n +
.
2
2
 2
Всего различных слов в коде, исправляющем одну ошибку — m = 2n–k. Поскольку
k = log 2 n  + 1 , имеем
k ≤ log 2 n + 1 ⇒ m ≥ 2

n −log 2 n −1

Теорема доказана.

38

2n
2n
=
⇒ M 1 (n ) ≥ m ≥
.
2n
2n

Глава V. Основы теории конечных автоматов
§35. Понятие ограниченно детерминированных (автоматных) функций,
их представление диаграммой Мура. Единичная задержка.
Пусть даны A = {a1, a2, …, ar} — входной алфавит и B = {b1, b2, …, bm} — выходной алфавит. Определим множества A∞ и B∞ как множества всевозможных последовательностей в
алфавитах A и B соответственно.
Определение 1. Отображение ϕ: A∞ → B∞ называется детерминированной функцией
(д.-функцией), если b(t) для любого t = 1, 2, … однозначно определяется по a(1), a(2), …, a(t).
a (1)! a1 (t )! → b1 (1)!b1 (t )!
Обозначать д.-функции будем так: ϕ : 1
, причём,
a2 (1)! a2 (t )! → b2 (1)!b2 (t )!
если a1 (1) = a2 (1), то b1 (1) = b2 (1);
 a1 (1) = a2 (1)
a (2) = a (2)
 1
2
если 
, то b1(t) = b2(t).
(

 a1 (t ) = a2 (t )
Определение 2. Пусть задана д.-функция ϕ: A∞ → B∞. Рассмотрим произвольное слово
a = a1a2 ! ak ∈ A* . Определим функцию ϕ a следующим образом: пусть a(1), a(2), …, a(t)…
— произвольная входная последовательность. Рассмотрим

ϕ (a1a2…aka(1)a(2)…a(t)…) = b1b2…bkb(1)b(2)…b(t)….
Тогда положим ϕ a (a (1)a (2)! a(t )!) = b(1)b(2 )!b(t )! . ϕ a при этом называется остаточной
функцией для ϕ по слову a ∈ A∗ .
Определение 3. Детерминированная функция ϕ : A∞→B∞ называется ограниченно детерминированной, если у неё имеется лишь конечное число различных остаточных функций.
Определение 4. Автоматом (инициальным) называется любая шестёрка
(A, B, Q, G, F, q0), где A, B, Q — конечные алфавиты, G: A × Q → Q, F: A × Q → B, q0 ∈ Q —
начальное состояние.
Входом автомата служит последовательность a(1)a(2)a(3)…, a(t)… ∈ A* (конечная или
бесконечная), выходом автомата служит последовательность z(t), при этом автомат задаётся
системой канонических уравнений
 z (t ) = F (x(t ), q (t − 1)),

q (t ) = G (x(t ), q (t − 1)),

q (0) = q0 .

Определение 5. Отображение ϕ: A∞ → B∞ называется автоматной функцией, если существует автомат, который реализует это отображение.
Утверждение. Функция является автоматной тогда и только тогда, когда она является
ограниченно детерминированной.
Пример. Пусть A = B = Q = {0, 1} и система канонических уравнений выглядит следующим образом:
 z (t ) = q(t − 1),

 q(t ) = x(t ),
 q(0) = 0.


39

Такой автомат, очевидно, осуществляет отображение a(1)a(2)…→0a(1)a(2)… и называется единичной задержкой.
x (t)
a (1) a (2) a (3)
q (t) 0 a (1) a (2) a (3)
z (t)
0
a(1) a(2)
Определение 6. Диаграммой Мура для автомата называется ориентированный граф с
множеством вершин Q, у которого каждой паре (a, q) сопоставляется дуга, идущая из вершины q в вершину, соответствующую G (a, q). Этой дуге приписывается пометка (a, F (a, q)).
Особым образом помечена вершина, соответствующая начальному состоянию. Диаграмма
Мура однозначно задаёт автомат.

§36. Схемы из функциональных элементов и элементов задержки.
Автоматность осуществляемых ими отображений.
Определение. Схемой из функциональных элементов и элемента задержки называется
схема из функциональных элементов в функциональном базисе, к которому добавлен элемент, реализующий функцию единичной задержки. В схеме из функциональных элементов и
элементов задержки допускаются ориентированные циклы, но любой ориентированный цикл
должен проходить хотя бы через одну задержку.
Пусть A = B = {0, 1}, E2n — множество всех булевых векторов длины n.
Теорема 1. Схема из функциональных элементов и задержки осуществляет автоматное
отображение.
Доказательство. 1) Пусть в схеме имеется r элементов задержки. Пусть i-я задержка Ri
приписана вершине vi, в которую идёт дуга из вершины wi. Для всех i = 1, …, r удалим из
СФЭЗ дуги (wi, vi). По определению СФЭЗ в полученном после этого графе не будет ориентированных циклов и он, тем самым будет представлять собой СФЭ. Входами этой СФЭ будут все входы исходной схемы, а также все вершины vi, i = 1, …, r (заметим, что все они различны и отличны от входов исходной схемы). Выходами полученной СФЭ объявим все выходы исходной схемы и вершины wi, i = 1, …, r. Пусть в исходной схеме выходам приписаны
переменные z1, …, zm, входам — переменные x1, …, xn. Вершинам vi припишем переменные
q'1, …, q'r, а вершинам wi — переменные q1, …, qr. В соответствии с определением функционирования СФЭ, для некоторых функций алгебры логики fi, gj справедливо:
 zi = f i (x1 ,!, xn , q1′,!, qr′ ), i = 1,!, m,

q j = g j (x1 ,!, xn , q1′,!, qr′ ), j = 1,!, r.

(1)

Естественно считать, что равенства (1) выполняются в каждый момент времени t = 1, 2, 3,…,
то есть
 zi (t ) = f i (x1 (t ),! , xn (t ), q1′ (t ),!, qr′ (t )), i = 1,! m,

q j (t ) = g j (x1 (t ), !, xn (t ), q1′ (t ),!, q′r (t )), j = 1,! , r.

(2)

Так как, в соответствии с каноническими уравнениями элемента единичной задержки его
выход в момент t совпадает с его входом в момент t – 1, то естественно считать, что в исходной схеме q'i (t) = qi (t – 1) при t = 1, 2, … для всех i = 1, …, r, где qi (0) = 0. Тогда равенства (2)
принимают вид (где i = 1, …, m и j = 1, …, r):
 zi (t ) = f i (x1 (t ),!, xn (t ), q1 (t − 1),!, qr (t − 1)),

q j (t ) = g j (x1 (t ),! , xn (t ), q1 (t − 1),!, qr (t − 1)),

q j (0) = 0.


(3)

Полученные равенства определяют функционирование СФЭЗ и называются её каноническими уравнениями.
40

2) Пусть отображение ψ, осуществляемое схемой Σ, задаётся каноническими уравнениями (3). Введём переменные X = (x1, …, xn), Q = (q1, …, qr), Z = (z1, …, zm), принимающие
значения, соответственно в E2n , E2r , E2m . Положим q0 = (0, …, 0). Тогда (3) можно переписать
в виде
Z (t ) = F (X (t ), Q(t − 1)),

Q(t ) = G (X (t ), Q(t − 1)),

Q(0) = q0 ,

где функции F, G не зависят явно от t. Отсюда видно, что отображение, осуществляемое схемой, совпадает с отображением, задаваемым автоматом E2n , E2m , E2r , G, F , q0 , то есть является
автоматной функцией. Теорема доказана.

(

)

§37. Моделирование автоматной функции схемой из функциональных элементов
и элементов задержки.
Определение. Пусть автоматная функция ϕ отображает последовательности в конечном
алфавите A в последовательности в конечном алфавите B. Пусть СФЭЗ Σ осуществляет преобразование ψ последовательностей с элементами из E2n в последовательности с элементами
из E2m . Будем говорить, что Σ моделирует ϕ, если существуют отображения (кодирования)
K1 : A → E2n и K 2 : B → E2m , сопоставляющие разным элементам разные элементы и обладающие свойством: для любой последовательности P = a(1)a(2)…a(t) в алфавите A, если

ϕ (P) = T = b(1)b(2)…b(t), то ψ (K1 (P)) = K2 (T), где K1 (P) = K1 (a(1))K1 (a(2))…K1 (a(t)),
K2 (T) = K2 (b(1))K2 (b(2))…K2 (b(t)).
Теорема 2. Для любой автоматной функции существует моделирующая её СФЭЗ в базисе из функциональных элементов дизъюнкции, конъюнкции, отрицания и элемента
задержки.
Доказательство. Пусть автоматная функция дана автоматом D = (A, B, Q, G, F, q0). Выберем n, m, r так, что 2n ≥ |A|, 2m ≥ |B|, 2r ≥ |Q|. Рассмотрим произвольные отображения (кодирования) K1 : A → E2n , K 2 : B → E2m , K 3 : Q → E2r , при которых разные элементы отображаются в разные элементы. Дополнительно потребуем, чтобы K3 (q0) = (0, …, 0). Рассмотрим
отображения G′ : E2n × E2r → E2r и F ′ : E2n × E2r → E2m такие, что для любых a ∈ A и q ∈ Q
выполняется
G′(K1 (a ), K 3 (q )) = K 3 (G (a, q )),

 F ′(K1 (a ), K 3 (q )) = K 2 (F (a, q )).

(1)

~
Равенства (1) определяют отображения G' и F' только для пар α~ ∈ E2n , β ∈ E2r таких, что α~
~
является кодом некоторой буквы из A, а β является кодом некоторой буквы из B. Для ос~
тальных пар отображения G' и F' доопределим произвольно. Пусть 0 = (0,!,0) . Рассмотрим
~
автомат H = E2n , E2m , E2r , G′, F ′, 0 с каноническими уравнениями

(

)

Z (t ) = F ′(X (t ), Q(t − 1)),

Q(t ) = G′( X (t ), Q(t − 1)),
~

Q(0 ) = 0 .


(2)

Из (1) вытекает, что если автомат D преобразует последовательность P в алфавите A в
последовательность T в алфавите B, то H преобразует код K1 (P) последовательности P в код
41

K2 (T) последовательности T. Таким образом, достаточно показать, что автоматную функцию,
задаваемую равенствами (2), можно реализовать схемой. Так как значением переменной X
являются наборы длины n из E2n , то её можно рассматривать как набор переменных
(x1, …, xn), принимающих значения из E2. Аналогично для переменных Q и Z. Тогда (2) можно переписать в эквивалентном виде для некоторых функций алгебры логики fi, gj:
 zi (t ) = f i (x1 (t ),!, xn (t ), q1′ (t ),! , q′r (t )), i = 1,!, m,

q j (t ) = g j (x1 (t ),!, xn (t ), q1′ (t ),!, q′r (t )), j = 1,! , r.
Тогда можно построить схему из функциональных элементов в базисе {∨,&, } с n + r входами и m + r выходами, реализующую семейство функций
 zi = f i (x1 ,!, xn , q1′,!, qr′ ), i = 1,!, m,

q j = g j (x1 , !, xn , q1′,!, qr′ ), j = 1,!, r.
Пусть в этой СФЭ входная переменная q′j приписана вершине vj, а выходная переменная qj
— вершине wj. Добавим дугу (wj, vj) и сопоставим вершине vj элемент задержки. Проделав
это для всех пар q j , q′j ( j = 1,!, r ) , получим СФЭЗ, функционирование которой описывается
каноническими уравнениями
 zi (t ) = f i (x1 (t ),!, xn (t ), q1 (t − 1),!, qr (t − 1)), i = 1,!, m,

q j (t ) = g j (x1 (t ),!, xn (t ), q1 (t − 1),! , qr (t − 1)), j = 1,!, r ,

q j (0 ) = 0.

Эта схема является искомой. Теорема доказана.

§38. Теорема Мура. Теорема об отличимости состояний двух автоматов.
Будем рассматривать автоматы, в которых не выделено начальное состояние, то есть автомат задаётся пятёркой (A, B, Q, G, F).
Через A* будем обозначать множество всех конечных слов в алфавите A. Расширим
функции F и G, определив F (a , qi ) и G (a , qi ) для любого состояния qi ∈ Q и любого слова

a = (a(1), a (2),!, a(m )) ∈ A∗ . Пусть автомат (A, B, Q, G, F) находится в состоянии qi ∈ Q и на
вход подаётся слово a = (a(1), a (2),!, a(m )) . Тогда на выходе будет последовательно выдаваться некоторое слово b = (b(1), b(2),!, b(m )) и после подачи всего слова a автомат окажется в некотором состоянии qk. Расширим функции F и G, положив F (a , qi ) = b , G (a , qi ) = qk .
Определение 1. Два состояния qi и qj автомата (A, B, Q, G, F) называются отличимыми,
если существует входное слово a ∈ A∗ такое, что F (a , qi ) ≠ F (a , q j ). При этом слово a назы-

вают экспериментом, отличающим qi и qj, а длину l (a ) — длиной этого эксперимента.
Лемма. Пусть в автомате (A, B, Q, G, F) есть 2 состояния qu и qv, отличимые экспериментом длины p и не отличимые более коротким экспериментом. Тогда для любого k, где
1 ≤ k ≤ p, существуют 2 состояния, отличимые экспериментом длины k и не отличимые более
коротким экспериментом.
Доказательство. Пусть состояния qu, qv отличимы экспериментом a длины p и не отличимы экспериментом меньшей длины. Пусть F (a , qu ) = b , F (a , qv ) = c . Тогда b ≠ c , причём b и c различаются только последней буквой. Разобьём все слова a , b , c на 2 подслова
a = a1a2 , b = b1b2 , c = c1c2 , где l (a2 ) = l (b2 ) = l (c2 ) = k . Пусть G (a1 , qu ) = q′ , G (a1 , qv ) = q′′ . Тогда
F (a2 , q′) = b2 , F (a2 , q′′) = c2 . Так как b2 и c 2 различаются последней буквой, то q' и q'' отли42

чимы экспериментом длины l (a2 ) = k . Допустим, что q' и q'' отличимы экспериментом a3
длины

l (a3 ) < k .

Тогда

F (a3 , q′) = b3 ,

F (a3 , q′′) = c3

и

b3 ≠ c3 .

Но

тогда

F (a1a3 , qu ) = b1b3 , F (a1a3 , qv ) = c1c3 и b1b3 ≠ c1c3 . Следовательно, qu и qv отличимы экспериментом a1a3 длины l (a1a3 ) = l (a1 ) + l (a3 ) < ( p − k ) + k = p . Это противоречит условию. Значит (от
противного), q' и q'' не отличимы экспериментом длины меньшей, чем k. Лемма доказана.
Теорема 3 (Теорема Мура). Если в автомате (A, B, Q, G, F) состояния qi и qj отличимы
и |Q| = r, то существует эксперимент a , отличающий qi и qj, длины l (a ) ≤ r − 1 .
Доказательство. Пусть состояния qi и qj отличимы экспериментом длины p и не отличимы более коротким экспериментом. Рассмотрим в данном автомате следующее отношение
Rm на множестве состояний Q (m = 0, 1, …, p): состояния qi и qj не отличимы экспериментом
длины m (считаем, что любые 2 состояния не отличимы экспериментом длины 0). Если для
любого слова a ∈ A∗ длины m F (a , qi ) = F (a , q j ) и F (a , q j ) = F (a , qk ) , то F (a , qi ) = F (a , qk ) ,
поэтому Rm — это отношение эквивалентности для каждого m = 0, 1, …, p. Относительно Rm
Q разбивается на классы эквивалентности Q1(m ), Q2(m ) ,!, Qs((mm)) , так что любые два состояния из
одного класса не отличимы экспериментом длины m, а любые два состояния из разных классов отличимы экспериментом длины m. При этом s(0) = 1 и Q = Q1(0 ) . Посмотрим, как меняются эти классы при переходе от m к m + 1. Если 2 состояния отличимы экспериментом длины m, то они отличимы и экспериментом длины m + 1, поэтому состояния из разных классов
остаются в разных классах. По лемме для любого m = 0, 1, …, p – 1 существуют 2 состояния,
отличимые экспериментом длины m + 1 и не отличимые экспериментом длины m. Следовательно, хотя бы один из классов эквивалентности относительно Rm распадается не менее чем
на 2 класса эквивалентности относительно Rm+1. Отсюда
1 = s (0) < s (1) < s (2) < … < s (p – 1) < s (p) ≤ r.
Так как все s (i) — натуральные числа, то p ≤ r – 1. Теорема доказана.
Следующий пример автомата показывает, что оценку r – 1 в теореме Мура в общем случае улучшить нельзя. Здесь, независимо от входного символа a F(a, qi) = 0, для i = 2, 3, …, r и
F(a, q1) = 1.
0,1

0

0

q1

q2

q3

1

0

0

1

1

…

0

…
1

1

0
qr–1

qr

0

0

0

1

Для того, чтобы отличить состояния qr–1 и qr надо перевести хотя бы одно из них в q1
(входным словом длины r – 2) и затем подать ещё один входной символ. Следовательно, минимальная длина эксперимента, отличающего qr–1 и qr, равна r – 1.
Определение 2. Пусть 2 автомата (A, B, Q1, G1, F1) и (A, B, Q2, G2, F2) имеют одинаковые входной и выходной алфавиты. Пусть qi ∈ Q1 и qj ∈ Q2. Будем говорить, что эксперимент
a ∈ A∗ отличает состояния qi и qj, если F1 (a , qi ) ≠ F2 (a , q j ).
Теорема 4. Пусть даны 2 автомата (A, B, Q1, G1, F1) и (A, B, Q2, G2, F2). Пусть |Q1| = r,
|Q2| = m и qi ∈ Q1, qj ∈ Q2. Тогда, если qi и qj отличимы, то существует отличающий их эксперимент a длины l (a ) ≤ r + m − 1 .
Доказательство. Можно считать, что Q1 ∩ Q2 = ∅. Рассмотрим автомат (A, B, Q, G, F), в
котором Q = Q1 ∪ Q2 и диаграмма которого получается объединением диаграмм исходных
автоматов. Тогда |Q| = r + m и по теореме Мура qi, qj отличимы экспериментом a длины
l (a ) ≤ r + m − 1 . Теорема доказана.

43

Следующий пример автомата показывает, что оценка r + m – 1 в общем случае не улучшаема. Здесь предполагается m ≥ r и опять выходной символ зависит только от текущего состояния и не зависит от входного символа.
q1′

0,1

1

q2′

0

…

0

0
1

qr–1′

0

0
1…1

qr′

qr+1′

0

0
1

0

0

…

0

qm–1′
0

0

qm′
0

0

1
1
1

Легко видеть, что если не использовать состояние qm′ второго автомата, то нельзя отличить состояния q1 и q1′ . Поэтому для того, чтобы отличить q1 и q1′ сначала надо перевести
второй автомат словом a из q1′ в q′m . При этом l (a1 ) ≥ m − 1 и первый автомат под действием
a перейдёт из q1 в qr. Чтобы далее получить различные выходные последовательности, надо
перевести первый автомат из qr в q1 и подать ещё один символ. Всего для того, чтобы отличить q1 от q1′ потребуется входное слово длины (m – 1) + (r – 1) + 1 = m + r – 1.

44

