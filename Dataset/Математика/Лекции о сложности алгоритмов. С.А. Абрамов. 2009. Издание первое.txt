С. А. Абрамов

Лекции о сложности
алгоритмов
Допущено учебно-методическим советом по прикладной математике
и информатике УМО по классическому университетскому
образованию в качестве учебного пособия для студентов высших
учебных заведений, обучающихся по специальности и направлению
«Прикладная математика и информатика» и по направлению
«Информационные технологии»

Москва
Издательство МЦНМО


УДК .
ББК .
A

Научный редактор
Е. А. Бордаченкова

A

Абрамов С. А.
Лекции о сложности алгоритмов. — М.:
. —  с.
ISBN ----

МЦНМО,

В книге излагаются основные (начальные) разделы теории сложности
алгоритмов. Различаются алгебраическая и битовая сложности, каждая из
которых рассматривается в худшем случае и в среднем. Ряд основных понятий теории сложности, как-то: оценки снизу и сверху, нижняя граница
сложности алгоритмов некоторого класса, оптимальный алгоритм и т. д.,
рассматривается не только в обычном функциональном, но и в асимптотическом смысле: асимптотические оценки, асимптотическая нижняя граница, оптимальность по порядку сложности и т. д. Показывается, что при
исследовании существования алгоритма решения задачи, имеющего «не
очень высокую» сложность, важную роль может играть сводимость одной
задачи к другой.
Изложение сопровождается анализом сложности большого числа алгоритмов арифметики, сортировки и поиска, вычислительной геометрии,
теории графов и др.
Для студентов, специализирующихся в области математики и информатики.

ББК .

ISBN ----

© Абрамов С. А., .
© МЦНМО, .

Предисловие

Предлагаемая книга основана на курсе лекций, читаемых автором на
факультете вычислительной математики и кибернетики (ВМК) МГУ
им. М. В. Ломоносова. Ее цель — обсуждение основных понятий теории сложности и некоторых методов анализа сложности алгоритмов. Это обсуждение сопровождается подробным рассмотрением со
сложностной точки зрения ряда алгоритмов арифметики, сортировки
и поиска, вычислительной геометрии, теории графов и др. Материал группируется по главам и параграфам в соответствии с разделами самой теории сложности — сложность в худшем случае, сложность
в среднем, нижние границы сложности и т. д., а не по тематической
принадлежности рассматриваемых алгоритмов — сортировка, теория
графов, арифметика и т. д. Для того, чтобы сосредоточиться именно
на понятиях и подходах теории сложности, при этом не затрачивая
слишком много времени на объяснение деталей трудных для понимания алгоритмов, в примерах исследуются либо алгоритмы достаточно
известные (сложностные характеристики которых менее известны),
либо алгоритмы, суть которых может быть изложена коротко. Сложностные вопросы рассматриваются в книге довольно подробно, но
книга значительно уступает по широте охвата алгоритмического материала книгам Д. Кнута [, , ], А. Ахо, Дж. Хопкрофта и Дж. Ульмана [], Т. Кормена, Ч. Лейзерсона, Р. Ривеста [], С. Баасе и А. ван
Гелдера [], Ж. Брассара и П. Берли [], в той или иной мере отражающих весь спектр вопросов построения алгоритмов, и книгам по
специальным алгоритмическим разделам математики — вычислительной геометрии (Ф. Препарата, М. Шеймос []), алгоритмической теории чисел (Э. Бах, Дж. Шаллит []), комбинаторики (Э. Рейнгольд,
Ю. Нивергельт, H. Део []) и др. Здесь надо сказать, что названная
литература, как и некоторые другие издания, послужила источником
ряда примеров и задач, предлагаемых в этой книге.
В последних трех параграфах, касающихся классов P и NP, понятия NP-полноты и т. д., ряд фактов дается без доказательства. Это
объясняется тем, что в книге используются менее формальные модели вычислений, чем, скажем, машина Тьюринга, а доказательства
упомянутых фактов опираются на полностью формализованные мо-



Предисловие

дели. Недостающие доказательства могут быть найдены, например,
в [], [], [], [].
В приложениях даются дополнительные сведения по затрагиваемым в основном тексте вопросам. Исключение составляют приложения A, G: в первом из них содержатся необходимые сведения о ряде
алгоритмов сортировки и поиска, во втором — о методе решения линейных рекуррентных уравнений с постоянными коэффициентами;
эти два приложения носят характер напоминания.
Библиографические комментарии даются в сносках.
Каждая из глав снабжена задачами для самостоятельного решения, среди которых помимо легких имеются и такие, которые углубляют материал главы, поэтому полезно по крайней мере прочитывать
условия всех задач. Задача содержит указание к решению в тех, например, случаях (довольно редких), когда в основном тексте имеется
отсылка к этой задаче. По всем главам для задач используется сквозная нумерация. Многие из предлагаемых задач имеют вид утверждений, подразумевается, что каждое такое утверждение надо доказать.
Автор благодарен своим коллегам по ВМК МГУ В. Б. Алексееву и
В. П. Иванникову, а также Е. В. Зиме (университет Вилфрид Лауэр, Ватерлоо, Канада) и М. Петковшеку (университет Любляны, Словения),
беседы и дискуссии с которыми существенно помогли в отборе материала и выработке общей схемы курса лекций и этой книги, при
этом надо особо отметить, что Е. В. Зима принял участие в написании
главы  и приложения D. Большая благодарность и А. В. Бернштейну (ИСА РАН), А. А. Васину (ВМК МГУ), В. А. Серебрякову (ВЦ РАН),
сделавшим полезные замечания по ряду разделов книги. Автор признателен рецензентам М. H. Вялому (ВЦ РАН) и С. Б. Гашкову (мехмат
МГУ) — их пометки на полях рукописи оказали значительную помощь
на заключительном этапе работы над книгой. Особая благодарность
за советы и многочисленные конструктивные замечания Е. А. Бордаченковой (ВМК МГУ) — научному редактору книги.

Введение

Исследование сложности алгоритма помогает понять степень его
практической приемлемости. Сравнительный анализ сложности нескольких алгоритмов решения одной и той же задачи позволяет делать
обоснованный выбор лучшего из них. Например, если для решения
задачи предлагается новый алгоритм, то необходимы доводы, говорящие о его преимуществах в сравнении с известными ранее алгоритмами, и анализ сложности может предоставить такие доводы.
Слово «сложность» в этом контексте является математическим
термином, а не общим обозначением препятствия к выполнению замысла. С понятием сложности связываются затраты времени или памяти, соответствующие худшему случаю, либо затраты в среднем;
при этом, чтобы обсуждать худший или «средний» случай, нужно,
прежде всего, договориться, как определяется размер входа (размер
входных данных) алгоритма и в чем измеряются затраты при работе
алгоритма над фиксированным входом.
Часто размер входа определяют как общее число символов в представлении входа, но возможны и другие пути. В задачах сортировки
и поиска размер входа — это, как правило, количество элементов n
входного массива, в задачах на графах — число вершин | V | или число ребер | E | входного графа G = (V , E), но, с другой стороны, | V |
и | E | могут рассматриваться и совместно как два параметра размера входа. В арифметических задачах размером входа может быть,
например, максимум абсолютных величин входных целых чисел, или
количество цифр в двоичной записи этого максимума, или же, как
уже говорилось, суммарное количество двоичных цифр всех входных
чисел и т. д. — выбор делается в зависимости от характера задачи.
Для алгоритмов сортировки соответствующие затраты времени
достаточно полно характеризуются количеством сравнений и перемещений элементов массива. Для алгоритмов на графах учитываемые затраты могут складываться, например, из операций над матрицей смежности или над массивом списков смежных вершин данного графа и из некоторых дополнительных вычислительных операций.
Для арифметических алгоритмов в качестве меры затрат может быть
взято количество всех выполняемых арифметических операций, или,



Введение

как альтернатива, лишь наиболее дорогих операций (например, мультипликативных — умножений и делений); более тщательный анализ
требует рассмотрения количества битовых операций. Если алгоритм
является рандомизированным (содержит обращения к генератору случайных чисел с известным распределением), то затраты, вообще говоря, не определяются однозначно входом алгоритма, но зависят от
полученных случайных чисел. Можно рассматривать усредненные затраты для каждого конкретного входа; такие затраты уже будут функцией входа.
При фиксированном значении размера входа сами входы алгоритма могут варьироваться, при этом меняются и затраты; алгоритм
может быть охарактеризован наибольшими или средними (в соответствии с распределением вероятностей на входах данного размера) затратами. В обоих случаях сложность алгоритма — это функция
размера входа или, соответственно, нескольких параметров размера
входа. Для этого понятия иногда используется термин вычислительная сложность, чтобы избежать путаницы с описательной сложностью, которая тем или иным способом определяется исходя из самой
записи (текста) алгоритма; одним из видов описательной сложности
является длина записи алгоритма, и именно так понятие сложности
трактуется в некоторых теориях  . Мы будем рассматривать только
вычислительную сложность, называя ее просто сложностью.
Понятие сложности является математическим уточнением довольно расплывчатого термина «трудоемкость», с помощью которого, наряду с не более ясными «быстродействием» и «эффективностью», иногда пытаются характеризовать алгоритмы. Принятие в качестве сложности именно затрат в среднем или затрат, соответствующих худшему (а не, скажем, лучшему) случаю, помогает оценить достаточность
имеющихся вычислительных ресурсов для выполнения алгоритма.
Итак, сложность является функцией числового, чаще всего целого,
аргумента, иногда — нескольких таких аргументов. Теория сложности
изучает эти функции, сопоставленные как отдельным алгоритмам,
так и классам алгоритмов решения некоторой задачи. В последнем
случае возникает семейство функций, для которого могут обсуждаться вопросы о нахождении нижней границы, о существовании минимальной функции этого семейства (если такая функция существует,
то соответствующий ей алгоритм — оптимальный в рассматриваемом
классе) и т. д. Важным является также вопрос о существовании в данном классе алгоритмов, нацеленных на решение конкретной задачи,


См., например, статью «Алгоритма сложность» в [].

Введение



алгоритма такого, сложность которого растет с увеличением размера
входа не слишком быстро, например, остается ограниченной некоторым полиномом, вид которого не оговаривается (такой алгоритм
принято называть полиномиальным).
При исследовании существования алгоритма решения задачи,
имеющего «не очень высокую» сложность, важную роль играет сводимость какой-то задачи к другой — из возможности быстро решить
некоторую задачу может следовать такая же возможность для ряда
других, и наоборот, невозможность быстрого решения какой-то одной задачи может автоматически повлечь такую же невозможность
для ряда других задач.
Сложности многих алгоритмов трудно или вообще нельзя представить в простом «замкнутом» виде; помимо этого, точное значение сложности алгоритма для каждого конкретного значения размера входа часто не представляет особого интереса, актуальным же является исследование роста сложности при возрастании размера входа (особый интерес к исходным данным большого размера оправдан
тем, что на них «захлебываются» тривиальные алгоритмы). Поэтому
в теории сложности широко используется асимптотическое оценивание. Однако сравнение сложностей различных алгоритмов на основе
асимптотических оценок этих сложностей возможно не для всех типов таких оценок.
Этот круг вопросов, наряду с рассмотрением общих достаточно
элементарных подходов и методов, которые могут оказаться полезными при сложностном анализе алгоритмов, составляет содержание
предлагаемого курса теории сложности алгоритмов.

Наиболее часто используемые обозначения

C AT (x), C AS (x) — временны́е и пространственные затраты алгоритма A
для входа (входных данных) x;
k x k — размер входа x;
TA (s), S A (s) — значения временно́й и пространственной сложности алгоритма A для значения s размера входа;
λ(n) — количество цифр в двоичной записи неотрицательного целого n (битовая длина n);
∗
λ (n) — количество единиц в двоичной записи неотрицательного целого n;
⌊a⌋ — наибольшее целое, меньшее или равное вещественному a;
⌈a⌉ — наименьшее целое, большее или равное вещественному a;
N, N+ — множества неотрицательных и положительных целых чисел;
Z — множество (кольцо) целых чисел;
Zk — кольцо вычетов по модулю k;
Q, R, C — множества (поля) рациональных, вещественных и комплексных чисел;
Πn — множество всех перестановок чисел 1, 2, ..., n;
 — конец доказательства.

Глава 

Сложности алгоритмов
как функции числовых аргументов.
Сложность в худшем случае

§ . Затраты алгоритма для данного входа,
алгебраическая сложность
Пусть по входным данным (входу) x алгоритм A вычисляет результат
(выход) y. Такое вычисление связано с затратами времени и памяти. Допустим, что достигнуто соглашение о том, как измеряются эти
затраты, тогда можно рассмотреть функции затрат
C AT (x), C AS (x),
где верхний индекс T указывает на временные затраты  , S — на
пространственные затраты (затраты памяти и пространственные затраты — это синонимы), соответствующие вычислениям, связанным
с применением A к входу x; буквы T и S возникают из английских
слов time — время и space — пространство. Вид этих функций может
быть очень непростым; их трудно исследовать методами математического анализа, потому что аргумент x не является, вообще говоря,
числом и не принадлежит какому-либо метрическому пространству.
Можно ввести некоторую неотрицательную числовую характеристику
k x k возможных входов алгоритма и оценивать функции затрат с помощью функций, зависящих не от x, а от k x k:
C AT (x) ¶ ϕ (k x k),

C AS (x) ¶ ψ(k x k).

(.)

Если ϕ и ψ не слишком быстро растут при возрастании (числового)
аргумента, то эти оценки могут обнадеживать автора или потребителя алгоритма A.

Здесь и далее имеется в виду временны́е (связанные с расходованием времени),
а не вре́менные (непостоянные, краткосрочные) затраты. Аналогично — временна́я
сложность и т. д.

 Глава . Сложности алгоритмов как функции числовых аргументов
Избираемую нами величину k · k принято называть размером входа. В соответствии с нашим замыслом размер входа должен характеризовать «громоздкость» исходных данных; то, что k x k является
числом, позволяет говорить о росте ϕ , ψ и исследовать этот рост.
Выбор размера входа — существенный этап оценивания функций затрат; нужна, во всяком случае, уверенность, что оценки вида (.)
будут нести полезную информацию.
В дальнейшем, однако, предметом нашего изучения будут не функции затрат, а некоторые другие функции, о которых мы скажем после ряда примеров. Предварительно условимся о некоторых обычных
для литературы по сложности алгоритмов обозначениях. Пусть a ∈ R,
т. е. a — вещественное число. Значение ⌊a⌋ есть результат округления a до целого в меньшую сторону: ⌊3,14⌋ = 3, ⌊−3,14⌋ = −4 (эту
величину — целую часть a — записывают и как [a]). Соответственно, ⌈a⌉ есть результат округления a до целого в большую сторону:
⌈3,14⌉ = 4, ⌈−3,14⌉ = −3. Если a — целое, то ⌊a⌋ = ⌈a⌉ = a.
Рассмотрим три простых примера.
Пример .. Исходя из определения произведения матриц, мы получаем алгоритм умножения двух квадратных матриц порядка n, требующий n3 операций умножения. Этот алгоритм далее будет обозначаться буквами MM, от английских слов matrix multiplication — матричное умножение.
Пример .. Один из очевидных алгоритмов распознавания простоты данного n ∈ N+ , который мы будем называть алгоритмом пробных делений,
состоит в выяснении того, имеется ли среди чисел
p
2, 3, ..., ⌊ n⌋ хотя бы одно, делящее n. Количество проверок делимости n на те или иные целые числа (для краткости
можно говоp
рить о «числе делений») колеблется от 1 до ⌊ n⌋ − 1. Этот алгоритм далее будет обозначаться буквами TD, от английских слов trial
divisions — пробные деления.
Пример .. При сортировке простыми вставками число сравнеn(n − 1)

, в зависимости от входного масний  колеблется от n − 1 до
2
сива x1 , x2 , ..., xn . Если интересоваться числом перемещений элемен
Основные алгоритмы сортировки и поиска приводятся в приложении A. Обсуждая
конкретные алгоритмы сортировки, мы для краткости иногда будем опускать само слово «алгоритм», говоря, например, не об алгоритме сортировки простыми вставками,
а просто о сортировке простыми вставками и т. д. Все сортировки, которые мы рассматриваем, являются сортировками с помощью сравнений, т. е. никаких других операций,
кроме сравнений и перемещений (присваиваний или обменов), над элементами массива производиться не может, — исключение составляет пример .. Элементы сор-

§ . Затраты алгоритма для данного входа


n(n − 1)

тов (операций обмена ↔), то оно колеблется от 0 до
. Эта
2
сортировка далее будет обозначаться буквой I, от английского слова
insert — вставка.
В этих примерах уже фактически сказано, что считается размером входа и затратами. В примере . размер входа — целое неотрицательное n — это порядок матриц. В примере . размер входа — само входное число (сам вход) n. В примерах ., . количество исследуемых операций однозначно определяется по n. Столь жесткая
зависимость затрат от размера входа может и не иметь места, как
это следует из примера ., где размер входа — это длина n массива.
В связи с этим примером остановимся пока на операциях сравнения.
n(n − 1)

, требуемое в худшем случае, характеКоличество сравнений
2
ризует рассматриваемый алгоритм среди всех алгоритмов сортировки
как «имеющий квадратичную сложность». Для придания этим словам
точного смысла должно быть, прежде всего, определено само понятие
сложности.
Определение .. Пусть на возможных входах x алгоритма A определена неотрицательная числовая функция k x k (размер входа). Пусть
также определены целочисленные неотрицательные функции C AT (x),
C AS (x) временных и пространственных затрат алгоритма A. Тогда временной и пространственной сложностями A называются функции
числового аргумента
TA (n) = max C AT (x),
k x k=n

S A (n) = max C AS (x)
k x k=n

(.)

(областью изменения n как аргумента функций TA (n) и S A (n) является множество значений размера k · k). Более полно каждая такая
сложность именуется сложностью в худшем случае.
Вместо TA (n), S A (n) мы иногда будем писать просто T(n), S(n), если ясно, о каком алгоритме идет речь.
Два примечания к определению ..
) Значение C AT (x) есть в подавляющем большинстве случаев число
каких-то операций, а C AS (x) — число хранимых величин какого-то типа, поэтому предположение о целочисленности значений этих функций вполне естественно. Без этого предположения в (.) пришлось
тируемых массивов считаются попарно различными. Если не оговорено противное, то
речь всегда идет о сортировке по возрастанию. Размером входа каждой из сортировок
мы без специального упоминания считаем число n элементов массива.

 Глава . Сложности алгоритмов как функции числовых аргументов
бы использовать sup вместо max, что сделало бы многие рассуждения
о сложности более тяжеловесными.
) Видимо, вместо «сложность в худшем случае» правильнее было бы сказать «сложность как затраты в худшем случае», но такова
принятая здесь терминология. Мы пока (до § ) не рассматриваем
сложность в среднем, и поэтому, не опасаясь путаницы, будем называть сложность в худшем случае просто сложностью.
Вернемся к алгоритмам MM, TD, I из примеров ., ., .. Рассмотрим вначале временные сложности TMM (n), TTD (n), TI (n). Получаn(n − 1)

. Для TTD (n) у нас нет столь простой
ем TMM (n) = n3 и TI (n) =
2
формулы. Заметим, например, что для значений n от  до  мы
имеем
n:
TTD (n):































Изменение этой функции при n → ∞ можно охарактеризовать
так:
p
для любых n значение этой функции не превосходит ⌊ n⌋ − 1, и найдутся сколь угодно большие n, для которых ее значение равно
p
⌊ n⌋ − 1.
В примерах . и . не возникает необходимости в хранении
больших объемов величин сверх объема входа (сортировка простыми вставками не требует дополнительного массива). Дополнительная
память, если и нужна, — это несколько дополнительных переменных
(ячеек), используемых алгоритмом.
Поэтому можно считать, что SI (n), STD (n) ограничены константами. В примере . нам требуется дополнительная матрица, в которой
будет формироваться результат; имеем SMM (n) = n2 .
Во всех этих примерах мы, как легко заметить, принимаем во
внимание лишь часть затрат и в соответствии с этим определяем
сложность алгоритма. В примере . учитывались только умножения
как более дорогие (доминирующие по затратности) операции. В примере . мы рассматриваем либо сравнения, либо обмены. И во всех
примерах мы игнорировали затраты по выполнению управляющих
операторов, хотя, скажем, при выполнении простейшего оператора
цикла

for i = 1 to n do ... od
тратится время на изменение параметра цикла, проверку условия
продолжения цикла и т. д.
Обычно в таких ситуациях считается, что мы учитываем основную
часть затрат для худшего случая. Если пытаться точно подсчитывать

§ . Затраты алгоритма для данного входа



все, не упуская ничего, то получение и обоснование оценки сложности заурядного алгоритма может превратиться в очень тяжелую работу. Принимая решение о том, в чем измеряются временные затраты,
мы разделяем важное и неважное. Разумеется, при этом необходима осторожность, без которой к разряду неучитываемых «дешевых»
операций могут быть отнесены такие, на выполнение которых в реальных вычислениях уйдет существенное время из-за их огромного
количества.
Отметим еще, что, вообще говоря, время выполнения операции
зависит от размеров ее операндов, это относится и к арифметическим операциям, и к операции сравнения (например, длинные числа сравнивать труднее, чем короткие и т. д.). Аналогично дело обстоит с пространственными затратами и соответственно с пространственной сложностью; здесь, прежде чем находить сложность, надо
решить, что является «единицей хранения»: скажем, при умножении
двух матриц мы можем получить матрицу с элементами, которые записываются более длинно, чем элементы исходных матриц. Однако
довольно часто считается, что результат операции всегда умещается
в одной ячейке.
Иногда приходится отвлекаться от того, что десятичная или двоичная запись иррационального числа не может быть размещена в ячейке какого-либо устройства. Более того, в теории алгебраической
сложности как разделе алгебры  рассматривают, например, алгоритмы, применимые к элементам произвольного абстрактного кольца
или поля, и вопрос о представлении этих элементов в реальном компьютере или в абстрактной машине не обсуждается вообще.
Определение .. Пусть функция C AT (x) в определении . отражает затраты на выполнение лишь какого-то одного типа операций
в предположении, что все эти операции требуют одинакового времени выполнения, не зависящего от вида и размера операндов, и это
время равно 1. Тогда соответствующая функция TA (n) — это сложность по числу операций рассматриваемого типа. Привлечение в качестве C AS (x) функции, отражающей только количество хранимых дополнительных величин того или иного фиксированного типа, приводит к пространственной сложности S A (n) по числу величин рассматриваемого типа.
Такую сложность называют алгебраической сложностью по числу операций или числу величин рассматриваемого типа, подчерки

См., например, [].

 Глава . Сложности алгоритмов как функции числовых аргументов
вая этим предположение о равнозатратности всех рассматриваемых
операций и равнообъемности всех учитываемых величин. Алгебраическую сложность арифметических алгоритмов по числу умножений
и делений называют мультипликативной сложностью. Из основных
арифметических операций умножение и деление являются наиболее
дорогими, и при рассмотрении арифметических алгоритмов часто
интересуются именно (алгебраической) мультипликативной сложностью.
Несколько позднее мы будем говорить о битовой сложности, которая позволяет принимать в расчет различие в размерах операндов
и рассматривать при нахождении сложности непохожие операции,
сопоставляя их затратность на битовом уровне.
Формулы (.) вновь заставляют вспомнить о важности понятия
размера входа. В силу разных причин не всегда этот размер легко
и естественно может быть введен так, что сложность алгоритма возрастает при увеличении размера входа. Но, по крайней мере, функция k · k должна обеспечивать определенность значений TA (n), S A (n)
для всех достаточно больших n — иначе было бы невозможно говорить о поведении TA (n), S A (n) при n → ∞.
Заведомо неудачный размер входа — это, скажем, число строк n
данной матрицы, если речь идет об алгоритмах вычисления произведения всех элементов и если матрица не обязательно является
квадратной: при выбранном таким образом размере входа мы имеем
тождественное равенство TA (n) = ∞ для сложности по числу умножений любого такого алгоритма A, так как при фиксированном числе
строк число столбцов и число элементов могут быть сколь угодно
большими.
Другие возможные осложнения, вызванные неудачным выбором
размера входа, будут обсуждаться в § .
Достаточно очевидно, что если алгоритм A состоит в последовательном (друг за другом) выполнении алгоритмов U и V , то мы, вообще говоря, не можем утверждать, что TA (n) = TU (n) + TV (n), так как,
например, размер входа алгоритма U может существенно отличаться,
как в большую, так и в меньшую сторону, от размера его выхода.
Пусть A и B — некоторые алгоритмы. Как можно заметить, из выполнения для всех n неравенства TA (n) < TB (n) не следует, что C AT (x) <
< C BT (x) для всех возможных входов x (достаточно вспомнить сортировку слияниями и пузырьковую сортировку; последняя выполняется
быстрее первой, коль скоро массив задан уже в упорядоченном виде).
Аналогично дело обстоит с пространственными сложностью и затратами.

§ . Затраты алгоритма для данного входа



В некоторых случаях алгоритму сопоставляют несколько сложностей. Итоговые временные затраты сортировки массива с помощью сравнений складываются из затрат на сравнение и на перемещение элементов. Без учета типа элементов массива нельзя сказать, какая из операций является более дорогой. Поэтому для алгоритмов сортировки используются две сложности: с одной стороны — по числу сравнений, а с другой — по числу перемещений элементов, т. е. присваиваний (:=) или обменов (↔). Если же рассматривается некоторый арифметический алгоритм, то, исследовав его
мультипликативную сложность, можно дополнительно интересоваться, в качестве уточнения, аддитивной сложностью (числом сложений
и вычитаний в худшем случае) и т. д. В приложении D мы тщательно исследуем мультипликативную и аддитивную сложности алгоритмов вычисления значения полинома при заданном значении аргумента.
Пусть некоторому алгоритму A сопоставлены две, скажем, временные сложности TA′ (n) и TA′′ (n). Например, TA′ (n) и TA′′ (n) могут быть
сложностями по разным операциям. Если операции первого и второго вида предполагаются имеющими одинаковую затратность, то
это еще не дает оснований считать, что сложность TeA (n), которую
мы определим, рассматривая совместно операции обоих видов, будет равна TA′ (n) + TA′′ (n), потому что максимумы этих двух видов затрат могут достигаться на разных входах одного и того же размера.
Можно только утверждать, что
TeA (n) ¶ T ′ (n) + T ′′ (n).
A

A

Пример .. Чтобы проиллюстрировать указанное обстоятельство,
мы вновь обратимся к сортировке простыми вставками, которая может рассматриваться в двух вариантах I1 и I2 : для вставки элемента
xi+1 в уже упорядоченную часть x1 , x2 , ..., xi элементы этой упорядоченной части просматриваются либо в порядке xi , xi−1 , ..., либо в порядке x1 , x2 , ... В первом варианте максимум числа сравнений достигается тогда, когда входной массив имеет обратную к требуемой
упорядоченность: x1 > x2 > ... > xn , и на этом же входе достигается
максимум числа обменов; имеем TeI1 (n) = TI′1 (n) + TI′′1 (n) = n(n − 1), где
TI′1 (n), TI′′1 (n) суть сложности по числу сравнений и обменов.
Во втором варианте максимум числа сравнений достигается, когда
массив уже упорядочен так, как требуется: x1 < x2 < ... < xn , а максимум числа обменов — когда x1 > x2 > ... > xn . Если i > 1, то при вставке
элемента xi+1 в уже упорядоченную часть x1 , x2 , ..., xi потребуется тем
меньше обменов, чем больше потребуется сравнений. Если элемент

 Глава . Сложности алгоритмов как функции числовых аргументов
займет место с номером k, то это потребует i − k + 1 обменов. Число
же сравнений равно k, если k ¶ i, и равно k − 1, если k = i + 1. Суммарное число сравнений и обменов равно i + 1, если k ¶ i, и равно i,
если k = i + 1. Поэтому максимум общего числа сравнений и обменов достигается, например, на входном массиве, имеющем обратную
к требуемой упорядоченность: x1 > x2 > ... > xn . Легко устанавливает(n + 2)(n − 1)
.
ся, что TeI (n) =
2

2

Рассматривая сложности TeI1 (n), TeI2 (n) первого и второго вариантов сортировки простыми вставками по общему числу сравнений
и обменов, мы имеем
TeI1 (n) = n(n − 1),

(n + 2)(n − 1)
TeI2 =
,
2

(.)

и, таким образом, TeI1 (n)/TeI2 (n) → 2 при возрастании n.
Обладающий большей общей сложностью TeI1 первый вариант алгоритма рассматривается в литературе значительно чаще второго, не
в последнюю очередь из-за того, что его запись несколько проще: мы
можем со всеми подробностями записать первый вариант с помощью
псевдокода

for i = 2 to n do
k := i ;
while k > 0 and xk > xk+1 do xk ↔ xk+1; k := k − 1 od
od
(предполагается, что если k ¶ 0, то булево выражение, имеющее вид
конъюнкции
k > 0 and xk > xk+1 ,
принимает значение 0, т. е. «ложь», даже если при этом, например,
значение xk не определено, и, следовательно, не определено значение
второго члена конъюнкции).
Второй вариант будет иметь вид:

for i = 2 to n do
k := 1;
while k < i and xk < xi do k := k + 1 od;
for j = i − 1 downto k do x j ↔ x j +1 od
od
В первом варианте используется на один оператор цикла меньше,
но с точки зрения вычислительной сложности это не является пре-

§ . Затраты алгоритма для данного входа



имуществом, — важным является число лишь учитываемых операций
при выполнении алгоритма. Хотя обычно для каждой сортировки рассматривают сложности по сравнениям и перемещениям раздельно,
но, тем не менее, если эти сложности совпадают с соответствующими
сложностями другой сортировки, то совместное рассмотрение обоих
типов операций может оказаться небезынтересным.
Заметим попутно, что среди сортировок с квадратичной сложностью по числу сравнений чрезвычайно низкой сложностью по числу
перемещений, а именно сложностью, равной n − 1, обладает сортировка выбором.
В некоторых случаях к учитываемым операциям относят операции
весьма разнородные, и время выполнения каждой из них считают
равным 1 — пример ., как и некоторые другие, даст соответствующую иллюстрацию. При нахождении каждой такой «смешанной»
сложности затраты для каждого конкретного входа учитываются разом все вместе.
Этот параграф завершим обсуждением тех предположений о выполнении рассматриваемых алгоритмов, которые неявно уже использовались нами. Мы исходили из того, что вычисления проводятся
некоторой машиной, память которой состоит из ячеек. При этом как
объем каждой ячейки, так и общее число ячеек считается бесконечным, что, разумеется, является чистой абстракцией. Поместив в ячейку результат каких-то вычислений или считав содержимое некоторой
ячейки, машина обращается еще к какой-то ячейке и т. д. Относительно этого процесса предполагается, что сам переход от ячейки к ячейке не связан с какими-либо затратами. Этот принцип лежит в основе
модели вычислений, называемой РАМ («равнодоступная адресная машина» — довольно неуклюжий, но принятый термин; имеется в виду
машина с равнодоступными ячейками памяти)  . Модель РАМ существенно отличается в этом смысле от другой известной модели вычислений — машины Тьюринга (МТ), где время перехода от одной
ячейки ленты к другой зависит от расстояния между ячейками; при
этом одна ячейка ленты МТ содержит один символ фиксированного
конечного алфавита  .


В литературе на английском языке — RAM (random-access machine).
Раньше в литературе по вычислительной математике и программированию слово «машина» употреблялось как обозначение некоторого реального вычислительного
устройства; устойчивым словосочетанием было, например, «электронная вычислительная машина» (ЭВМ). Сейчас в этом значении в основном употребляется слово «компьютер», а слово «машина» часто используется при обсуждении абстрактных вычислительных устройств: машин Тьюринга, равнодоступных адресных машин и т. д.


 Глава . Сложности алгоритмов как функции числовых аргументов
Употребление слова «модель» в этом контексте подчеркивает то
обстоятельство, что реальные вычислительные устройства (компьютеры) работают на тех или иных специфических принципах, но при
исследовании вычислительной сложности алгоритмов этой спецификой можно до известного предела пренебрегать и исходить из упрощающей системы допущений.
Далее мы будем еще неоднократно обращаться к понятию модели
вычислений; всюду до главы  без оговорок подразумевается модель
РАМ.
§ . Асимптотические оценки (формализм)
Для характеристики роста сложности по числу сравнений сортировки простыми вставками первого и второго типа мы можем использовать известный из математического анализа символ O и написать
T(n) = O(n2 ) (здесь и далее n → ∞). Мы можем также выделить главные по росту слагаемые в (.):
TeI1 (n) = n2 + O(n),

1
TeI2 (n) = n2 + O(n),
2

(.)

хотя в этом и нет ощутимого практического смысла в силу простоты
функций TeI1 (n), TeI2 (n). В то же время, как это хорошо известно, асимптотическая формула f (n) = O(g(n)) является удобным средством оценивания нетривиально устроенной функции f (n) с помощью более
простой функции g(n); столь же полезными оказываются и оценки
вида f (n) = o(g(n)). Но когда мы говорим, что сортировка выбором,
пузырьковая сортировка и сортировка простыми вставками имеют
квадратичные сложности, мы имеем в виду не только то, что соответствующие сложности допускают оценку O(n2 ), но что эти сложности
являются величинами порядка n2 ; в математическом анализе это иногда записывается как T(n) ≍ n2 , где T(n) — рассматриваемая функция,
в данном случае — сложность. В последние годы в теории сложности
алгоритмов вместо f (n) ≍ g(n) стали писать f (n) = Θ(g(n)).
Определение .. Функции f (n) и g(n) имеют одинаковый порядок
(пишут f (n) = Θ(g(n))) тогда и только тогда, когда найдутся положительные c1 , c2 , N такие, что неравенства
c1 | g(n) | ¶ | f (n) | ¶ c2 | g(n) |

(.)

выполнены для всех n > N.
Без труда проверяется, что отношение «иметь одинаковый порядок» является отношением эквивалентности на множестве функций,

§ . Асимптотические оценки (формализм)



определенных для всех достаточно больших значений n (в нашем случае эти значения целые). Несимметричность записи f (n) = Θ(g(n))
в сравнении с записью f (n) ≍ g(n) ( f (n) и g(n) как бы не равноправны в первой записи, хотя имеем дело с отношением эквивалентности) объясняется тем, что обычно эту запись используют, когда g(n)
проще, чем f (n).
Итак, для сложности T(n) по числу сравнений для любого из упомянутых алгоритмов сортировки мы имеем T(n) = Θ(n2 ). Это более
сильное утверждение, чем T(n) = O(n2 ), так как T (n) = O(n2 ) является
лишь асимптотической верхней оценкой: в соответствии с известным
из математического анализа определением
f (n) = O(g(n)) ⇐⇒ ∃c,N >0 ∀n>N | f (n) | ¶ c| g(n) |,
например, n = O(n2 ), но неверно, что n = Θ(n2 ). Здесь и далее, пользуясь кванторами ∃, ∀, мы записываем связываемые ими переменные,
равно как и условия, определяющие множества значений этих переменных, в виде индексных выражений при кванторах. Это часто
позволяет обходиться без дополнительных скобок и облегчает чтение
формул.
Иногда бывают полезными нижние асимптотические оценки.
Определение .. Соотношение f (n) = Ω(g(n)) имеет место тогда
и только тогда, когда найдутся положительные c, N такие, что для
всех n > N выполнено | f (n) | ¾ c| g(n) |.
Следующее предложение выводится из определений символов O, Ω
и Θ.
Предложение .. Соотношение f (n) = Θ(g(n)) имеет место тогда
и только тогда, когда одновременно f (n) = O(g(n)) и f (n) = Ω(g(n));
помимо этого, f (n) = Ω(g(n)) тогда и только тогда, когда g(n) =
= O( f (n)).
Если размер входа является целым положительным числом, то возникающие функции являются последовательностями. Для единообразия мы, как правило, будем говорить о функциях, подразумевая, но
не упоминая специально, что каждая такая функция определена лишь
для целых положительных значений аргумента (возможно даже, только для достаточно больших целых положительных значений аргумента). Итак, при n → ∞ оценки вида f (n) = Λ(g(n)), где Λ — один из
символов Ω, O, Θ, предполагают, что функции f (n), g(n) определены для всех достаточно больших n. Соответствующее неравенство из

 Глава . Сложности алгоритмов как функции числовых аргументов
числа
| f (n) | ¾ c1 | g(n) |,

| f (n) | ¶ c2 | g(n) |,

c1 | g(n) | ¶ | f (n) | ¶ c2 | g(n) |

(.)

тоже, в соответствии с определением, должно выполняться лишь
для n, больших некоторого N. Заметим, однако, что если f (n) и g(n)
определены для всех n ∈ N+ и принимают при 1 ¶ n ¶ N ненулевые
значения, то можно считать, что соответствующее неравенство из перечисленных в (.) выполняется для всех n, так как, положив
m = min

1¶n¶ N

| f (n) |
,
| g(n) |

M = max

1¶n¶ N

| f (n) |
,
| g(n) |

мы можем заменить c1 , c2 в (.) на c′1 = min{c1 , m}, c′2 = min{c2 , M}.
Это замечание в некоторых случаях будет для нас полезным.
Вернемся к примеру .. Для сложности алгоритма пробных делений было быpошибкой утверждать,
что его сложность по числу делеp
ний есть Θ( n). Но оценка O( n), разумеется, верна и, более того,
является точной в смысле следующего определения.
Определение .. Если имеет место оценка f (n) = O(g(n)), то она
называется точной, коль скоро существует неограниченно возрастающая последовательность неотрицательных целых чисел {nk } такая,
что для ϕ (k) = f (nk ), ψ(k) = g(nk ) имеет место ϕ (k) = Ω(ψ(k)).
Для упомянутых ϕ (k) и ψ(k) в силу этого определения и семантики символа Θ выполнено ϕ (k) = Θ(ψ(k)).
При рассмотрении алгоритма
пробных делений для доказательp
ства точности оценки O( n) можно взять nk равным k-му простому
числу, k = 1, 2, ...
Понятие точности оценки вида f (n) = O(g(n)) можно определить
также с помощью знакомого из математического анализа символа o;
напомним, что u(n) = o(v(n)) при n → ∞, коль скоро u(n) = α(n)v(n)
и lim α(n) = 0.
n→∞

Предложение .. Пусть f (n) = O(g(n)). Эта оценка является
точной, если и только если неверно, что f (n) = o(g(n)).
Доказательство. Пусть оценка является точной, и {nk } — возрастающая последовательность, о которой говорится в определении .. Тогда существует положительная константа c такая, что
| f (nk ) | ¾ c| g(nk ) |, k = 1, 2, ..., и соотношение f (n) = o(g(n)) места не
имеет. Обратно, если неверно, что f (n) = o(g(n)), то по определению
символа o существуют ǫ > 0 и возрастающая последовательность {nk }
натуральных чисел такие, что | f (nk ) | ¾ ǫ| g(nk ) |, k = 1, 2, ... Если при

§ . Асимптотические оценки (формализм)



этом выполнена оценка f (n) = O(g(n)), то эта оценка точна в соответствии с определением ..
Для рассматриваемой сложности алгоритма пробных делений не
верна,pскажем, оценка O(log n), потому что для этой сложности
оценp
ка O( n) является точной и в то же время log n = o( n).
Нелишним будет заметить, что сложность алгоритма пробных делений допускает оценки O(n), O(n5 ), O(n log n) и т. д., хотя,
разумеетp
ся, эти оценки являются более грубыми в сравнении с O( n). Еще раз
подчеркнем, что оценка f (n) = O(g(n)) есть асимптотическая верхняя
оценка, равно как оценка f (n) = Ω(g(n)) — асимптотическая нижняя  .
Как, например, из l < 5 и m < 100 нельзя вывести, что l < m, так и из
f (n) = O(n2 ), g(n) = O(n3 ) нельзя вывести, что хотя бы для достаточно
больших n выполняется f (n) < g(n). Оценка вида TA (n) = O(g(n)) (или
S A (n) = O(g(n))) подходит для того, чтобы «похвалить» алгоритм A,
т. е. охарактеризовать его сложность как достаточно низкую (речь
идет лишь об оценках вида O(g(n)), а не о более тонких оценках,
включающих символ O и имеющих вид, подобный (.)), но не для
того, чтобы «раскритиковать» его — для таких целей скорее подойдет оценка вида TA (n) = Ω(h(n)). Зная, например, что сложность по
числу обменов для сортировки выбором есть O(n), а для сортировки
простыми вставками — Ω(n2 ), мы обоснованно заключаем, что для
достаточно больших n первая сложность меньше второй.
Оценки вида TA (n) = Θ(g(n)), соединяющие в себе оценки TA (n) =
= O(g(n)) и TA (n) = Ω(g(n)), в соответствующих ситуациях подходят
и для характеризации сложности как сравнительно низкой, и, наоборот, как сравнительно высокой  .
При всем этом, иногда можно услышать сообщения о новых алгоритмах, сопровождаемые рассуждениями в духе следующего (подразумевается, что n — размер входа): «Лучший из известных ранее
алгоритмов решения этой задачи требует O(n3 ) операций, а пред
В книге [] отмечено, что положение с символом O схоже с тем, которое возникнет, если кто-нибудь «вместо слов „меньше чем“ начнет писать = M, например, так:
3 = M(5). На вопрос: „Что значит M(5)?“ — он должен ответить: „Нечто, что меньше, чем 5“. Таким образом, он быстро привыкает читать M как „нечто, что меньше,
чем“, приближаясь к тем самым словам, которые употребляем мы, вводя соотношение
f (s) = O(ϕ (s))».

Θ- и Ω-нотации вошли в литературу по вычислительной сложности алгоритмов
с появлением статьи Д. Кнута [], в которой автор, в частности, пишет о бессмысленности нижних оценок вида O( f (n)) и о невозможности использования оценок такого
рода как оценок сложности при сравнении алгоритмов. В [] отмечается также, что
Ω-нотация использовалась ранее в работах Э. Ч. Титчмарша, известного математика
первой половины XX века.

 Глава . Сложности алгоритмов как функции числовых аргументов
лагаемый нами алгоритм — лишь O(n). Таким образом, достигнуто
улучшение на два порядка по числу операций». Но информация, содержащаяся в первой из этих двух фраз, не дает достаточных оснований для сделанного заключения. Более того, на основе этой информации вообще нельзя сказать, какой из двух алгоритмов — известный
ранее или новый — требует меньше операций при больших n, ведь
речь идет лишь об оценках сверху, и возможно, что первая из них
может быть улучшена.
Если про оценку O(g(n)) известно, что она точная, то это расширяет возможности ее использования. Допустим, что нам известен
алгоритм распознавания простоты числа n, имеющий мультипликативную сложность O(logd n) при некотором d > 0. Тогда мультипликативная сложность этого алгоритма для бесконечного множества значений n (но, может быть, не для всех n) будет меньше, чем мультипликативная сложность алгоритма пробных делений, и для этого
вывода достаточно того, что сложность алгоритма пробных делений
p
допускает точную оценку O( n).
В тех случаях, когда рассматриваются два или более параметров
размера входа, мы можем по-прежнему использовать асимптотические оценки вида Θ(g(n1 , n2 )), где под знаком Θ расположена функция двух переменных n1 , n2 , причем n1 , n2 → ∞; определение Θ легко
модифицируется на случай двух и большего числа переменных:
f (n1 , n2 ) = Θ(g(n1 , n2 )) ⇐⇒
⇐⇒ ∃c1 ,c2 ,N >0 ∀n1 ,n2 >N c1 | g(n1 , n2 ) | ¶ | f (n1 , n2 ) | ¶ c2 | g(n1 , n2 ) |.

(.)

То же самое с Ω, O и o. При этом, если имеет место оценка f (n1 , n2 ) =
= O(g(n1 , n2 )), то мы назовем ее точной, коль скоро неверно, что
f (n1 , n2 ) = o(g(n1 , n2 )).
Утверждение, что f (n) и g(n) асимптотически эквивалентны, записываемое как f (n) ∼ g(n), означает, как известно, что f (n) = g(n) +
+ o(g(n)) = g(n)(1 + o(1)). Утверждение, что f (n) ∼ g(n), является,
очевидно, более сильным, чем утверждение, что f (n) = Θ(g(n)). Заметим кстати, что из формул (.) следует
1
TeI2 (n) ∼ n2
(.)
2

 
1
= n2 (1 + o(1))), но не
(например, TeI1 (n) = n2 + O(n) = n2 1 + O
n
наоборот. Из (.) следует только, что

TeI1 (n) ∼ n2 ,

TeI1 (n) = n2 + o(n2 ),

1
TeI2 (n) = n2 + o(n2 ),
2

§ . Асимптотические оценки (два примера)



при этом из v(n) = o(n2 ) не следует, что v(n) = O(n), что доказывается
примером v(n) = n3/2 .
Слова « f (n) имеет асимптотику g(n)» означают, что f (n) ∼ g(n);
например, TeI1 (n) имеет асимптотику n2 , а TeI2 (n) имеет асимптотику

1 2
n .
2

Сложности многих алгоритмов трудно или невозможно представить элементарного вида функциями от размера входа. Помимо этого, точное значение сложности алгоритма для каждого конкретного значения размера входа часто не представляет особого интереса,
актуальным же является исследование роста сложности при возрастании размера входа. Поэтому асимптотическое оценивание широко
используется в теории сложности.
§ . Асимптотические оценки (два примера)
Если мы изначально имеем эскизное описание алгоритма, не содержащее мелких деталей, но полностью отражающее его идею, то уже
этого эскиза может быть достаточно для получения некоторой информативной асимптотической оценки сложности; проработка деталей
алгоритма будет влиять на скрытые за символами O, Ω, Θ значения
констант.
Пример .. Займемся задачей построения выпуклой оболочки конечного множества M точек координатной плоскости, т. е. выпуклого
многоугольника H, содержащего все множество M (рис. ). Множест-

а)

б)

Рис. . a) Конечное множество M точек плоскости; б) выпуклая оболочка
множества M .

во M задается массивом координат принадлежащих ему точек; требуется построить массив координат вершин многоугольника H при
обходе этого многоугольника, начиная с какой-нибудь его вершины,

 Глава . Сложности алгоритмов как функции числовых аргументов
против часовой стрелки  (считаем, что это направление совпадает
с направлением обхода точек (0, 0), (1, 0), (0, 1), (0, 0)).
Пусть n — число элементов множества M, будем считать это число размером входа. Алгоритм, основанный на переборе всех подмножеств множества M с проверкой для каждого из них, является ли оно множеством вершин искомого многоугольника H, имеет
очень высокую сложность Ω(2n ). Обсудим идею значительно более
экономного алгоритма Р. Л. Грэхема (этот алгоритм мы обозначим
буквой G).
Можно довольно быстро найти среди точек множества M такую,
которая обязательно будет одной из вершин многоугольника H: достаточно выбрать в M точку P с наименьшей ординатой, а если таких
точек несколько, то из этих нескольких взять ту, которая имеет наименьшую абсциссу. Дополнительно найдем точку O, которая принадлежит многоугольнику H, но не совпадает ни с одной из точек множества M: возьмем для этого какие-нибудь две точки из M и найдем
середину соединяющего их отрезка (если впоследствии вдруг окажется, что эта точка принадлежит M, то можно будет удалить ее из M,
так как она заведомо не является вершиной H).
Используя какую-нибудь сортировку с помощью сравнений, все
точки множества M можно упорядочить по возрастанию углов между
отрезком OP и отрезками, соединяющими O с точками множества M,
при этом мы считаем, что величина каждого угла принадлежит полуинтервалу [0, 2π). Если вдруг обнаружится, что два каких-то угла равны, то упорядочим соответствующие точки по удаленности от O, но
для краткости будем говорить просто о сортировке по величине угла.
Соединив точки в этом порядке (будем обозначать их P1 , P2 , ..., Pn , при
этом P1 = P), и соединив дополнительно Pn c P1 , мы получим замкнутую несамопересекающуюся ломаную, но ограниченный этой ломаной многоугольник может не быть выпуклым (см. рис. а). Тогда среди вершин P2 , P3 , ..., Pn найдется хотя бы одна, скажем Pk , вдавленная,
которая принадлежит треугольнику Pk−1 OPk+1 при k < n и треугольнику Pn−1 OP1 при k = n (рис. б). Вдавленную вершину можно исключить из дальнейшего рассмотрения, соединив напрямую Pk−1 с Pk+1 ,
или, соответственно, P1 с Pn−1 . Удалив все вдавленные вершины, мы
получим требуемый многоугольник. Такова общая идея алгоритма.
Задержимся на удалении вдавленных вершин.

«Наглядно можно представлять себе дело так: в точках M вбиты гвозди, на которые натянута резинка, охватывающая их все, — эта резинка и будет выпуклой оболочкой множества гвоздей» []. Но в нашем понимании построение выпуклой оболочки
предполагает еще перечисление вершин в порядке их обхода.

§ . Асимптотические оценки (два примера)



P5
P8

P5
P8

P6
P7

P4

а)

O
P1

P6
P7

P3

P4

б)

O

P2

P3
P2

P1

Рис. . a) Точки, упорядоченные по величине угла ∠ P1 OPi , i = 1, 2, ..., n; б) вершина P4 — первая вдавленная вершина в последовательности P2 , P3 , ..., P8 .

Вдавленные вершины можно обнаружить просмотром точек
P2 , P3 , ..., Pn , P1 : переходя от вершины Pi к вершине Pi+1 , i = 2, 3, ...
..., n − 1, можно сразу проверять, принадлежит ли Pi треугольнику
Pi−1 OPi+1, а при переходе от Pn к P1 проверять, принадлежит ли Pn
треугольнику Pn−1 OP1 . Если да, то Pi или соответственно Pn , удаляется, но после этого надо проверить, не окажется ли теперь вдавленной
предыдущая из неудаленных вершин, — на рис. б видно, что после
удаления P4 вершина P3 становится вдавленной. Возможно, что удаление одной вдавленной вершины повлечет удаление нескольких уже
рассмотренных вершин, но вершина P1 никогда не будет удалена.
При i < n − 1 после Pi+1 мы рассматриваем Pi+2 и вновь пытаемся
освободиться от вдавленных вершин с меньшими номерами и т. д.
Последний шаг — переход от Pn к P1 и завершающая попытка освободиться от вдавленных вершин.
Затраты этапа построения точек P и O ограничены значением c1 n,
где c1 — некоторая константа.
Если используется сортировка, сложность которой по числу сравнений есть r(n), то в алгоритме Грэхема может потребоваться не более c2 r(n) операций для сортировки точек по величине угла, константа c2 отражает затраты на сравнение двух углов и сравнение расстояний от O до двух данных точек.
Покажем, что описанный процесс удаления вдавленных вершин
потребует затрат, не превосходящих по величине c3 n, где c3 — некоторая константа (в частности, учитывающая затраты на проверку принадлежности точки треугольнику). В самом деле, если переход от Pi
к Pi+1 сопровождается проверкой вдавленности некоторого числа vi

 Глава . Сложности алгоритмов как функции числовых аргументов
вершин, то число удаленных при этом вершин равно vi − 1. Но обn
P
(vi − 1) < n, и,
щее число удаленных вершин меньше n. Поэтому
как следствие,

i =2

n
X

vi < 2n.

(.)

i =2

Это означает, что сложность TG (n) алгоритма Грэхема по общему
числу арифметических операций и сравнений не превосходит c′ r(n) +
+ c′′ n, где c′ и c′′ суть некоторые положительные константы. Сложность любой сортировки массивов длины n по числу сравнений не
может быть меньше n/2, так как каждый элемент должен пройти хотя бы одно сравнение и в каждом сравнении участвуют два элемента.
Имеем


n
¶ r(n)(c′ + 2c′′ ),
TG (n) ¶ c′ r(n) + c′′ n = r(n) c′ + c′′
r(n)

откуда TG (n) = O(r(n)). При этом у нас нет пока достаточных оснований для утверждения, что TG (n) = Θ(r(n)), потому что нет, например,
оснований утверждать, что после выбора P и O может действительно потребоваться r(n) сравнений обсуждаемого типа (ведь мы можем
еще выполнять арифметические операции; почему бы не предположить, что, прибегая к ним, можно существенно снизить число сравнений при сортировке), и мы пока можем утверждать только то, что
TG (n) = Ω(n); эту тему мы отложим до § .
После того как точки упорядочены по величине угла, информацию об их координатах можно представить в виде двунаправленного списка, и тогда удаление вдавленных вершин не будет связано
с какими-либо перемещениями координат точек, и, подходя формально, можно было бы затраты на перемещения в процессе удаления
вдавленных вершин считать равными нулю. При менее формальном
подходе эти затраты можно считать ограниченными сверху значением cn, где c — некоторая константа: переход от массива к двунаправленному списку и, равным образом, в силу (.), работа со ссылками
во время удаления вдавленных вершин потребуют затрат, ограниченных величинами такого вида. В свою очередь, сложность любой сортировки по числу перемещений элементов не может быть меньше
чем n/2 (так как не исключено, например, что изначальный порядок элементов является обратным к требуемому). Отсюда сложность
алгоритма Грэхема по числу перемещений не превосходит произведения некоторой константы и сложности используемой сортировки
по числу перемещений. Аналогично, для сложности по общему чис-

§ . Асимптотические оценки (два примера)



лу арифметических операций, сравнений и перемещений мы имеем
оценку O(s(n)), где s(n) — соответствующая сложность используемой
сортировки.
Основываясь на эскизном описании алгоритма Грэхема, мы получили следующее.
Для любой сортировки массивов длины n, имеющей некоторую
сложность s(n) по общему числу сравнений и перемещений элементов, существует алгоритм построения выпуклой оболочки n точек,
заданных массивом своих координат на плоскости, сложность которого по общему числу арифметических операций, сравнений и перемещений есть O(s(n)).
Пространственная сложность алгоритма Грэхема, очевидно, есть
O(n).
Пример .. Пусть G = (V , E) — ориентированный граф без кратных ребер и v ∈ V . Вояжем по G, выходящим из вершины v, будем
называть любой путь, который
• начинается в вершине v,
• не проходит ни по одному из ребер дважды,
• завершается в вершине, из которой не выходит ни одного непройденного ребра
(вояж не обязательно охватывает все ребра G). Примером выходящего из вершины 1 вояжа в изображенном на рис.  графе служит
(1, 2, 2, 3, 1, 4).
4

3

5

1

2

6

7

Рис. . Ориентированный граф.

Построение какого-то одного выходящего из данной вершины v
вояжа может быть выполнено произвольным блужданием по непройденным ребрам графа, завершающимся в вершине, из которой не
выходит непройденных ребер. Систематизация блужданий может со-

 Глава . Сложности алгоритмов как функции числовых аргументов
стоять в том, что, попав в некоторую вершину, мы выбираем для
продолжения пути ребро, ведущее в вершину с наименьшим доступным номером.
Определяемый этим алгоритмом вояж может захватить и все ребра — например, когда граф имеет вид кольца (на рис.  изображен
такой граф, для которого | E | = | V | = 5). Входом алгоритма является
граф G и вершина v. Если мы рассматриваем | E | как размер входа, то для сложно3
сти любого алгоритма построения вояжа
обязательно имеет место нижняя оценка Ω(| E |) — ввиду, например, того, что
4
2
для любого фиксированного | E | существует граф, имеющий вид кольца. Возникает вопрос, можно ли обосновать верхнюю
оценку O(| E |)? Если да, то в итоге это дало бы оценку Θ(| E |).
5
1
Для представления графов, не имеющих кратных ребер, часто используются
Рис. . Граф в виде кольца
матрицы смежности. Матрица смежно(любой вояж охватывает
сти — квадратная матрица порядка | V |,
все ребра).
состоящая из нулей и единиц (фактически, булева матрица), в которой элемент
с индексами i, j равен единице, если и только если из i-й вершины
выходит ребро в j-ю вершину. Такой способ представления действительно удобен во многих задачах. Но когда речь идет о блужданиях по графу, при которых однажды пройденное ребро изымается из
дальнейшего рассмотрения, более удобным оказывается представление графа в виде массива a1 , a2 , ..., a| V | списков смежных вершин.
В списке ai , i = 1, 2, ..., | V |, в порядке возрастания содержатся номера
вершин, в которые входят ребра, выходящие из вершины с номером i.
Для графа, приведенного на рис. , имеем
a1 = (2, 4), a2 = (2, 3), a3 = (1, 4), a4 = (), a5 = (6), a6 = (5), a7 = ();
для графа в виде кольца —
a1 = (2), a2 = (3), ...,

a| V |−1 = (| V |),

a| V | = (1)

(в этом графе | V | = | E |). Представление в виде массива списков смежных вершин возможно и для графов, имеющих кратные ребра; в этом
случае номера вершин в каждом списке располагаются в порядке
неубывания.

§ . Асимптотические оценки (два примера)



Начав вояж из вершины с номером v, мы смотрим, не пуст ли список av : если он пуст, то вояж закончен. Если же список av не пуст, переносим первый его элемент (пусть это будет, например, i) в список
вершин, через которые шаг за шагом проходит вояж; затем рассматриваем список ai , если он пуст, то вояж закончен, иначе повторяем
все то же самое, что проделывали в предыдущей вершине, и т. д.:
l := cons(v, nil); i := v ;
while not null(ai ) do i := car(ai ); l := cons(i, l); ai := cdr(ai ) od
Мы здесь использовали операции над списками, применяемые в языке Лисп: car — первый элемент списка, cdr — список после удаления первого его элемента, cons — вставка элемента в начало списка,
null — предикат проверки пустоты списка, nil — обозначение пустого
списка.
Затраты, связанные с удлинением пути на один шаг и с проверкой,
не завершен ли вояж, ограничены сверху константой (эти затраты
суть четыре операции над списками), длина всего пути не превосходит | E |, и затраты во всех случаях не превосходят произведения
некоторой константы на | E |.
Список l содержит в обратном порядке все вершины, через которые последовательно проходит вояж. Если желателен прямой порядок, то надо перевернуть l:
l ′ := nil ;

while not null(l) do l ′ := cons(car(l), l ′ ); l := cdr(l) od
Построение списка l ′ потребует некоторых дополнительных операций над списками, число этих операций не превзойдет произведения
некоторой константы c на длину списка l, но эта длина не превосходит | E |, следовательно, число операций на этом этапе не превзойдет
c| E |.
Естественно считать пространственные затраты на хранение списка с числовыми элементами пропорциональными длине списка.
В случае, например, графа в виде кольца каждый из списков l и l ′
имеет длину | E | + 1.
Обозначим буквами VL описанный алгоритм построения вояжа,
предполагая, что исходный ориентированный граф задается массивом списков смежных вершин. Из сказанного следует, что для временных затрат алгоритма VL мы имеем
T
CVL
(G, v) ¶ c| E |,

(.)

 Глава . Сложности алгоритмов как функции числовых аргументов
где c — некоторая константа. Это неравенство выполнено для любого
имеющего | E | ребер графа. Поэтому если значение | E | принято за
размер входа (напомним, что сам вход — это граф и выделенная в нем
вершина), то из (.) будет следовать TVL (| E |) ¶ c| E |, откуда
TVL (| E |) = O(| E |).

(.)

Вместе с указанной ранее оценкой Ω(| E |) оценка (.) дает
TVL (| E |) = Θ(| E |).
Нетрудно вывести аналогичную оценку и для пространственной
сложности.
Если массивы списков смежных вершин используются в качестве
представления ориентированных графов, то построение начинающегося с заданной вершины v вояжа в графе G = (V, E) возможно с помощью алгоритма, который при выборе числа | E | ребер в качестве
размера входа имеет сложность Θ(| E |) по числу операций над списками. Эта же оценка имеет место для пространственной сложности,
если считать, что пространственные затраты на хранение списка
с числовыми элементами пропорциональны длине этого списка.
Если бы граф представлялся матрицей смежности, то мы для используемого алгоритма не смогли бы получить оценку сложности
Θ(| E |), так как при блуждании по графу вход в каждую вершину
сопровождается проверкой, есть ли непройденное до сих пор ребро, выходящее из этой вершины. Например, для графа в виде кольца
при | E | = | V | = n мы имеем матрицу смежности порядка n:


0 1 0 ... 0


0 0 1 ... 0


. . . . . . . . . . . . . . . . . . .


0 0 0 ... 1
1 0 0 ... 0
Начиная вояж из первой вершины, мы потратим 2 + 3 + ... + n + 1 =
= Ω(n2 ) сравнений элементов матрицы с единицей при поиске первых
подходящих вершин.
Разумеется, базовые операции над списками и операции сравнения элементов матрицы смежности с единицей различаются по затратности (сравнение с единицей — это очень дешевая операция). Но
какими бы ни были положительные c′ и c′′ , отражающие затраты на
операцию сравнения с  и, соответственно, на операцию над списком, неравенство c′ | E |2 > c′′ | E | будет иметь место для всех достаточно

§ . Длина числа как возможный размер входа



больших | E |. Константы, скрытые в оценках Ω(| E |2 ) и O(| E |), найденных для сложностей алгоритма при использовании двух разных
способов представления графа, различаются между собой. Но тем не
менее мы можем сравнивать рост первой и второй сложностей на основе этих оценок. Этот пример показателен и в том отношении, что
«дешевых» операций может быть слишком много (их число может
слишком быстро расти при увеличении размера входа) и их игнорирование может дать
неправильное представление о реальной временной сложности алгоритма.
Если рассматривать два параметра | V |, | E |
размера входа, то сложностью алгоритма VL
′
будет функция TVL
(| V |, | E |) двух переменных.
Для того чтобы устанавливать для нее асимптотические оценки, эта функция должна быть
определена для всех (или, по крайней мере,
всех достаточно больших) натуральных значеРис. . Граф с одной
ний | V |, | L |. Это значит, что для всех таких
вершиной и произ| V |, | E | должен существовать граф, имеющий
вольным заданным
| V | вершин и | E | ребер. Проблема будет снячислом ребер.
та, если, например, допустить к рассмотрению
и такие ориентированные графы, которые
′
имеют кратные ребра. Оценка TVL
(| V |, | E |) = O(| E |) будет, очевидно,
′
выполняться. Можно обосновать и оценку TVL
(| V |, | E |) = Ω(| E |): достаточно рассмотреть имеющий | E | ребер граф в виде цветка (рис. ),
добавив к нему | V | − 1 изолированных вершин (подобных вершине 7
на рис. ) и взяв в качестве v вершину в центре «цветка». В итоге
′
TVL
(| V |, | E |) = Θ(| E |).
§ . Длина числа как возможный размер входа
Часто, хотя и не всегда, для алгоритмов целочисленной арифметики,
входом которых является целое неотрицательное число n, размером
входа выбирают не само n, а его битовую длину, или, иными словами, количество λ(n) цифр в его двоичной записи:
¨
1,
если n = 0,
λ(n) =
⌊log2 n⌋ + 1, если n > 0.
Выражение ⌊log2 n⌋ + 1 во второй строчке этого определения можно
заменить на ⌈log2 (n + 1)⌉ — см. задачу .

 Глава . Сложности алгоритмов как функции числовых аргументов
Пример .. Вернемся к алгоритму пробных делений (пример .).
Наряду с его уже рассмотренной сложностью TTD (n) введем еще одну
∗
сложность (также по числу делений) TTD
(m), m = λ(n). Легко обнаружить, что эта новая функция ведет себя не так, как функция TTD (n),
для которой характерны резкие скачки. Для начальных значений m
имеем
m:






n: —  —  —  — —   —
n̂:






∗
TTD
(m):






(в строке m указывается битовая длина входа; в строке n указывается диапазон, в котором располагаются значения n, битовая длина m
которых равна числу в предыдущей строке; в строке n̂ указывается
одно из тех чисел этого диапазона, на которых достигается максимум числа делений; в последней строке указано значение сложности
∗
∗
TTD
(m)). В поведении TTD
(m) не видно резких скачков. Переход от
размера knk = n к размеру knk∗ = m = λ(n) влечет более основательное преобразование функции T(n), чем простая замена переменной.
Теперь одним и тем же размером m обладают несколько входов n,
затраты для которых, вообще говоря, различны, и, в соответствии
с определением сложности, мы должны брать максимум этих затрат.
Данным размером m обладают все целые n такие, что
2 m −1 ¶ n < 2 m .

(.)

Согласно постулату Бертрана, при m > 1 в таком диапазоне обязательно встретится простое число.
Постулат Бертрана.  При любом целом N > 1 имеется простое
число, принадлежащее интервалу (N, 2N).
∗
С помощью постулата Бертрана мы можем доказать, что TTD
(m) =
m/2
= Θ(2 ). В самом деле, обозначим через pm наибольшее простое
число битовой длины m. Количество делений, требующееся алгоp
ритму для работы с pm , будет равно ⌊ pm ⌋ − 1. В силу (.) имеем
p
⌊2(m−1)/2 ⌋ − 1 ¶ ⌊ pm ⌋ − 1. Таким образом,


1
1
1
∗
TTD
(m) ¾ ⌊2(m−1)/2 ⌋ − 1 > p 2m/2 − 2 = p − m/2−1 2m/2 ,

2



2

2

Сформулирован Ж. Бертраном в  г. и доказан П. Л. Чебышевым в  г. Обсуждение доказательства выходит за рамки этого курса, доказательство Чебышева
см. в [] (статья «О простых числах»). Доказательства, использующее лишь элементарные средства, можно найти в [] (приложение «Доказательство постулата Бертрана
(теоремы Чебышева)») и в [, § ].

§ . Длина числа как возможный размер входа



и при m ¾ 4 имеем


1 m/2
1
∗
TTD
(m) > p −
2 .
2

2

В то же время, в силу (.) очевидно, что для всех m
∗
TTD
(m) < 2m/2 − 1 < 2m/2 .

Отсюда следует требуемое.
Исследуем общий вопрос о возможности перехода от оценок TA∗ (m)
к оценкам TA (n) и наоборот для какого-либо алгоритма A, считая,
что эти две сложности соответствуют одному и тому же способу
учета затрат, но разным размерам входа — k · k и k · k∗ , принимающим значения в N+ , причем если k x k = n для некоторого входа x, то
k x k∗ = m = λ(n) = ⌊log2 n⌋ + 1. В таком случае, очевидно, выполнено
TA∗ (m) =

max

2m−1 ¶n<2m

TA (n).

(.)

Ясно, что TA (n) несет более полную информацию о рассматриваемом алгоритме A, чем TA∗ (m): значения TA∗ (m), m = 1, 2, ..., образуют
подпоследовательность последовательности TA (n), n = 1, 2, ... Поэтому естественно, что переход от оценок для TA∗ (m) к оценкам для TA (n)
приводит к более грубому результату, чем тот, который может быть
получен при изначальном рассмотрении размера k x k = n. Особенно
это касается нижних оценок (пример . прямо указывает на это).
Лемма .. Пусть f (x) — неубывающая функция вещественной переменной. Тогда если TA∗ (m) ¶ f (m), то TA (n) ¶ f (log2 n + 1).
Доказательство. Пусть m и n фиксированы, 2m−1 ¶ n < 2m , и пусть
значение n̂ таково, что
2m−1 ¶ n̂ < 2m ,
(.)
и при этом
TA (n̂) = TA∗ (m).

(.)

Используем неубывание f (x):
TA (n) ¶ TA (n̂) = TA∗ (m) ¶ f (m) = f (⌊log2 n⌋ + 1) ¶ f (log2 n + 1).
Лемма .. Пусть g(x) — неубывающая функция вещественной переменной. Тогда
(i) если TA (n) ¶ g(n), то TA∗ (m) ¶ g(2m ),
(ii) если TA (n) ¾ g(n), то TA∗ (m) ¾ g(2m−1 ).

 Глава . Сложности алгоритмов как функции числовых аргументов
Доказательство. Пусть m фиксировано, 2m−1 ¶ n < 2m , и пусть значение n̂ таково, что выполнены (.) и (.). Используем неубывание
g(x):
(i) TA∗ (m) = TA (n̂) ¶ g(n̂) ¶ g(2m ),
(ii) TA∗ (m) = TA (n̂) ¾ g(n̂) ¾ g(2m−1 ).
Утверждения следующих двух теорем непосредственно следуют
из доказанных лемм. (При рассмотрении асимптотической оценки,
содержащей некоторую переменную, подразумевается, что значение
этой переменной стремится к бесконечности.)
Теорема .. Пусть f (x) — неубывающая функция вещественной
переменной. Тогда если TA∗ (m) = O( f (m)), то TA (n) = O( f (log2 n + 1));
как следствие, при f (x + 1) = O( f (x)) имеем TA (n) = O( f (log2 n)).
Теорема .. Пусть g(x) — неубывающая функция вещественной
переменной. Тогда
(i) если TA (n) = O(g(n)), то TA∗ (m) = O(g(2m )),
(ii) если
TA (n) = Ω(g(n)), то TA∗ (m) = Ω(g(2m−1 )); как следствие,

при g

x
2

= Ω(g(x)) имеем TA∗ (m) = Ω(g(2m )).

функции, для которых условие f (x + 1) = O( f (x)) или

 Существуют
2
x
= Ω(g(x)) не выполнено — например, f (x) = 2 x , g(x) = 2 x .
g
2

∗
Для рассмотренных в примере . сложностей TTD (n), TTD
(m) сиx /2
туация выглядит следующим образом. Функция f (x) = 2
явля∗
ется возрастающей, и по теореме . из TTD
(m) = O(2m/2 ) следует
p
TTD (n) = O(2(log2 n+1)/2 ) = O( n). Рассматривая возрастающую функp
цию g(x) =p x, мы можем, применив
теорему .(i), вывести из
p
∗
TTD (n) = O( n) оценку TTD
(m) = O( 2m ) = O(2m/2 ).
p
∗
Получить из оценки TTD
(m) = Ω(2m/2 ) оценку TTD (n) = Ω( n) мы
не можем, так как последняя оценка не верна; это не противоречит
доказанным утверждениям.

Пример .. Идея бинарного алгоритма возведения a в целую
неотрицательную степень n, называемого также алгоритмом повторного возведения в квадрат (мы будем обозначать его буквами RS, от
английского названия алгоритма repeated squaring — повторное возведение в квадрат), состоит в том, что если двоичная запись n есть
βk ... β1 β0 , то вычисление an может быть сведено к вычислению послеi
довательности значений qi = a(2 ) , i = 0, 1, ..., k (каждый следующий
элемент последовательности получаем возведением в квадрат преды-

§ . Длина числа как возможный размер входа



дущего), и подсчету произведения u тех qi , для которых βi = 1:
q := a; u := 1;
for i = 0 to k − 1 do
if βi = 1 then u := u · q fi;
q := q 2

od
u := u · q

Например, a11 = a8 · a2 · a ( умножений), так как (11)10 = (1011)2 .
Займемся сложностью по числу умножений этого алгоритма. Используя λ(n) для обозначения битовой длины n и обозначение λ∗ (n)
для числа единиц в двоичной записи n, мы легко получаем следующее.
Если рассматривать n как размер входа бинарного алгоритма вычисления an , n ∈ N+ , то сложность TRS (n) по числу умножений для
этого алгоритма равна λ(n) + λ∗ (n) − 2. Если в качестве размера вхо∗
да рассматривать m = λ(n), то сложность TRS
(m) по числу умножений равна 2m − 2.
∗
Для TRS
(m) и TRS (n) имеем очевидные асимптотические оценки
∗
TRS
(m) = Θ(m),

TRS (n) = Θ(log n).

∗
Заметим, что мы не можем вывести из TRS
(m) = 2m − 2 равенство
∗
TRS (n) = λ(n) + λ (n) − 2, хотя обратный вывод очевиден.
В рассмотренном алгоритме предполагается, что показатель степени n задан как массив двоичных цифр. Если показатель n задан как
число, то его двоичные цифры β0 , β1 , ... могут быть получены одна
за другой нахождением соответствующих частных и остатков от деления на 2. Это не изменит оценок Θ(log n), Θ(m) как для общего
числа операций, так и для числа мультипликативных операций. Но
при этом бинарный алгоритм возведения в степень может быть использован, например, для вычисления An , где A — матрица большого
порядка и т. д. В этом смысле те операции, которые подразумеваются в командах u := u · q и q := q 2 , естественно подсчитывать отдельно
и именно их считать составляющими главные затраты алгоритма.
Задачу вычисления an в некотором множестве с ассоциативным
умножением (т. е. в полугруппе) часто формулируют как задачу об аддитивных цепочках для n, т. е. о наборах целых чисел n1 < n2 < ... < nk ,
в которых

• n1 = 1, nk = n;
• для каждого i, 1 < i ¶ k, найдутся s, t такие, что 1 ¶ t ¶ s < i и nt +
+ n s = ni .

 Глава . Сложности алгоритмов как функции числовых аргументов
Каждая аддитивная цепочка для n задает способ вычисления an . Например, аддитивная цепочка 1, 2, 3, 4, 8, 11 для 11 задает тот способ, который соответствует бинарному алгоритму возведения в степень. Задача быстрого возведения в степень n с помощью умножений — это фактически задача построения короткой аддитивной цепочки для n.
Обозначение l(n) закреплено за длиной самой короткой аддитивной цепочки для n. Бинарный алгоритм возведения в степень использует свою специфическую аддитивную цепочку (назовем ее бинарной). Бинарная цепочка не для всех n имеет длину l(n) (см. задачу ). Но, как мы выясним несколько позже, длина бинарной цепочки и l(n) имеют одинаковый порядок. Помимо этого бинарные
цепочки легко и быстро строятся, чего в общем случае нельзя сказать об аддитивных цепочках длины l(n).
Некоторые предположения относительно функции l(n) до настоящего времени не доказаны, хотя и подтверждены проверкой для многих n. К числу таковых относится, например, гипотеза Шольца—Брауэра: l(2n − 1) ¶ n − 1 + l(n) для всех n > 0. 
Задачи
j k l m
n
n
+
, для любого a ∈ R
. Для любого n ∈ Z выполнено n =
2
2
выполнено ⌈a⌉ = −⌊−a⌋.
. Для любых k, n ∈ N+ , k > 1, выполнено ⌊logk n⌋ + 1 = ⌈logk (n + 1)⌉.
Указание. Пусть m ∈ N+ таково, что km−1 ¶ n < km , тогда km−1 < n + 1 ¶ km .
Прологарифмировать по основанию k обе системы неравенств.

. Предположим, что в нашем распоряжении нет операции обмена
a ↔ b и мы заменяем ее тремя присваиваниями:
c := a;

a := b;

b := c;

чему в этом случае равны сложности первого и второго варианта сортировки простыми вставками по суммарному числу сравнений и присваиваний?
. Пусть полином f (n) = am nm + ... + a1 n + a0 имеет ненулевой
старший коэффициент am . Тогда
а) f (n) = O(nk ) ⇔ k ¾ m,
б) f (n) = Ω(nk ) ⇔ k ¶ m,
в) f (n) = Θ(nk ) ⇔ k = m, при k = m также выполнено f (n) ∼ am nm .


Подробнее об аддитивных цепочках см. в [, разд. ..].

Задачи



. Пусть P(n) — количество простых множителей целого числа
n > 1 с учетом кратности. Имеет место точная оценка P(n) = O(log n).
. (Продолжение предыдущей задачи.) Пусть
P ∗ (m) =

max

2m−1 ¶n<2m

P(n),

m = 2, 3, ... Верно ли, что P ∗ (m) = Θ(m)?
. Указать все вещественные значения δ, при которых справедлива
оценка
а) TTD (n) = O(nδ ),
б) TTD (n) = Ω(nδ ),
в) TTD (n) = Θ(nδ ),
где TTD (n) — сложность алгоритма пробных делений (пример .).
. Железнодорожный сортировочный узел устроен так, как показано на рис. . На правой стороне собрано некоторое число вагонов
МИМО

ИЗ

В

тупик

Рис. . Сортировочный узел.

двух типов (на рис.  — черные и белые), по n штук каждого типа. Тупик может вместить все 2n вагонов. Требуется, пользуясь тремя сортировочными операциями В, ИЗ, МИМО, собрать вагоны на левой стороне так, чтобы типы вагонов чередовались. Указать такой алгоритм
решения этой задачи, сложность которого по числу сортировочных
операций при рассмотрении n в качестве размера входа равнялась бы
3n − 1.
. Хорошо известно, что мультипликативная сложность метода
Гаусса решения системы n линейных уравнений с n неизвестными
допускает оценки
) O(n3 ),

)

1 3
n + O(n2 ),
3

) Θ(n3 ).

 Глава . Сложности алгоритмов как функции числовых аргументов
а) Из какой оценки (указать номер) следуют две остальные?
б) Можно ли из приведенных оценок выбрать такую, которая является следствием любой из остальных?
в) Является ли оценка Ω(n3 ) следствием какой-либо из оценок ,
, ?
. Для сложности TQS (n) быстрой сортировки выполняется оценка
TQS (n) = Θ(n2 ). (Обозначение QS происходит от английского названия
быстрой сортировки — quick sort.)
Указание. Оценка TQS (n) = Ω(n2 ) устанавливается предъявлением примера. Неравенство TQS (n) < n2 можно доказать индукцией по n, используя то,
что при фиксированном n ∈ N+ квадратичная функция (m − 1)2 + (n − m)2
от m принимает на отрезке [1, n] свое максимальное значение в одном из
концов этого отрезка.

. Алгоритм, использующий только аддитивные операции и сравнения целых чисел для проверки того, является ли данное целое положительное n точным квадратом, может быть основан на вычислении последовательности значений 1, 1 + 3, 1 + 3 + 5, ... до появления
в ней первого большего или равного n элемента. Сложность по числу
аддитивных операций и операций сравнения этого алгоритма (назоp
вем его sq1 ) допускает оценку Θ( n). Сохранится ли эта оценка, если
дополнительно использовать операцию нахождения целой части половины числа (считается, что затратность этой операции такая же,
как у аддитивных операций) для того, чтобы предварительно выяснять, на какую максимальную степень двойки — четную или нечетную — делится n (алгоритм sq2 )?
. (Продолжение предыдущей задачи.) Пусть Tsq1 (n), Tsq2 (n) —
сложности, соответственно, первого и второго вариантов рассмотренного алгоритма и
Tsq∗ 1 (m) =

max

2m−1 ¶n<2m

Tsq1 (n),

Tsq∗ 2 (m) =

max

2m−1 ¶n<2m

Tsq2 (n),

m = 2, 3, ...
а) Как связаны значения функций Tsq∗ 1 (m) и Tsq∗ 2 (m)?
б) Имеются ли среди оценок Θ(m), O(log m), Θ(2m/2 ), O(2m ) такие,
которые верны для Tsq∗ 2 (m), и если да, то какие именно?
. Изменим в алгоритме Грэхема (пример .) этап удаления
вдавленных вершин: будем обходить — возможно, многократно —
против часовой стрелки вершины построенной несамопересекающейся ломаной и удалять вдавленные вершины до тех пор, пока при
очередном обходе не окажется безуспешной попытка найти хотя бы

Задачи



одну вдавленную вершину. Сложность этого варианта рассматриваемого этапа алгоритма Грэхема есть Ω(n2 ), где n — начальное число
вершин ломаной (в то время как сложность этого этапа в алгоритме
Грэхема есть O(n)).
. Рассмотрим в главных чертах алгоритм Шеймоса—Хоя  построения пересечения P ∩ Q двух выпуклых многоугольников P и Q
содержащих соответственно l и m вершин. Считаем, что многоугольники задаются массивами P1 , P2 , ..., Pl и Q1 , Q2 , ..., Qm координат своих последовательных вершин.
Упорядочим множество всех абсцисс обоих многоугольников по
возрастанию (для простоты считаем, что абсциссы попарно различны, хотя это и несущественно), в результате получим абсциссы
a1 < a2 < ... < al +m (рис. ). Теперь для каждого i = 1, 2, ..., l + m − 1

a1

a2 a3

...

ai

a i +1

...

a m+l

Рис. . Алгоритм Шеймоса—Хоя (l = 5, m = 4).

строим пересечение трапеций, вырезаемых прямыми x = ai , x = ai+1
в заданных многоугольниках. (В вырожденном случае такая трапеция превращается в треугольник.) Из получившихся пересечений
трапеций можно собрать P ∩ Q, удаляя лишние вершины.
Привлекая дополнительно те или иные структуры данных (массивы, списки, ...) и уточняя по мере надобности какие-то этапы алгоритма, добиться того, чтобы в итоге алгоритм (обозначим его буквами SH) имел следующие сложностные характеристики. Если размер входа — это r = l + m, то TSH (r) = Θ(r); если размер входа — это
′
s = max{l, m}, то TSH
(s) = Θ(s); если размер входа имеет два параметра


См. [, гл. ].

 Глава . Сложности алгоритмов как функции числовых аргументов
′′
l и m, то TSH
(l, m) = Θ(l + m) — мы рассматриваем операции сравнения и перемещения элементов, арифметические операции, как мультипликативные, так и аддитивные, все вместе. Для пространственной
сложности — SSH (r), S′SH (s) или S′′SH (l, m) в зависимости от выбора размера входа — получаем те же оценки Θ(r), Θ(s) или Θ(l + m).

Указание. Если исходные многоугольники представить, например, двунаправленными списками координат последовательных вершин, то список абсцисс (a1 , a2 , ..., al+m ), a1 < a2 < ... < al+m , можно получить с временными затратами, не превосходящими c0 (l + m).
При определении пространственной сложности можно заметить, что общее число вершин искомого пересечения не превосходит 3(l + m) — это следует непосредственно из самого алгоритма Шеймоса—Хоя: при построении
пересечения двух трапеций может возникнуть не более двух дополнительных
вершин.

. Расширить алгоритм построения вояжа в ориентированном
графе G = (V , E) с выделенной начальной вершиной v (пример .)
так, чтобы помимо вояжа алгоритм выдавал также информацию
о том, охватил ли вояж все ребра графа. Размер входа имеет два
параметра m = | V |, n = | E |. Для графов, не содержащих изолированных вершин, т. е. вершин, подобных вершине 7 на рис. , сложность
расширенного алгоритма должна быть O(n).
. Задача распознавания существования и фактического построения эйлерова цикла в данном графе для ориентированного случая выглядит так: выяснить, имеется ли в данном ориентированном графе
цикл, проходящий по всем ребрам графа по одному разу, и если существует, то построить этот цикл. Воспользовавшись рассмотренным
алгоритмом построения вояжа (пример .), дать алгоритм решения
этой задачи. Размер входа имеет два параметра m = | V |, n = | E |. Для
графов, не содержащих изолированных вершин, сложность предлагаемого алгоритма должна быть O(n).
. Путник столкнулся со стеной, простирающейся бесконечно
в обе стороны. Имеется дверь в этой стене, но путник не знает ни
расстояния до двери, ни направления к ней. Предложить позволяющий добраться до двери алгоритм, сложность которого допускает
оценку O(n), где n — число шагов (неизвестное путнику), изначально отделяющее путника от двери.
Указание. Сумма sk = 1 + q + ... + qk , q > 1, есть величина порядка qk ,
т. е. sk = Θ(qk ).

. Будем считать затратностью любого построения на плоскости
с помощью циркуля и линейки количество линий (окружностей или

Задачи



прямых), проводимых в ходе построения. Рассмотрим задачу построения отрезка, длина которого равна 1/n от длины исходного отрезка,
считая n размером входа. Предложить для этой задачи такой алгоритм решения, сложность которого допускает оценку O(log n). 
. При n = 15 возможно вычисление an с меньшим числом умножений, чем требуется бинарному алгоритму возведения в степень.
. Пусть двоичная запись числа n ∈ N есть βk ... β1 β0 . Алгоритм
u := 1;
for i = k downto 0 do
u := u · u ;
if βi = 1 then u := u · a fi
od
вычисляет an . Сравнить сложность этого алгоритма по числу умножений с аналогичной сложностью бинарного алгоритма возведения в степень, рассмотренного в примере ., при использовании n
или соответственно m = λ(n) в качестве размера входа. (Описанный
в этой задаче алгоритм является еще одним вариантом бинарного
алгоритма возведения в степень.)
. Для функции l(n), определенной в конце § , выполнено l(ab) ¶
¶ l(a) + l(b) − 1 для всех a, b ∈ N+ .
. (Продолжение предыдущей задачи.) Можно ли утверждать, что
l(ab) = l(a) + l(b) − 1 для всех a, b ∈ N+ ?



Разбор задач на построение с точки зрения их сложности содержится, например,
в [, § ].

Глава 

Сложность в среднем

§ . Понятие сложности в среднем
До сих пор мы исследовали сложность в худшем случае, теперь обратимся к сложности в среднем. Мы ограничимся ситуацией, когда при
каждом фиксированном значении s размера входа сами соответствующие входы образуют конечное множество X s = {x : k x k = s}. Будем
предполагать, что каждому x ∈ X s приписана некоторая вероятность
Ps (x):
0 ¶ Ps (x) ¶ 1,
и при этом

X

Ps (x) = 1.

x ∈ Xs

Таким образом, при каждом допустимом значении s размера входа
множество X s превращается в вероятностное пространство; по умолчанию считается, что вероятность распределена равномерно:

Ps (x) =

1
,
Ns

где N s — количество элементов множества X s . Функции от s
X
X
C AT (x)Ps (x) и
C AS (x)Ps (x)
x ∈ Xs

(.)

(.)

x ∈ Xs

называются временной и, соответственно, пространственной сложностью в среднем алгоритма A. Более подробно:
Определение .. Пусть при любом допустимом значении s множество X s всех входов размера s является вероятностным пространством, в силу чего временные и пространственные затраты алгоритма A для входов x (т. е. C AT (x) и C AS (x)) размера s являются случайными величинами на X s . Сложностью в среднем называется математическое ожидание (первая или вторая сумма из (.)) соответствующей
случайной величины.

§ . Понятие сложности в среднем



Сложность в среднем может принимать и нецелые значения, даже
если функция затрат целочисленна.
Для временной и пространственной сложности в среднем алгоритма A мы будем использовать обозначения ¯T¯A (·), S̄¯ A (·).
Теорема .. Для любого алгоритма A при любом распределении
вероятностей на множестве X s , где s — некоторое допустимое значение размера k · k, сложность в среднем не превосходит сложности
в худшем случае:
¯T¯A (s) ¶ TA (s), S̄¯ A (s) ¶ S A (s).
Доказательство. Докажем, например, первое неравенство:
X
X
¯T¯A (s) =
C AT (x)Ps (x) ¶
(max C AT (x))Ps (x) =
x ∈ Xs

x ∈ Xs

x ∈ Xs

X

=

TA (s)Ps (x) = TA (s)

x ∈ Xs

X

Ps (x) = TA (s).

x ∈ Xs

Второе неравенство доказывается аналогично.
Ниже в этом параграфе мы рассмотрим временную сложность в
среднем ряда алгоритмов.
Пример .. Как было уже установлено (пример .), бинарный
алгоритм возведения в степень n требует λ(n) + λ∗ (n) − 2 умножений; если в качестве размера взять m = λ(n), то сложность в худшем
случае будет равна 2m − 2. Подсчитаем сложность в среднем, привлекая m как размер входа. Всего имеется 2m−1 неотрицательных целых
битовой длины m; если считать все эти числа равновероятными, то
искомая сложность есть
m
m
2X
−1
2X
−1
1
1
∗
(
λ
(n)
+
λ
(n)
−
2)
=
m
−
2
+
λ∗ (n).
m− 1
m− 1
2

2

n=2m−1

n=2m−1

Первая цифра каждого из чисел битовой длины m равна 1; количество чисел, имеющих кроме старшей
цифры
еще k, 0 ¶ k ¶ m − 1,


m−1
ненулевых двоичных цифр, равно
(т. е. числу сочетаний из
k
m − 1 по k). Поэтому искомую сложность можно переписать в виде

m
−1 
m
−1 


X
X
m−1
1
m−1
1
k
.
m − 2 + m − 1 2 m −1 +
k
= m − 1 + m− 1
2

k =1

k

2

Легко проверяется, что при 1 ¶ k ¶ m − 1 выполнено




m−1
m−2
k
= (m − 1)
,
k

k−1

k =1

k



Глава . Сложность в среднем

и возможно дальнейшее упрощение выражения для сложности:
m−1+

m−1
2 m− 1

m
−1
X
k =1

m−2
k−1


=m−1+

m−1
2 m− 1

m
−2
X
l =0

m−2
l



3
2

= (m − 1).

Если рассматривать m = λ(n) как размер входа бинарного алгоритма вычисления an , n ∈ N+ , то сложность в среднем по числу умно3
жений для этого алгоритма есть (m − 1).
2

Таким образом, при больших m сложность в среднем бинарного
алгоритма возведения в степень приблизительно равна трем четвертым сложности в худшем случае.
Анализ сложности в среднем для широкого ряда арифметических
алгоритмов опирается на асимптотический закон распределения простых чисел, который мы приведем без доказательства.
Асимптотический закон распределения простых чисел. Для
функции π(n), значение которой равно количеству простых чисел,
меньших данного натурального n, справедливо асимптотическое равенство
n
π(n) ∼
.
(.)
ln n

Как следствие, вероятность того, что при выборе «наугад» одного
из целых чисел 1, 2, ..., n попадется простое число, асимптотически
1 
равна
.
ln n

Пример .. Вновь вернемся к алгоритму пробных делений, предназначенному для распознавания простоты данного n ¾ 2 (примеры ., .). Будем рассматривать в качестве размера входа битовую

Предположение о справедливости этого закона распределения простых чисел высказывалось, в частности, Гауссом и Лежандром. Впоследствии в  г. Чебышевым
было доказано, что для некоторых констант c и C

c

n
ln n

< π(n) < C

n
ln n

для всех достаточно больших n, и, более того, им было установлено, что можно положить C = 1,10555, c = 0,92129. Асимптотическое равенство (.) было полностью доказано в  г. независимо Ж. Адамаром и Ш. Валле Пуссеном. «После доказательства
неравенств Чебышева в  г. речь шла, казалось бы, только о более точном нахождении и сближении постоянных c и C. Однако асимптотический закон распределения
простых чисел был доказан лишь полвека спустя, в самом конце XIX века, на основании совершенно новых идей, предложенных Риманом...» []. В [, гл. V] приводится
1

элементарное доказательство неравенств Чебышева для C = 6 и c = . Полное доказательство асимптотического закона имеется, например, в [].

3

§ . Понятие сложности в среднем



длину m данного числа. На первый взгляд сложность в среднем этого
алгоритма могла бы оказаться существенно меньшей, чем сложность
в худшем случае, так как для многих входов затраты совсем невелики.
Например, для четных входов достаточно одного деления и т. д. Для
сложности в худшем случае по числу делений нами была установлена экспоненциальная оценка Θ(2m/2 ). Существует ли d ∈ N такое, что
сложность в среднем алгоритма пробных делений как функция от m
допускает оценку O(md )? Мы видим, что для довольно обширного
множества входов размера m алгоритм пробных делений работает
быстро, и предположение, что для сложности в среднем существует
такое число d, выглядит правдоподобным. На самом деле все обстоит не так, потому что среди всех натуральных чисел доля простых
(для которых алгоритм пробных делений работает долго) достаточно
велика. Оценка количества V (m) простых среди чисел
2 m −1 ¶ n < 2 m
может быть получена из приведенной выше теоремы о распределении
простых чисел: воспользовавшись тем, что
π(2m ) ∼

2m
,
(ln 2)m

m → ∞,

а также равенством V (m) = π(2m ) − π(2m−1 ), получим
V (m) ∼

1
1
m−2
2m ∼
2m .
2 ln 2 m(m − 1)
(2 ln 2)m

(.)

Теперь уже экспоненциальность роста сложности в среднем алгоритма пробных делений выводится легко. Обозначим через D(n)
количество делений, требующееся алгоритму пробных делений применительно к натуральному числу n. Для любого простого p ¾
¾ 2m−1 , m ¾ 7, выполнено D(p) > 2m/2−1 (в самом деле, D(p) =
p
= ⌊ p ⌋ − 1 ¾ ⌊2(m−1)/2 ⌋ − 1 > 2(m−1)/2 − 2, и при m ¾ 7 выполнено
2(m−1)/2 − 2 ¾ 2m/2−1 ). Интересующая нас сложность в среднем рав2m
−1
P
1
D(n). При m ¾ 7 мы имеем
на m−1
2

n=2m−1

1
2

m− 1

m
2X
−1

n=2m−1

D(n) ¾

1
2

m− 1

X
m−1

D(p) ¾ V(m)2−m/2 .

(.)

m

2
¶ p <2
p — простое

Учитывая (.), находим, что последняя величина при m → ∞ асимптотически равна
1
2m/2 .
(2 ln 2)m



Глава . Сложность в среднем

Это говорит о том,
чтоисследуемая сложность по числу делений

1 m/2
и как функция от m эта сложность не мо2
в среднем есть Ω
m

жет быть оценена как O(md ) ни при каком d ∈ N.
Определение .. Вещественная неотрицательная функция f (m),
определенная для целых положительных значений аргумента, называется полиномиально ограниченной, если существует полином P(m)
с вещественными коэффициентами такой, что f (m) ¶ P(m) для всех
m ∈ N+ . (Очевидно, что мы получим эквивалентное определение, если
дополнительно потребуем, чтобы все коэффициенты полинома P(m)
были неотрицательными; другие эквивалентные варианты определения: f (m) = O(md ) для некоторого d ∈ N и f (m) = mO(1) .)
Доказанное нами можно сформулировать так:
Пусть в качестве размера входа алгоритма пробных делений, предназначенного для распознавания простоты натурального числа n,
привлекается m = λ(n). Тогда временные сложности этого алгоритма
как в худшем случае, так и в среднем по числу делений не являются
полиномиально ограниченными функциями от m.
Краткое обсуждение идеи такого алгоритма распознавания простоты числа, который имеет полиномиально ограниченную сложность в худшем случае (тем самым, разумеется, и в среднем), будет проведено в примере .. При этом речь пойдет не об алгебраической сложности по числу делений, мультипликативной сложности и т. д., а о битовой сложности, что приводит к существенно более
сильным утверждениям. До этого в гл.  будет детально рассмотрено
само понятие битовой сложности.
§ . Сортировка и конечные вероятностные пространства.
Применение формулы полного математического ожидания
При рассмотрении сложности в среднем мы, прежде всего, должны
превратить каждое из множеств входов, обладающих фиксированным
размером, в вероятностное пространство. Проще работать с конечными вероятностными пространствами, но как обходиться такими
пространствами, имея дело, например, с алгоритмами сортировки,
входом каждого из которых, при фиксированном размере n, может
быть любой массив x1 , x2 , ..., xn с попарно различными элементами?
Общий принцип заключается в том, что мы разбиваем все имеющие
фиксированный размер n входы на некоторые классы, включая в один

§ . Сортировка и конечные вероятностные пространства



класс входы, неразличимые для данного алгоритма в том смысле, что
алгоритм проделывает одну и ту же последовательность операций для
любого входа, принадлежащего классу (этот принцип может применяться не только при рассмотрении той или иной сортировки). Число
таких классов может оказаться конечным, даже если само множество
входов размера n бесконечно. Если это не противоречит другим предположениям, то такие классы можно рассматривать как элементарные события, приписывая каждому из них некоторую вероятность.
На выполнение любой сортировки с помощью сравнений сами
значения элементов x1 , x2 , ..., xn не оказывают никакого влияния, важен лишь их относительный порядок. Поэтому в один класс естественно объединять все массивы x1 , x2 , ..., xn , имеющие один и тот
же порядок элементов по отношению друг к другу. Такой класс может быть представлен перестановкой чисел 1, 2, ..., n с соответствующим порядком элементов (перестановкой длины n). В дальнейшем
для любого n ∈ N∗ мы будем рассматривать функцию ψn , аргументами которой являются любые попарно различные числа x1 , x2 , ..., xn ,
а значением — перестановка a = (a1 , a2 , ..., an ) чисел 1, 2, ..., n, отражающая относительный порядок чисел x1 , x2 , ..., xn . Например,


3
(.)
ψ3 − , −10, 17 = (2, 1, 3).
4

Множество всех перестановок чисел 1, 2, ..., n будет обозначаться через Πn , так же будет обозначаться и вероятностное пространство,
1
получаемое приписыванием вероятности
каждой из этих перестаn!
новок.
Рассмотрим некоторые события в вероятностном пространстве Πn ;
M
вероятность каждого из них, очевидно, будет равна , где M — чисn!
ло перестановок, составляющих событие. Эту вероятность мы будем
обозначать через Pn (·).
Пример .. Начнем с события Bvn , 1 ¶ v ¶ n, состоящего в том,
что v-й элемент av перестановки (a1 , a2 , ..., an ) равен v. Перестановку (a1 , a2 , ..., an ) ∈ Πn можно рассматривать как отображение множества {1, 2, ..., n} на себя, при котором 1 переходит в a1 ,  переходит
в a2 и т. д., и событие Bvn состоит тогда в том, что v является неподвижной точкой перестановки. Множество, состоящее из перестановок (a1 , a2 , ..., an ) таких, что av = v, содержит (n − 1)! элементов, от(n − 1)!

1

= при всех рассматриваемых v.
сюда Pn (Bvn ) =
n!
n
В зависимости от выбранной перестановки число неподвижных
точек может быть любым целым из диапазона от 0 до n. Рассмотрим



Глава . Сложность в среднем

вопрос о среднем числе неподвижных точек перестановок длины n:
найдем математическое ожидание определенной на Πn случайной величины ξn , равной числу неподвижных точек перестановки a. Дополнительно определим случайные величины
¨
1, если av = v,
v
ζn =
0, если av 6= v,
1
n

v = 1, 2, ..., n. Мы видим, что Pn (ζvn = 1) = Pn (Bvn ) = , откуда Eζvn =

Eξn = E(ζ1n + ζ2n + ... + ζnn ) = Eζ1n + Eζ2n + ... + Eζnn = n ·

1
и
n

1
= 1.
n

Итак, среднее число неподвижных точек равно 1. 
Неподвижные точки перестановки соответствуют элементам массива, которые при сортировке не нуждаются в перемещениях на другие места, они и так находятся именно там, где должны находиться,
и это может использоваться в некоторых видах сортировки (см. задачу ).
Найдем теперь вероятности еще трех событий — эти вероятности
потребуются нам при исследовании сложностей в среднем некоторых
сортировок.
Предложение .. Пусть n ∈ N+ . Тогда
(i) при 1 ¶ u ¶ n, 1 ¶ v ¶ n имеем

Pn (Fnu,v ) =

1
n

для события Fnu,v , состоящего в том, что v-й элемент перестановки
(a1 , a2 , ..., an ) равен u;
(ii) при 1 < u ¶ n и любой перестановке p чисел 1, 2, ..., u − 1 имеем

Pn (Gnu,p ) =
u,p

1
(u − 1)!

для события Gn , состоящего в том, что относительный порядок
элементов ai1 , ai2 , ..., aiu−1 перестановки (a1 , a2 , ..., an ), меньших u, совпадает с относительным порядком элементов заданной перестановки p (аналогичное утверждение имеет место для элементов, больших u);
(iii) при 0 ¶ u < v ¶ n имеем

Pn (Hnu,v ) =


1
v

Серия вероятностных «задач о совпадении» с решениями приведена в [].

§ . Сортировка и конечные вероятностные пространства



для события Hnu,v, состоящего в том, что в перестановке (a1, a2 , ..., an )
содержится u элементов ai , 1 ¶ i < v, для которых ai < av .
Доказательство. (i) Множество перестановок (a1 , a2 , ..., an ) таких,
что av = u, содержит (n − 1)! элементов, независимо от значений
u и v.


n
u,p
(ii) Событие Gn включает
(n − u + 1)! перестановок, т. е.
u−1
n!
перестановок, независимо от вида p.
(u − 1)!

(iii) Очевидно, что если p — любая перестановка чисел 1, 2, ..., v,
то множество перестановок
(a1 , a2 ..., an ) таких, что ψv (a1 , a2 , ..., av ) =
 
n
n!
элементов (мы используем функ= p, содержит
(n − v)! =
v!
v
цию ψv , определенную перед формулой (.)). Заметим, что количество тех перестановок p чисел 1, 2, ..., v, в которых последний элемент равен u + 1, есть (v − 1)!. Поэтому количество перестановок,
n!
n!
образующих событие Hnu,v , равно
(v − 1)!, т. е.
, откуда следует
v!
v
требуемое.
Напомним полезную формулу из курса теории вероятностей. Как
и прежде, мы ограничимся рассмотрением конечных вероятностных пространств элементарных событий. Пусть W — такое пространство, P — соответствующее распределение вероятностей, ξ — некоторая случайная величина (функция) на W . Пусть события W1 , W2 , ..., Wl
задают полную группу событий, т. е. эти события попарно несовместны и
W = W1 + W2 + ... + Wl .
(.)
Представление W в виде (.) с помощью некоторой полной группы
событий мы
P будем называть разложением W . Как обычно, Eξ — это
значение
ξ(w)P(w), т. е. математическое ожидание (или среднее)
w ∈W

случайной величины ξ, а E(ξ|Wk ), k = 1, 2, ..., l, суть соответствующие
условные математические ожидания этой случайной величины (при
условии осуществления события Wk ). Тогда, как известно, имеет место формула полного математического ожидания:

Eξ =

l
X

E(ξ|Wk )P(Wk ).

(.)

k =1

Оценивание математических ожиданий является оцениванием числовых сумм. В этом иногда помогает простой прием, описанный в приложении B.



Глава . Сложность в среднем

Пример .. Исследуем сложности в среднем по числу сравнений и перемещений сортировки простыми вставками, которую, как
и прежде, мы будем рассматривать в двух вариантах I1 и I2 (см. пример .). Вначале займемся первым вариантом I1 этой сортировки,
полагая затраты равными числу сравнений. Входные массивы считаем перестановками чисел 1, 2, ..., n. Для исследования сложности по
числу сравнений введем случайные величины ξ1n , ξ2n , ..., ξnn−1 , определенные так, что значение ξin для
a = (a1 , a2 , ..., an ) ∈ Πn
равно затратам на i-м шаге нашей сортировки, применяемой
к a. Ясно, что интересующее нас математическое ожидание есть
E(ξ1n + ξ2n + ... + ξnn−1 ), и
¯T¯I (n) = Eξ1 + Eξ2 + ... + Eξn−1 .
n
n
n
1

(.)

Найдем ξin , 1 ¶ i < n. Рассматривая события Hnk,i+1, k = 0, 1, ..., i, образующие разложение пространства Πn , и применяя формулу (.)
полного математического ожидания, мы имеем согласно предложению .(iii)
i
X
1
E(ξin | Hnk,i+1 ).
(.)
Eξin =
i+1

k =0

Если перестановка a = (a1 , a2 , ..., an ) принадлежит событию Hnk,i+1 , то
в этой перестановке перед элементом ai+1 имеется ровно k элементов,
меньших его, и, очевидно,
¨
i − k + 1, если k > 0,
i
ξn =
i,
если k = 0.
Мы видим, что при выполнении события Hnk,i+1 значение ξin определено однозначно (напомним, что значение ξin , i = 1, 2, ..., n − 1, равно
числу сравнений на i-м шаге, а перед выполнением i-го шага элементы a1 , a2 , ..., ai уже упорядочены по возрастанию). Поэтому
¨
i − k + 1, если k > 0,
k,i +1
i
E(ξ n | H n ) =
i,
если k = 0.
В соответствии с (.)

Eξin =



1
i+
i+1

i
X
k =1


1
i
.
(i − k + 1) = + 1 −
2

i+1

§ . Сортировка и конечные вероятностные пространства



Используя (.), получаем выражение
n−1+

n −1 
X
i =1

1
i
−
2
i+1



для искомой сложности в среднем. С помощью известной из математического анализа формулы (ее вывод имеется в приложении B)
n
X
1
= ln n + O(1)
i =1

i

сложность ¯T¯I1 (n) можно записать в виде
¯T¯I (n) = (n + 4)(n − 1) − ln n + O(1)
1

(.)

2
¯T¯I (n) = n + O(n).
1

(.)

4

и, проще, в виде
4

Таким образом, сложность в среднем по числу сравнений первого варианта сортировки простыми вставками, как и сложность в худшем
случае, есть величина порядка n2 , но при больших n первая сложность примерно вдвое меньше второй. Формула (.) показывает, что,
вообще говоря, вопреки бытовым представлениям сложность в среднем не есть среднее арифметическое затрат в худшем и в лучшем случае: такое среднее арифметическое для рассматриваемой сортировки
является рациональной функцией от n и не может описываться этой
формулой, содержащей логарифм.
Если рассмотреть вместо случайных величин ξ1n , ξ2n , ..., ξnn−1 случайные величины η1n , η2n , ..., ηnn−1 , соответствующим образом отражающие затраты исследуемой сортировки по числу перемещений, то,
очевидно, будем иметь
ξin ¶ ηin ¶ ξin + 1,

i = 1, 2, ..., n − 1. Поэтому сложность в среднем по числу перемещений
n2

+ O(n). Нетрудно показать, что и сложности в среднем
тоже есть
4
по числу сравнений и числу перемещений второго варианта сортиn2

ровки простыми вставками равны
+ O(n). Сложность в среднем по
4
суммарному числу сравнений и перемещений и для первого, и для
n2

второго варианта есть
+ O(n), поскольку для любых случайных
2
величин ξ, η, определенных на каком-либо вероятностном пространстве, выполняется
E(ξ + η ) = Eξ + Eη .
(.)



Глава . Сложность в среднем

Каждая из сложностей в среднем как по числу сравнений, так и по
числу перемещений для двух вариантов сортировки простыми вставn2

ками (всего четыре сложности) есть
+ O(n); каждая из сложно4
стей в среднем по общему числу сравнений и перемещений для двух
вариантов этой сортировки (всего две сложности) есть

n2
+ O(n).
2

Можно вспомнить, что в примере ., в котором мы рассматривали для двух вариантов сортировки простыми вставками их сложности
в худшем случае по суммарному числу сравнений и перемещений, наблюдалась непохожая ситуация, чему имеется, повторимся, простое
объяснение: в отличие от (.), равенство max(ξ + η) = max ξ + max η,
вообще говоря, места не имеет.
Общая формулировка установленного нами соотношения:
Теорема .. Сложность в среднем некоторого алгоритма по суммарному числу операций нескольких различных типов равна сумме
сложностей в среднем этого алгоритма по числу операций каждого
типа в отдельности.
Среди наиболее элементарных сортировок мы пока рассмотрели
сложность в среднем только для сортировки простыми вставками.
Сразу же можно добавить, что для сортировки выбором ее сложности
по числу сравнений в среднем и в худшем случае совпадают, так как
число сравнений однозначно определяется длиной n массива. Число
сравнений на i-м этапе (i-м просмотре массива) пузырьковой сортировки равно n − i. Не сталкиваясь с большими трудностями, можно
показать (см. задачу ), что математическое ожидание s(n) числа
просмотров массива есть
n−

n
X
k =0

k! kn−k
.
n!

(.)

Очевидно, что s(n) < n. С другой стороны,
n
X
k =0

k! kn−k
¶
n!

Поэтому s(n) ¾ n −

n
X
(n − 1)! k
k =0

n!

=

1
n

n
X
k =0

k=

n+1
.
2

n+1
n−1
=
. Мы имеем
2
2
n−1
¶ s(n) < n
2

и s(n) = Θ(n). Из этого следует, что сложность в среднем по числу
сравнений пузырьковой сортировки квадратична.

§ . Пример медленного роста сложности в среднем



Сложности в среднем по числу сравнений пузырьковой сортировки, сортировок выбором и простыми вставками имеют одинаковый
порядок со сложностями этих же сортировок в худшем случае (допускают оценку Θ(n2 )).
§ . Пример медленного роста сложности в среднем в сравнении
со сложностью в худшем случае
Следующий пример показывает, что при n → ∞ сложность в среднем
может расти существенно медленнее, чем сложность в худшем случае.
Пример .. Рассмотрим сложность в среднем ¯T¯QS (n) быстрой сортировки по числу сравнений. Будем считать, что в качестве разбивающего элемента всегда выбирается первый элемент сортируемой части
массива. Введем случайную величину ξn на Πn , равную числу сравT
нений быстрой сортировки для a ∈ Πn (в этом смысле ξn (a) = CQS
(a)).
Имеем
X
¯T¯QS (n) = Eξn = 1
ξn (a).
n!

a∈Πn

Введем разложение
Πn = Kn1 + Kn2 + ... + Knn ,

где событию Kni принадлежат все те перестановки длины n, для которых разбивающий элемент занимает i-ю позицию после завершения
разбиения. В силу предложения .(i) (видно, что Kni = Fni,1 — событие
состоит в том, что -й элемент перестановки равен i), получаем
1
n

Pn (Kni ) = ,

i = 1, 2, ..., n.

Разбиение перестановки a (первый этап быстрой сортировки) порождает две перестановки a′ ∈ Πi−1 и a′′ ∈ Πn−i . В соответствии с этим
определим еще две случайные величины
ξ′n (a) = ξi−1(a′ ),

ξ′′n (a) = ξn−i (a′′ ),

где i — номер позиции, которую занимает разбивающий элемент после разбиения. По формуле полного математического ожидания

Eξ n =

n
X
i =1

E(ξn | Kni )Pn (Kni ) =

n
X
1
(n − 1 + E(ξ′n | Kni ) + E(ξ′′n | Kni )) ;
i =1

n



Глава . Сложность в среднем

после очевидного упрощения имеем

Eξ n = n − 1 +

1
n

n
X
i =1

(E(ξ′n | Kni ) + E(ξ′′n | Kni )).

Займемся вычислением E(ξ′n | Kni ) и E(ξ′′n | Kni ), 1 ¶ i ¶ n.
Мы имеем разложение
X
Kni =
Gni,p ,
p ∈Πi−1
i,p

где событие Gn определено так же, как в предложении .(ii), — это
событие состоит в том, что относительный порядок элементов перестановки, имеющих значения, меньшие i, совпадает с порядком элементов перестановки p длины i − 1; имеем
X
E(ξ′n | Kni ) =
E(ξ′n |Gni,p )Pn (Gni,p ).
p ∈Πi−1

i,p

Когда выполняется Gn , значение ξ′n (a) равно ξi−1 (p). Принимая дополнительно во внимание предложение .(ii), имеем
X
1
= E ξ i −1 .
E(ξ′n | Kni ) =
ξi−1 (p)
(i − 1)!

p ∈Πi−1

Аналогично можно показать, что
X
ξn−i (p)
E(ξ′′n | Kni ) =
p ∈Πn−i

1
= Eξ n − i ;
(n − i)!

здесь надо рассмотреть событие, которое состоит в том, что относительный порядок элементов перестановки, имеющих значения, большие i, совпадает с порядком элементов перестановки p длины n − i.
В итоге получаем

Eξ n = n − 1 +
Так как

n
P
i =1

E ξ i −1 =

n
P
i =1

Eξ n − i =

1
n

nP
−1

n
X
i =1

(Eξi−1 + Eξn−i ).

Eξk , то

k =0

Eξ n = n − 1 +

2
n

n −1
X
k =0

Eξ k .

(.)

§ . Пример медленного роста сложности в среднем



Таким образом, для ¯T¯QS (n) = Eξn мы имеем соотношение
n −1
X
¯T¯QS (k),
¯T¯QS (n) = n − 1 + 2

n

(.)

k =0

¯T¯QS (0) = 0. Домножение обеих частей равенства (.) на n дает
n¯T¯QS (n) = n(n − 1) + 2

n −1
X

¯T¯QS (k).

k =0

При n > 0 имеем для n − 1:
(n − 1)¯T¯QS (n − 1) = (n − 1)(n − 2) + 2

n −2
X

¯T¯QS (k).

k =0

Вычитая почленно последнее равенство из предпоследнего, получаем
n¯T¯QS (n) − (n − 1)¯T̄QS (n − 1) = 2(n − 1) + 2¯T¯QS (n − 1),
т. е.
n¯T¯QS (n) − (n + 1)¯T¯QS (n − 1) = 2(n − 1).
Делим последнее равенство на n(n + 1) и переходим к новой неизвестной функции t(n) =

¯T¯QS (n)
:
n+1

t(n) − t(n − 1) = 2

n−1
,
n(n + 1)

t(0) = 0.

Решением любого уравнения вида t(n) − t(n − 1) = ϕ (n) при функции
n
P
ϕ , определенной для всех n ¾ n0 , является t(n) = ϕ (n0 ) +
ϕ (k),
k = n 0 +1

n ¾ n0 (легко доказывается индукцией по n в предположении, что если нижний предел суммирования больше верхнего, то сумма равна
нулю). В нашем случае
t(n) = 2

n
X
k =1

Мы имеем

n
P
k =1

поскольку ряд
отсюда

k−1
=2
k(k + 1)

n
X
k =1

1
−2
k+1

n
X
k =1

1
.
k(k + 1)

(.)

n
P
1
1
= ln n + O(1); с другой стороны,
= O(1),
k+1
k(k
+ 1)
k =1
∞
P

k =1

1
сходится. Таким образом, t(n) = 2 ln n + O(1);
k(k + 1)

¯T¯QS (n) = (n + 1)t(n) = 2n ln n + O(n).

(.)



Глава . Сложность в среднем

В то же время, сложность в худшем случае TQS (n) есть величина порядка n2 (см. задачу ).
Число перемещений, требуемое быстрой сортировкой для конкретного массива, не превосходит числа сравнений, домноженного
на некоторую небольшую константу, откуда сложность в среднем
¯T¯′ (n) по числу перемещений элементов допускает оценку ¯T¯′ (n) =
QS
QS
= O(n log n).
Сложность в среднем быстрой сортировки как по числу сравнений,
так и по числу перемещений элементов допускает оценку O(n log n).
Быстрая сортировка не использует дополнительных массивов, поэтому пространственная сложность по числу одновременно хранимых
дополнительных величин, равных каким-то элементам исходного массива, ограничена (небольшой) константой и, как следствие, допускает оценку O(1).
Нелишне заметить, что если быстрая сортировка реализована как
рекурсивная процедура, то при ее выполнении будет использован
стек отложенных заданий. Рекурсию в данном случае можно организовать так, что в стек будут попадать лишь значения индексов некоторых элементов, но не сами элементы массива. В соответствии с определением алгебраической сложности объем такого стека не влияет на
пространственную сложность.
Если выйти за рамки алгебраической сложности, то размер стека
отложенных заданий становится важной характеристикой алгоритма. Мы рассмотрим размер этого стека для некоторого типа рекурсивных сортировок, к которому относится не только быстрая сортировка, но и, например, рекурсивный вариант сортировки слияниями.
Пусть сортировка организована так, что на первом ее этапе мы, следуя некоторому принципу, выделяем из массива x длины n > 1 две
какие-то его непересекающиеся части x ′ , x ′′ , длина каждой из которых меньше n. На втором этапе эти части сортируются рекурсивно
с помощью той же сортировки, и на третьем, заключительном, этапе,
исходя из результатов сортировки x ′ и x ′′ , массив x представляется,
уже без рекурсий, в упорядоченном виде. Если n = 0 или n = 1, то
никаких действий над элементами массива не производится.
Будем использовать для такого рода сортировок рабочее название
«бинарные рекурсивные сортировки». Возникающие при выполнении
таких сортировок рекурсии реализуются с помощью стека отложенных заданий.
Теорема .. Если некоторая бинарная рекурсивная сортировка
такова, что первым из x ′ , x ′′ сортируется массив, имеющий не пре-

§ . Пример медленного роста сложности в среднем



n

длину, то в ходе применения сортировки к массиву x
восходящую
2
длины n > 1 число отложенных заданий, хранящихся в стеке, никогда
не превосходит log2 n.
Доказательство. Проведем индукцию по n. При n = 2 утверждение, очевидно, справедливо. Пусть утверждение доказано для
2, 3, ..., n − 1, и пусть массив x, содержащий n элементов, на первом
этапе сортировки порождает два массива x ′ , x ′′ , причем длина n′
n
первого массива x ′ не превосходит , длина n′′ второго массива x ′′
2
не превосходит n − 1. Пусть n′′ ¾ n′ ¾ 1. На протяжении сортировки
массива x ′ , помимо отложенных заданий, связанных с сортировкой
x ′ , в стеке будет храниться еще одно задание — сортировать x ′′ .
Но в момент, когда сортировка массива x ′ завершена, в стеке не
останется никаких ее следов; таким образом, по предположению
индукции, число отложенных заданий в стеке никогда не превзойn
дет max{log2 n′ + 1, log2 n′′ }. В силу того, что n′ ¶ и n′′ ¶ n − 1, мы
2
имеем
max{log2 n′ + 1, log2 n′′ } ¶ log2 n,
что и требовалось.
Полученная оценка числа отложенных заданий, хранящихся в стеке, является оценкой для сложности в худшем случае и, тем самым,
для сложности в среднем тоже.
Принимая во внимание теорему ., мы приходим к варианту быстрой сортировки, представляемому рекурсивной процедурой qsort(k, l),
обращение к которой обеспечивает сортировку части xk , xk+1 , ..., xl исходного массива x1 , x2 , ..., xn ; при k ¾ l никаких действий не производится. Сам массив x1 , x2 , ..., xn является глобальным по отношению
к процедуре:

if k < l then
xk выбирается в качестве разбивающего элемента и выполняется разбиение xk , xk+1 , ..., xl ; пусть i — индекс, получаемый разбивающим элементом после разбиения;
if i − k < l − i then qsort(k, i − 1); qsort(i + 1, l) else
qsort(i + 1, l); qsort(k, i − 1)

fi
fi.

Быстрая сортировка всего массива является результатом выполнения
qsort(1, n).



Глава . Сложность в среднем

§ . Функция затрат рандомизированного алгоритма
Определение .. Алгоритмы с элементами случайности, реализуемыми обращениями к генераторам случайных чисел, называются
рандомизированными.
Рандомизированные алгоритмы можно разделить на вероятностные, или, что то же самое, алгоритмы типа Монте-Карло, и алгоритмы
типа Лас-Вегас. Первый тип допускает, что ответ, который дает алгоритм для поставленной задачи с некоторым конкретным входом, может
быть неправильным, хотя бы и с малой вероятностью; второй тип —
Лас-Вегас — гарантирует правильный ответ, но (как и для алгоритмов
типа Монте-Карло) время получения ответа для конкретного входа
не определяется, вообще говоря, однозначно этим входом  . Исключая
специально оговариваемые редкие случаи, мы будем рассматривать
только алгоритмы типа Лас-Вегас, не упоминая этого каждый раз.
Анализ сложности рандомизированного алгоритма сводится к нахождению математических ожиданий некоторых случайных величин.
Но ситуация здесь отличается от той, когда множество входов фиксированного размера рассматривается как вероятностное пространство и затраты алгоритма, однозначно определенные для каждого
конкретного входа, становятся случайными величинами на этом пространстве (мы шли этим путем в двух предыдущих параграфах). При
исследовании рандомизированных алгоритмов вероятностное пространство, на котором рассматриваются случайные величины, состоит из сценариев выполнения алгоритма для фиксированного входа,
и каждый сценарий определяется тем, какие случайные числа будут сгенерированы в соответствующие моменты выполнения алгоритма; за каждым таким сценарием закрепляется некоторая вероятность. В нашем контексте генератор случайных чисел можно представлять себе как стандартную функцию random(N) целого положительного аргумента N, результатом выполнения которой является элемент множества {0, 1, ..., N − 1}, но невозможно предсказать точно,
каким именно будет значение этой функции, — любой из элементов
указанного множества может появиться с вероятностью 1/ N.
Таким образом, затраты рандомизированного алгоритма при фиксированном входе, вообще говоря, не определяются однозначно, но

Эта классификация является достаточно распространенной в специальной литературе по рандомизированным алгоритмам — см., например, книгу [], — но не единственной. Например, в [, разд. .] рандомизированные алгоритмы подразделяются
иначе, а именно — на алгоритмы типа Монте-Карло, типа Лас-Вегас и шервудские. Мы
не будем останавливаться на этом.

§ . Функция затрат рандомизированного алгоритма



зависят от сценария вычисления. При фиксированном входе мы можем рассмотреть множество всех сценариев и, приписав адекватным
образом каждому из сценариев некоторую вероятность, ввести на полученном вероятностном пространстве случайную величину, значение которой для данного сценария равно соответствующим вычислительным затратам. Значение функции затрат на данном входе можно
положить равным математическому ожиданию этой случайной величины (усредненным затратам для данного входа). А после того как
определена функция затрат и принято соглашение о том, что такое
размер входа, мы можем, как обычно, рассматривать сложность алгоритма — в худшем случае или же в среднем (последнее возможно,
если только множество входов каждого фиксированного размера является вероятностным пространством).
Мы не будем здесь сколь-либо глубоко входить в общие проблемы теории сложности рандомизированных алгоритмов, а ограничимся рассмотрением примеров, в которых вероятностное пространство
сценариев является одним и тем же для каждого из входов данного
размера (в общем случае это не так).
Пример .. Вновь обратимся к быстрой сортировке. В §  нами установлено, что быстрая сортировка имеет сравнительно низкую
сложность в среднем в предположении, что для каждого n > 0 все относительные порядки элементов входных массивов длины n имеют
1
. Но в некоторых практических задачах
одинаковую вероятность
n!
это предположение может оказаться безосновательным в силу того,
что все входные массивы изначально оказываются, например, «почти
упорядоченными». Число сравнений, затрачиваемых быстрой сортировкой на каждом таком «почти упорядоченном» массиве, будет близко к n2 , что сведет на нет достоинства быстрой сортировки.
Однако если разбивающий элемент выбирать случайно, то при
каждом фиксированном входе размера n усредненные затраты будут
иметь порядок n log n, что и будет показано ниже. Итак, под рандомизированной быстрой сортировкой мы будем понимать быструю
сортировку со случайным выбором индекса разбивающего элемента;
если надо выбрать случайное значение m из k, k + 1, ..., l, то мы полагаем m := k + random(l − k + 1). В том алгоритме, который записан
в виде процедуры в конце § , вместо
xk выбирается в качестве разбивающего элемента и выполняется разбиение xk , xk+1 , ..., xl ; пусть i — индекс, получаемый разбивающим элементом после разбиения;



Глава . Сложность в среднем

можно написать
m := k + random(l − k + 1);
xm выбирается в качестве разбивающего элемента и выполняется разбиение xk , xk+1 , ..., xl ; пусть i — индекс, получаемый
разбивающим элементом после разбиения;
это даст рандомизированный вариант быстрой сортировки.
Пусть дан массив x1 , x2 , ..., xn попарно различных чисел. Пусть мы
выбираем элемент m из множества {1, 2, ..., n} и вероятность выбора
1
каждого из элементов есть . Тогда место xm в массиве x1 , x2 , ..., xn
n
после сортировки этого массива может оказаться любым с одной
1
и той же вероятностью . В самом деле, пусть 1 ¶ i ¶ n и пусть l(i) таn
ково, что xl(i) занимает после сортировки массива место с номером i.
Это l(i) определяется единственным образом. Поэтому вероятность
попадания xm после сортировки массива на i-е место равна вероят1
ности того, что m = l(i). Последняя вероятность, очевидно, равна .
n
Следовательно, приписывание одинаковой вероятности каждому возможному выбору индекса разбивающего элемента ведет к тому, что
вероятность каждого из событий «после этапа разбиения элемент, выступавший в качестве разбивающего, занимает в массиве i-е место»,
1
i = 1, 2, ..., n, равна .
n
Это обстоятельство позволяет переформулировать задачу анализа
сложности рандомизированной быстрой сортировки, например, следующим образом. Имеется полоска бумаги шириной в одну клетку
и длиной в n клеток, n ¾ 0, которую надо разрезать на отдельные
клетки. Разрезы имеет право производить некий разрезальщик, которому надо платить за работу. При n = 0 или n = 1 разрезальщик
ничего не делает и ничего не получает. В случае n > 1 он выбирает
случайным образом (тянет из шапки билет с номером) значение i
из множества {1, 2, ..., n} и затем вырезает из полоски i-ю клетку
(рис. ), получая за этот этап работы вознаграждение в n − 1 рубль.
Кроме вырезанной клетки возникают две полоски, длина каждой из

i
Рис. . Этап разрезания полоски.

§ . Функция затрат рандомизированного алгоритма



которых не превышает n − 1, при этом не исключается равенство
нулю одной из длин. С каждой из двух полосок разрезальщик проделывает ту же операцию, получая вознаграждение в соответствии
с тем же принципом оплаты. Каково математическое ожидание размера вознаграждения, получаемого разрезальщиком за всю работу?
Здесь при фиксированном n множество всех возможных сценариев (будем называть их n-сценариями) — это фактически множество
3
0

3
0

2
0

1

3
2

1

1
0

3
1

0

2
0

3

1

0

2
0

1

Рис. . Сценарии разрезания полоски из трех клеток (-сценарии).

некоторых двоичных деревьев; на рис.  показано одно из возможных представлений множества всех -сценариев. В каждой вершине
дерева записывается число клеток в полоске.
n
При произвольном n ¾ 0 понятие n-сценария
определяется рекурсивно: -сценарий и -сценарий — это одна вершина, которой приписано число 0 или соответственно 1; пусть n > 1,
тогда любой n-сценарий s получается выбоi −1
n−i
ром некоторого числа i, 1 ¶ i ¶ n, некоторого
(i − 1)-сценария s′ и некоторого (n − i)-сценаs′
s′′
рия s′′ : из корня n исходят ребра к вершинам
i − 1 и n − i, к которым подклеиваются корни
Рис. . Структура
сценариев s′ и s′′ (рис. ). Каждому n-сценаn-сценария.
рию s естественным образом приписывается
вероятность Pn (s) (здесь индекс n указывает
на то, что вероятность соотнесена с некоторым n-сценарием): если
n = 0 или n = 1, то сценарии имеют вероятность 1, а при n > 1
1
n

Pn (s) = Pi−1 (s′ )Pn−i (s′′ ).

(.)

Например, третий из -сценариев, изображенных на рис. , имеет
1
1
вероятность , каждый из остальных — вероятность .
3
6
Формула (.) отражает идею алгоритма, а именно что после определения i выбор (i − 1)-сценария s′ и выбор (n − i)-сценария s′′ независимы друг от друга. Эта формула превращает множество всех n-сценариев при фиксированном n в вероятностное пространство Sn . Поль-



Глава . Сложность в среднем
P
Pn (s) = 1: при
зуясь индукцией по n, проверим, например, что
s ∈ Sn

n = 0 и n = 1 это очевидно, при n > 1 имеем
X
s ∈ Sn

Pn (s) =

n
X
X

1
P (s′ )Pn−i (s′′) =
n i −1

′

i =1 s ∈Si−1
s′′ ∈Sn−i

=

1
n

n  X
X
s′ ∈Si−1

i =1

Pi−1 (s′ )

 X
s′′ ∈Sn−i

Pn−i (s′′ )


=

1
n

n
X
i =1

1 · 1 = 1.

Плата за разрезание полоски длины n на отдельные клетки полностью определяется использованным n-сценарием, это задает случайную величину χn на Sn , и нас интересует математическое ожидание
этой величины. Для сценария s, представленного на рис. , мы назовем s′ и s′′ левым и правым подсценариями. При n > 1 определим
на Sn дополнительно к χn еще две случайные величины χn′ и χn′′ , положив χn′ (s) = χi−1 (s′ ) и χn′′ (s) = χn−i (s′′ ), где s′ и s′′ суть левый и правый
подсценарии сценария s. Имеем при n > 1
χn (s) = n − 1 + χn′ (s) + χn′′ (s).

Пусть n > 1. Введем разложение
Sn = S1n + S2n + ... + Snn ,

(.)

где Sin — это событие «левый подсценарий данного n-сценария является (i − 1)-сценарием (и соответственно правый подсценарий является
(n − i)-сценарием)», i = 1, 2, ..., n. Очевидно,
1
n

Pn (S1n ) = Pn (S2n ) = ... = Pn (Snn ) = ,
поэтому по формуле полного математического ожидания получаем

Eχ n =

n
X
i =1

1
n

E(χn |Sin ) =

1
=n−1+
n

=n−1+

1
n

=n−1+

2
n

n
X
i =1
n
X
i =1
n
X
i =1

(E(χn′ |Sin ) + E(χn′′ |Sin )) =
( E χ i −1 + E χ n − i ) =

E χ i −1 = n − 1 +

2
n

n −1
X
k =0

Eχ k .

§ . Функция затрат рандомизированного алгоритма



Итак,

Eχ n = n − 1 +

2
n

n −1
X

Eχ k ,

Eχ0 = 0.

k =0

Такого вида соотношения уже встречались в предыдущем параграфе,
и по аналогии с (.) мы находим

Eχn = 2n ln n + O(n).

(.)

Возвратимся к рандомизированной быстрой сортировке. Для данного массива длины n математическое ожидание затрат, измеряемых
числом сравнений, полностью определяется значением n. Поэтому,
например, сложность в худшем случае, т. е. максимум математических ожиданий рассматриваемого вида для массивов длины n, есть
просто математическое ожидание, найденное при рассмотрении этого n. Мы можем переписать (.) как соотношение для сложности
TeQS (n) по числу сравнений рандомизированной быстрой сортировки:
TeQS (n) = 2n ln n + O(n).
Вновь можно заметить, что число перемещений, требуемое рандомизированной быстрой сортировкой для конкретного массива, не
превосходит числа сравнений, домноженного на некоторую констан′
ту, откуда сложность в среднем TeQS
(n) по числу перемещений эле′
e
ментов допускает оценку TQS (n) = O(n log n). Как и обычная быстрая
сортировка, рандомизированная быстрая сортировка не использует
дополнительных массивов, поэтому S̃QS (n) = O(1).
Сложность рандомизированной быстрой сортировки как по числу
сравнений, так и по числу перемещений элементов допускает оценку O(n log n). Пространственная сложность по числу одновременно
хранимых дополнительных величин, равных каким-то элементам исходного массива, допускает оценку O(1).
При использовании принципа «из двух заданий первым выполняется более простое», мы получаем, согласно теореме ., для сложности по объему стековой памяти оценку log2 n.
Совпадению сложностей ¯T¯QS (n) и TeQS (n) можно дать объяснение: случайный выбор разбивающего элемента, предпринимаемый
на каждом этапе сортировки, эквивалентен тому, что мы меняем
порядок исходного массива случайным образом и затем применяем
«обычную» быструю сортировку; но равенство сложностей такого рода не обязано иметь место для других алгоритмов, — все-таки речь
идет о математических ожиданиях случайных величин, определенных



Глава . Сложность в среднем

на разных вероятностных пространствах. Например, можно несколько ускорить рандомизированную быструю сортировку, если разбивающий элемент определять путем случайного выбора без возвращения
трех элементов массива и последующего определения второго по величине из этих трех; можно показать, что тогда вместо 2n ln n + O(n)
12
n ln n + O(n)  , и совпадения сложностей обычной и ранвозникнет
7
домизированной быстрой сортировки уже не будет.
Возвращаясь к примеру ., мы видим, что, основываясь на рандомизированной быстрой сортировке, можно получить алгоритм построения выпуклой оболочки данных n точек координатной плоскости,
имеющий сложность в среднем O(n log n) по общему числу операций.
При нахождении или оценивании сложности какого-либо рандомизированного алгоритма часто не возникает необходимости детального
рассмотрения всевозможных сценариев. Бывает достаточно рассмотреть сходное с (.) разложение пространства сценариев и применить
формулу полного математического ожидания. Даже если множество
всех сценариев бесконечно, разложение вида (.) можно выбрать конечным.
Пример .. Массив x1 , x2 , ..., xn назовем массивом, содержащим
большинство, если больше половины его элементов имеют равные
значения. Пусть над элементами массивов разрешена операция проверки равенства двух элементов, будем называть эту операцию сравнением. Пусть для данного массива, содержащего большинство, требуется найти i, 1 ¶ i ¶ n, такое, что значение xi принадлежит большинству значений элементов x1 , x2 , ..., xn . Один из возможных рандомизированных алгоритмов решения этой задачи состоит в том,
что i выбирается случайно (распределение вероятностей равномерно), а затем проверяется, удовлетворяет ли xi поставленному условию, — сравнений на эту проверку уйдет не более n − 1. Если xi не
подходит, то все повторяется. Сложность в среднем по числу сравнений этого алгоритма не превосходит 2(n − 1). В самом деле, пространство всех сценариев разлагается на два события: первая попытка найти нужное i оказывается удачной и, соответственно, эта попытка оказывается неудачной. По формуле полного математического
ожидания имеем для искомого среднего a:
1
p

a ¶ p(n − 1) + (1 − p)(a + n − 1).

Отсюда a ¶ (n − 1) < 2(n − 1).


Доказательство имеется, например, в [, разд. .].

Задачи



Еще один путь получения этого же результата. Так как вероятность p удачного выбора индекса i больше половины, то математическое ожидание количества попыток, которые потребуются для получения удачного значения i, меньше двух. Отсюда среднее число сравнений a меньше, чем 2(n − 1).
Теоретически нет никакого препятствия к тому, чтобы при определении функции затрат рандомизированного алгоритма взять вместо математического ожидания максимум затрат по соответствующим сценариям (при таком подходе рандомизированная быстрая сортировка имеет квадратичную сложность). Но обычно для
рандомизированных алгоритмов рассматриваются усредненные затраты.
Добавим в заключение, что правомерен взгляд на рандомизированные алгоритмы, при котором каждому возможному входу сопоставляется вероятностное пространство обычных детерминированных алгоритмов  . Если в этой связи вернуться к примеру ., то
можно заметить, что для разрезания полоски бумаги каждый из рассматриваемых сценариев задает конкретный детерминированный алгоритм разрезания.
Мы вернемся к этому в § .
Задачи
. Верно ли, что для рассмотрения сложности в среднем некоторого алгоритма требуется задание распределения вероятностей
а) на множестве всех допустимых входов?
б) на каждом из множеств всех входов фиксированного размера?
. Как говорилось при обсуждении асимптотического закона распределения простых чисел, в [] приводится элементарное доказательство неравенств Чебышева с C = 6, c = 1/3. Добавим, что наиболее легко доказывается нижняя оценка
π(n) >

1 n
,
3 ln n

справедливая для всех n > 1. Доказать, что сложность в среднем алгоритма пробных делений не является полиномиально ограниченной,
используя для этого только последнее неравенство и не прибегая
к полному варианту асимптотического закона распределения простых
чисел.


См., например, [].



Глава . Сложность в среднем

Указание. Предположение о том, что V (m) < 23m/4 для всех m > m0 , позволило бы, исходя из равенства
π(2m ) = π(2m0 ) + V (m0 + 1) + V (m0 + 2) + ... + V (m),

вывести верхнюю оценку π(2m ) = O(23m/4 ), что вступило бы в противоре2m

чие с неравенством π(2m ) ¾ c
с положительной константой c. Поэтому
m
существует последовательность m1 < m2 < ... натуральных чисел таких, что
V (mi ) ¾ 23mi /4 , i = 1, 2, ... Можно рассмотреть (.) для m = m1 , m2 , ...

. Сложность по числу перемещений (обменов) в среднем для
сортировки выбором при условии, что мы исключаем обмены вида
1
xk ↔ xk , не превосходит n − 2 + , где n — длина массива.

n
Указание. В перестановках из Πn среднее число элементов ai , 1 ¶ i ¶ n − 1,

таких, что ai = i, есть

n−1
(см. пример .).
n

. Найти среднее число присваиваний m := ... при выполнении
алгоритма поиска наименьшего элемента массива:
m := x 1 ;
for i = 2 to n do
if xi < m then m := xi fi
od
Предполагается, что все возможные взаимные порядки элементов
в исходном массиве длины n являются равновероятными; в качестве
размера входа берется n.
Указание. Рассмотреть разложение всего вероятностного пространства в
сумму двух событий: последний элемент исходного массива является его наи1

меньшим элементом (вероятность равна ) и соответственно последний элеn
мент исходного массива не является его наименьшим элементом (вероятn−1

ность равна
). Пусть s(n) обозначает искомое математическое ожидание.
n
Показать, что условное математическое ожидание исследуемого числа присваиваний, соответствующее первому событию, есть s(n − 1) + 1, а условное
математическое ожидание, соответствующее второму событию, есть s(n − 1).
Пользуясь формулой полного математического ожидания, вывести отсюда рекуррентное соотношение для s(n) и найти его решение, удовлетворяющее
условию s(1) = 1.

. Пользуясь дискретным аналогом формулы Ньютона—Лейбниn
P
ца, согласно которому
( f (k + 1) − f (k)) = f (n + 1) − f (1), вычислить сумму

n
P
k =1

k =1

1
, входящую в (.).
k(k + 1)

Задачи



. Исходя из (.), пользуясь приемом оценки сумм из приложения B и результатом из предыдущей задачи, доказать неравенство ¯T¯QS (n) ¶ 2n ln n, из которого будет следовать, что величина O(n)
в правой части (.) отрицательна.
. Вернемся к задаче . В качестве алгоритма с указанными свойствами можно предложить следующий: при наличии вагонов на правой стороне узла к операции В прибегаем лишь тогда, когда на левой стороне невозможно увеличить на 1 число вагонов с правильным чередованием цветов с помощью какой-то из операций МИМО
и ИЗ; в остальных случаях выполняется одна из операций МИМО
и ИЗ, если возможны обе, то первая из них. Как и в задаче , считаем, что черных и белых вагонов по n штук, и n — размер входа.
Какова сложность по числу сортировочных операций этого алгоритма в среднем?
Указание.  Можно доказать следующие три утверждения.
) Предположим, что в исходном расположении первый вагон на правой
стороне белый. Тогда число сортировочных операций, требующихся алгоритму, равно 3n − k, где k есть количество максимальных сплошных последовательностей черных вагонов в исходном расположении (непосредственно
слева и справа от каждой такой сплошной последовательности нет черных
вагонов, таков смысл «максимальности»).
) Вновь предположим, что в исходном расположении первый вагон на
правой стороне белый. Тогда количество исходных расположений, в которых
имеется ровно
k максимальных
сплошных последовательностей черных ва 

n

n−1

гонов, есть
.
k
k−1

 

nP
− 1
n−1
n−1
2n − 2
)
=
.
k =1

n−k

k

n

Из первых двух утверждений выводится, что искомая сложность в среднем есть
nP
−1

2n + 2 ·

k =1

(n − k)

 n  n − 1 
k

 2n 

k−1

,

n

третье утверждение позволяет получить из этого, что интересующая нас
сложность есть

n(5n − 3)
5
1
= n + + o(1).
2n − 1
2
4

. (Задача не связана со сложностью в среднем, но приводит к рекуррентному соотношению, которое решается сходно с (.).) Доказать, что для любого l > 0 можно, не применяя клей, построить из
костяшек домино, длина каждой из которых равна 2, навес длины l


Решение принадлежит А. П. Фокину.



Глава . Сложность в среднем

|

{z
l

}

Рис. . Навес из костяшек домино.

(рис. ). Предложить алгоритм конструирования таких навесов, требующий O(el ) костяшек.
Указание. Будем характеризовать навес из n костяшек неотрицательными
числами l1 , l2 , ..., ln , где li — расстояние от правого края i-й сверху костяшки
до вертикальной (пунктирной на рис. ) линии, проходящей через правый
край -й, т. е. самой верхней, костяшки. (Таким образом, l1 = 0, ln = l .) Считая,
что вес каждой костяшки равен 1, можно показать, что условием равновесия
является система неравенств
l i +1 ¶

(l1 + 1) + (l2 + 1) + ... + (li + 1)
,
i

i = 1, 2, ..., n − 1

(каждое такое неравенство означает, что центр тяжести конструкции из
i верхних костяшек не выходит за правый край (i + 1)-й костяшки). Самый
длинный навес получается тогда, когда числа l1 , l2 , ... подчинены рекуррентному соотношению

l i +1 =

(l1 + 1) + (l2 + 1)... + (li + 1)
,
i

l1 = 0.

Далее можно идти тем же путем, что и при решении соотношения (.) и т. д.

. Перестановка (a1 , a2 , ..., an ) ∈ Πn называется полной, если ai 6= i,
i = 1, 2, ..., n. Вероятность dn = Pn (Dn ) события Dn , состоящего в том,
что данная перестановка является полной, равна 0 при n = 1 и равна
(−1)n
1
1
− + ... +
2!
3!
n!
1
при n > 1 (следствие: lim dn = ).
e
n→∞

(.)

Задача о значении dn широко известна как задача о шляпах. На
собрание, состоявшееся поздно вечером, n его участников пришли
в шляпах и оставили их в раздевалке, а когда собрание окончилось,
разобрали шляпы наугад в темноте (в раздевалке перегорела лампочка) и разошлись по домам. Какова вероятность того, что каждый
пришел домой в чужой шляпе?
Указание. Для любого r такого, что 0 ¶ r ¶ n, можно рассмотреть вероятность p(n, r) того, что перестановка длины n имеет ровно r непо-

Задачи



движных точек (ровно r человек пришли домой в своих шляпах). Тогда
 p(n,
 0) + p(n, 1) + ... + p(n, n) = 1. Далее надо доказать, что p(n, r) =
1
n
1
p(n − r, 0) = p(n − r, 0), откуда будет следовать, что
=
r

n(n − 1)...(n − r)

r!

1
1
1
1
1
d + d + d + ... +
d + d = 0.
0! n 1! n−1 2! n−1
(n − 1)! n−1 n! 0

С учетом d0 = 1 последнее соотношение однозначно определяет все d1 , d2 , ...
Остается убедиться, что подстановка значений (.) в левую часть этого со-

1
1
1
(−1)r
1
−
+
−
+ ... +
, r = 0, 1, ..., n,
0!
1!
2!
3!
r!
−j
n nP
i
P
(−1)
в левую часть этого соотношения, получим
(роль r играет n − j ).
j =0 i=0 j! i!

отношения дает 0. Подставляя

Слагаемые этой суммы можно перегруппировать так, чтобы внутри группы
значение i + j было постоянной величиной l . Это даст
n X
l
X
(−1)i
l =0 i =0

(l − i)! i!

=

n 
l
X
1 X
l =0

l!

i =0



l!
(−1)i ,
(l − i)! i!

последний шаг доказательства очевиден.

. При быстрой сортировке (в любом из рассмотренных ее вариантов) число пар индексов (i, j), попадающих в стек отложенных
заданий, не превосходит длины n исходного массива.
. Верно ли, что определение усредненных затрат некоторого
рандомизированного алгоритма требует задания распределения вероятностей
а) на множестве всех допустимых входов?
б) на каждом из множеств всех входов фиксированного размера?
. Если измерять затраты рандомизированной быстрой сортировки количеством обращений к генератору случайных чисел, то сложность этой сортировки есть величина порядка n. То же самое верно,
если в определении функции затрат вместо математического ожидания взять максимум затрат по соответствующим сценариям.
. Идея, лежащая в основе быстрой сортировки, может быть
использована для нахождения m-го наименьшего элемента среди
a1 , a2 , ..., an , 1 ¶ m ¶ n (самый маленький элемент — это -й наименьший, следующий элемент — -й наименьший и т. д.). Разбиение массива с использованием случайно выбранного разбивающего элемента
порождает два массива длины i − 1 и n − i при некотором 1 ¶ i ¶ n. Если m = i, то поиск закончен, если m ¶ i − 1, то далее рекурсивно находится m-й наименьший в первом массиве, а если m > i, то рекурсивно
находится (m − i)-й наименьший во втором массиве. Можно ввести
сложность по числу сравнений при рассмотрении двух параметров



Глава . Сложность в среднем

n, m размера входа. Беря максимум этих сложностей по всем m та¯
ким, что 1 ¶ m ¶ n, определяем сложности T(n), ¯T(n)
по числу сравнений в худшем случае и в среднем с использованием n в качестве
¯
размера входа. Показать, что T (n) = Θ(n2 ) и ¯T(n)
< 4n.
Указание. Возьмем U(n) = max ¯T̄ (k). Очевидно, что U(n) не убывает при
1¶ k ¶ n

возрастании n и что ¯T̄(n) ¶ U(n). Доказывается неравенство
1
n

U(n) ¶ (U(n − 1) + max{U(1), U(n − 2)} + ...
... + max{U(n − 2), U(1)} + U(n − 1)) + n − 1,
из которого, в силу неубывания U(n), следует

j k
2
n
U(n) ¶
U(n − 1) + U(n − 2) + ... + U
+ n.
n

2

Отсюда с помощью индукции выводится, что U(n) < 4n для всех n ¾ 1.

. В инверсионном векторе (b1 , b2 , ..., bn ) произвольной перестановки (a1 , a2 , ..., an ) ∈ Πn каждая компонента bi равна количеству целых j таких, что 1 ¶ j < i и a j > ai . Например, инверсионный вектор
перестановки (2, 4, 3, 1, 6, 5) — это (0, 0, 1, 3, 0, 1). Показать, что каждому целочисленному вектору (b1 , b2 , ..., bn ), для которого 0 ¶ bi < i,
i = 1, 2, ..., n, соответствует некоторая перестановка длины n, для которой этот вектор является инверсионным.
Указание. Очевидно, что если bn = k, 1 ¶ k < n, то an = n − k, и это соображение приводит к алгоритму построения (a1 , a2 , ..., an ), применимому
к любому вектору b, удовлетворяющему оговоренным условиям: просматриваем компоненты вектора b, продвигаясь от последней к первой, находим
значение соответствующей компоненты перестановки a и удаляем найденное значение из множества M , первоначально равного {1, 2, ..., n}; при этом
значение ai , i = n, n − 1, ..., 1, определяется как (bi − 1)-й наибольший в множестве M (самый большой элемент — это первый наибольший, следующий
по величине элемент — это второй наибольший и т. д.).

. Показать, что один этап пузырьковой сортировки понижает на
единицу значение каждой неотрицательной компоненты инверсионного вектора перестановки (см. предыдущую задачу) и не изменяет
нулевые компоненты. Показать, что вероятность того, что значение
максимума компонент инверсионного вектора выбранной наугад перестановки длины n равно k, 0 ¶ k < n, есть

kn−k k!
.
n!

Указание ко второй части задачи. Количество векторов (b1 , b2 , ..., bn ), для
каждого из которых bi ∈ N+ , 0 ¶ bi < i, i = 1, 2, ..., n, и max{b1 , b2 , ..., bn } ¶ k,

Задачи



1 ¶ k ¶ n − 1, равно k! kn−k−1 , так как bi может принимать любое значение
между 0 и i − 1 при i ¶ k и любое значение между 0 и k − 1 для k < i ¶ n.

. Показать, что математическое ожидание числа этапов пузырьковой сортировки совпадает с (.).
Указание. Пользуясь решением предыдущей задачи, легко получить, что
это математическое ожидание есть
n
1 X
(k(kn−k k! − (k − 1)n−k+1 (k − 1)!),
n!

что равно
X
n
1
n!

k =1

k =1

(kn−k+1 k! − (k − 1)n−k+2 (k − 1)!) −

n

X
(k − 1)n−k+1 (k − 1)! .
k =1

В упрощении последнего выражения поможет дискретный аналог формулы
Ньютона—Лейбница (см. задачу ).

. Используя идею решения задачи , предложить рандомизированный алгоритм восстановления перестановки длины n по ее инверсионному вектору (см. задачу ), имеющий сложность в среднем
по числу сравнений O(n2 ).
. Пусть (a1 , a2 , ..., an ) — произвольная перестановка длины n. Ее
преобразование

for i = n downto 2 do j := 1 + random(i − 1); ai ↔ a j od
1

. (Это
может дать любую перестановку длины n с вероятностью
n!
дает алгоритм построения случайных перестановок с равномерным
распределением вероятностей.)
. Предположим, что у нас нет другого генератора случайных чисел, кроме генератора, в результате обращения к которому появля1
(аналог подбрасывания
ется 0 или 1 с одинаковой вероятностью
2
монеты), и пусть p, 0 ¶ p ¶ 1, — заданное вещественное число. Каким образом с помощью этого генератора можно определить генератор randp, в результате обращения к которому появляется 0 или 1
с вероятностями соответственно p и 1 − p (незначительные отклонения допустимы)? Сложность в среднем алгоритма получения одного
случайного числа с помощью randp должна быть меньше 2 (затраты
определяются числом обращений к изначально имеющемуся генератору).
Указание. Представить p (возможно, с небольшой погрешностью) в виде
a
a
a
конечной суммы вида 1 + 22 + ... + kk , где ai — это 0 или 1 для всех i,
2

2

2

а k — некоторое целое положительное число.



Глава . Сложность в среднем

. Пусть изначально у нас имеется генератор случайных вещественных чисел, принадлежащих отрезку [0, 1], и вероятность появления числа, принадлежащего отрезку [a, b], 0 ¶ a ¶ b ¶ 1, есть b − a.
Пусть даны неотрицательные вещественные числа α0 , α1 , ..., αN −1 такие, что α0 + α1 + ... + αN −1 = 1. Как определить генератор чисел, принадлежащих множеству {0, 1, ..., N − 1}, такой, что вероятность появления числа k, 0 ¶ k ¶ N − 1, равна αk ?
. Предположим, что у нас нет другого генератора случайных чисел, кроме генератора, в результате обращения к которому появляется 0 с вероятностью p или 1 с вероятностью 1 − p, причем о p мы
ничего не знаем, кроме того, что p 6= 0 и p 6= 1. Как с помощью этого
генератора можно сконструировать генератор, в результате обращения к которому появляется 0 или 1 с одинаковой вероятностью 1/2?
Указание. Порождая подряд две цифры с помощью имеющегося генератора, мы получаем комбинации 0, 1 и 1, 0 с одинаковой ненулевой вероятностью.

. (Продолжение предыдущей задачи.) Чему равно математическое ожидание числа обращений к изначально имеющемуся генератору случайных чисел при построении последовательности пар до появления 0, 1 или 1, 0? Найти сложность в среднем алгоритма получения
k «равновероятных» нулей и единиц с помощью сконструированного
генератора (затраты определяются количеством обращений к изначально имеющемуся генератору). Можно ли указать значения p, для
которых эта сложность имеет минимальное и, соответственно, максимальное значение?
. Предложенную в указании к задаче  идею обобщить на случай, когда необходимо сконструировать генератор random(N), N ¾ 1,
описанный в § . Найти сложность в среднем алгоритма получения
k равновероятных случайных чисел из отрезка [0, N − 1] (затраты
определяются числом обращений к изначально имеющемуся генератору).
. Сохранится ли для сложности в среднем формула 2n ln n + O(n),
если в задаче о разрезании полоски клетчатой бумаги на отдельные
клетки (см. пример .) считать, что плата за вырезание одной случайно выбранной клетки равна не n − 1, а n рублей? Тот же вопрос,
если эта плата составляет n2 рублей.
. Известное утверждение (теорема Дирихле,  г.), что два
6
случайных числа x, y ∈ N+ с вероятностью P, равной 2 , оказываются
π
взаимно простыми, имеет тот смысл, что если ввести в рассмотрение
число M(n), равное количеству пар (x, y) таких, что x и y взаимно

Задачи



просты и, дополнительно, 1 ¶ x, y ¶ n, то предел lim

n→∞

6

M(n)
существует
n2

и равен 2 . Предполагая (не обосновывая и не вникая в то, можπ
но ли это обосновать; это соответствует «физическому уровню строгости»), что множество N+ может быть превращено в вероятностное пространство так, что случайное x ∈ N+ кратно фиксированно1
му d ∈ N+ с вероятностью , можно предложить несколько довольно
d

6

простых доказательств равенства P = 2 . Для этого можно воспольπ
зоваться тем, что
∞
X
1
π2
=
2
n =1

n

6

(доказано Эйлером в  г.) или свойством дзета-функции Римана,
согласно которому
∞
X
Y
1
1
s =
s
n =1

n

p — простое

1− p

и которое справедливо, например, для всех целых s > 1, и, в частности, для s = 2.
6
В упомянутых выше предположениях доказать равенство P = 2 ,
π
используя следующие подходы.
а) Для произвольного d ∈ N+ вычислить вероятность ϕ (d) того,
что для случайных x, y ∈ N+ выполнено d = íîä(x, y). Из равенства
∞
P
P =1−
ϕ (d) определить P. 
d =2

б) Для произвольного простого p вычислить вероятность ψ(p) то+
го, что по крайней мере
Q одно из случайных x, y ∈ N не делится на p.
Из равенства P =
ψ(p) определить P.
p — простое

Указания. а) ϕ (d) =

1
P
; б) ψ(p) = 1 − 2 .
d2
p

Для того чтобы сделать доказательство «настоящим», надо для произвольного n ∈ N+ детально рассмотреть ситуацию 1 ¶ x, y ¶ n и перейти к пределу
при n → ∞, что потребует более кропотливой работы. 





См. [, разд. ..].
См. [, гл. I, разд. , прим. .].
См. [, разд. .., упр. ].

Глава 

Оценивание числа шагов (итераций)
алгоритма

§ . Функции, убывающие по ходу выполнения алгоритма
Часто выполнение алгоритма является последовательностью однотипных шагов (итераций). Если все шаги равнозатратны по времени, то
общее их число с точностью до постоянного множителя эквивалентно
временным затратам рассматриваемого алгоритма для данного входа, и важной задачей является определение или хотя бы оценивание
числа этих шагов.
Пример .. Пусть a0 , a1 — натуральные числа, a0 ¾ a1 . Поиск наибольшего общего делителя (íîä) чисел a0 , a1 по алгоритму Евклида
требует выполнения серии однотипных шагов, каждый из которых —
деление с остатком:
a0 = q1 a1 + a2 ,
a1 = q2 a2 + a3 ,
...................
a n −3 = q n −2 a n −2 + a n −1 ,
a n −2 = q n −1 a n −1 + a n ,

(.)

a n −1 = q n a n .

В этом случае an = íîä(a0 , a1 ), так как
íîä(a0 , a1 ) = íîä(a1 , a2 ) = ... = íîä(an , 0) = an .
Последовательность получаемых остатков убывает (остаток меньше
делителя), при этом все остатки — неотрицательные целые. Не существует убывающей бесконечной последовательности, элементами
которой являются неотрицательные целые числа, поэтому выполнение алгоритма Евклида (будем обозначать его буквой E) завершается
для любых натуральных a0 , a1 , и число делений с остатком не пре-

§ . Функции, убывающие по ходу выполнения алгоритма



восходит a1 . Обозначив через CE (a0 , a1 ) исследуемое число делений
с остатком, получаем
CE (a0 , a1 ) ¶ a1
(.)
(для упрощения записи мы пишем CE (a0 , a1 ) вместо CET (a0 , a1 )). Это
говорит о том, что если a1 рассматривается как размер входа или если a0 , a1 рассматриваются как два параметра размера входа, то сложность алгоритма Евклида по числу делений не превосходит a1 . Как
мы увидим, эта оценка является весьма грубой, но, привлекая сходные рассуждения, можно получать и более тонкие оценки.
Формализуем те соображения, которые привели нас к этой первой
оценке. Каждый шаг алгоритма имеет дело с парой неотрицательных целых (ai−1 , ai ) и при условии ai 6= 0 перерабатывает эту пару
в (ai , ai+1 ), где ai+1 равно остатку от деления ai−1 на ai . На множестве пар неотрицательных целых чисел k, l мы определяем функцию
L(k, l), принимающую неотрицательные целые значения. Эта функция такова, что когда при выполнении алгоритма Евклида мы переходим от пары (ai−1 , ai ) к паре (ai , ai+1 ), значения функции убывают: L(ai−1 , ai ) > L(ai , ai+1 ). Так как функция целочисленна, то ее значение убывает с каждым шагом по крайней мере на единицу. Отсюда следует, что общее число шагов не превзойдет значения функции L на исходной паре чисел. Мы рассмотрели функцию L(k, l) = l,
и это привело нас к выводу, что число шагов не превзойдет значения
L(a0 , a1 ) = a1 .
Для обоснования того, что число делений в алгоритме Евклида
растет медленнее, чем a1 , было бы достаточно найти соответствующую функцию L(k, l), значения которой при больших k, l оказываются существенно меньшими, чем l. Эта функция по-прежнему должна
быть определена для любых неотрицательных целых k, l, k ¾ l, принимать неотрицательные целые значения и убывать при замене пары
k, l парой l, r, где r — остаток от деления k на l. Хотя бы одна пара целых неотрицательных k, l, k ¾ l, должна обращать L(k, l) в нуль,
иначе вместо L(k, l) можно взять функцию L′ (k, l) = L(k, l) − 1 и т. д.
Предложение .. Пусть k, l ∈ N+ , k > l, и пусть r — остаток от
деления k на l. Тогда
(i) λ(k) > λ(r), где, как обычно, λ(·) — битовая длина данного
числа;
(ii) функция
L(k, l) = λ(k) + λ(l) − 2
(.)
такова, что L(k, l) > L(l, r).



Глава . Оценивание числа шагов (итераций) алгоритма

Доказательство. (i) Имеем k = ql + r, q ¾ 1, откуда k ¾ l + r > 2r.
Следовательно, λ(k) > λ(r).
(ii) Из λ(k) > λ(r) следует λ(k) + λ(l) − 2 > λ(l) + λ(r) − 2.
Очевидно, что функция (.) неотрицательна. Таким образом,
справедлива оценка
CE (a0 , a1 ) ¶ λ(a0 ) + λ(a1 ) − 2.

(.)

Но если a0 очень велико в сравнении с a1 , то λ(a0 ) + λ(a1 ) − 2 > a1 .
Тем не менее, теперь для CE (a0 , a1 ) уже легко выводится хорошая
оценка. Пусть число делений с остатком больше 1. Имеем
CE (a0 , a1 ) = CE (a1 , a2 ) + 1 ¶ λ(a1 ) + λ(a2 ) − 1 ¶ 2λ(a1 ) − 1.
Оценка
CE (a0 , a1 ) ¶ 2λ(a1 ) − 1,

(.)

очевидно, верна и в случае единственного деления: CE (a0 , a1 ) = 1 при
том, что λ(a1 ) ¾ 1.
Если взять a1 за размер входа (a0 , a1 ), то для сложности по числу
делений будем иметь
TE (a1 ) = max CE (a0 , a1 ) ¶ 2λ(a1 ) − 1 = 2⌊log2 a1 ⌋ + 2 − 1 ¶ 2 log2 a1 + 1.
a0 ¾ a1

Доказанное нами можно переформулировать так:
Если рассматривать a1 как размер входа a0 , a1 алгоритма Евклида, то для сложности TE (a1 ) по числу делений выполнено неравенство
TE (a1 ) ¶ 2 log2 a1 + 1.

(.)

Эта же оценка имеет место и при рассмотрении двух параметров
a0 , a1 размера входа.
Для достаточно больших a1 верхняя оценка (.) существенно лучше, чем TE (a1 ) ¶ a1 . (Несколько более точная, чем (.), оценка дается
в задаче .)
Рассматривая далее оценки сложности по числу делений алгоритма Евклида, мы будем использовать значение a1 в качестве размера
входа (значение a0 может быть очень большим в сравнении с a1 , но
первое же деление с остатком приведет к a1 , a2 , где a2 < a1 ).
Известно, что алгоритм Евклида допускает разнообразные обобщения и расширения. Прежде всего, вместе с íîä(a0 , a1 ) можно находить целые s, t такие, что
sa0 + ta1 = íîä(a0 , a1 ).

(.)

§ . Функции, убывающие по ходу выполнения алгоритма



Чтобы это показать, обратимся к (.). Пусть уже известны a0 , a1 , ...
..., ai , 1 ¶ i ¶ n − 1, и пусть для них найдены множители s0 , t0 ; s1 , t1 ; ...
...; si , ti такие, что
s0 a0 + t0 a1 = a0 , s1 a0 + t1 a1 = a1 , ..., si−1 a0 + ti−1 a1 = ai−1 , si a0 + ti a1 = ai .
После выполнения очередного деления с остатком ai−1 = qi ai + ai+1
имеем ai+1 = ai−1 − qi ai и
(si−1 − qi si )a0 + (ti−1 − qi ti )a1 = ai+1 .
Можем положить
s i +1 = s i −1 − q i s i ,

t i +1 = t i −1 − q i t i ,

i = 1, ..., n − 1;

(.)

при этом
s0 = 1,

t0 = 0;

s1 = 0,

t1 = 1.

(.)

Решение поставленной задачи дают числа
s = sn ,

t = tn .

В процессе применения этого алгоритма к числам a0 = 39, a1 = 15
возникают остатки 9, 6, 3, 0 и соответствующие ненулевым остаткам
пары множителей суть 1, −2; −1, 3; 2, −5. Имеем 2 · 39 + (−5) · 15 = 3 =
= íîä(39, 15).
Этот алгоритм мы назовем расширенным алгоритмом Евклида
и будем его обозначать буквами EE, от его английского названия
extended Euclidean — расширенный евклидов. Каждый шаг расширенного алгоритма Евклида содержит три мультипликативных операции — одно деление с остатком и два умножения.
Если рассматривать a1 как размер входа a0 , a1 расширенного алгоритма Евклида, то для мультипликативной сложности TEE (a1 ) этого
алгоритма имеем TEE (a1 ) ¶ 6 log2 a1 + 3.
Расширенный алгоритм Евклида дает возможность решать в целых числах линейные уравнения с целыми коэффициентами (см. задачу ), он также играет существенную роль в модулярной арифметике (см. § ).
Если дополнить расширенный алгоритм Евклида еще одним шагом, то получатся sn+1 , tn+1 такие, что
sn+1 a0 + tn+1 a1 = 0.

(.)

Например, для a0 = 39, a1 = 15 имеем s5 = −5, t5 = 13. Легко доказать,
что
| s1 | ¶ | s2 | ¶ | s3 |, | t1 | ¶ | t2 | < | t3 |,
(.)



Глава . Оценивание числа шагов (итераций) алгоритма

и при n > 2
| s3 | < | s4 | < ... < | sn+1 |,

| t3 | < | t4 | < ... < | tn+1 |.

(.)

Несколько труднее, но также возможно доказать, что | si | и | ti | взаимно просты при i = 1, 2, ..., n + 1 (см. задачу ). Из (.) и взаимной
простоты sn+1 и tn+1 следует
| s n +1 | =

a1
,
íîä(a0 , a1 )

| t n +1 | =

a0
.
íîä(a0 , a1 )

Вместе с (.), (.) это дает нам
| s n | ¶ a1 ,

| t n | < a0 .

(.)

Эти неравенства пригодятся нам в дальнейшем.
Пример .. Бинарный поиск места (т. е. значения p, 1 ¶ p ¶
¶ n + 1, — как объяснено в приложении A) элемента y в упорядоченном массиве из n элементов x1 < x2 < ... < xn :
p := 1; q := n + 1;
while pj < q do
k
p+q
; if xr < y then p := r + 1 else q := r fi
r :=
2
od
Обозначим этот алгоритм буквами BS от его английского названия
binary search — бинарный поиск. Будем считать число элементов сегмента массива длиной этого сегмента (при рассмотрении задач сортировки и поиска мы называем сегментом массива любую упорядоченную часть x s < x s+1 < ... < xt −1 < xt данного массива). Легкоj видеть,
k
k

что от сегмента длины k мы переходим к сегменту длины
или
2
j k
k
− 1. Это говорит о том, что с каждым шагом алгоритма функция
2
L(k) = λ(k), где положительное k является длиной сегмента, рассматриваемого на данном шаге, убывает по крайней мере на единицу,
пока не приходим к сегменту, содержащему один элемент, после чего еще одно сравнение полностью решает задачу. Отсюда сложность
бинарного поиска не превосходит λ(n) = ⌊log2 n⌋ + 1. Мы видим также, что если y меньше минимального элемента рассматриваемого
сегмента
j kдлины k > 1, то длина сегмента на следующем шаге будет
k

равна
. Поэтому если изначально y < x1 , то в ходе бинарного по2
иска будут рассматриваться сегменты длины
jnk
j k
n
2
n,
,
, ..., 1
2

2

§ . Функции, убывающие по ходу выполнения алгоритма



соответственно (битовая длина каждого следующего элемента последовательности на единицу меньше битовой длины предыдущего), и
в целом потребуется в точности λ(n) = ⌊log2 n⌋ + 1 сравнений. Используя утверждение, содержащееся в задаче , мы можем сформулировать установленное свойство бинарного поиска так:
Сложность TBS (n) бинарного поиска места элемента в массиве длины n по числу сравнений равна ⌊log2 n⌋ + 1, или, что то же самое,
⌈log2 (n + 1)⌉.
Выражение ⌈log2 (n + 1)⌉ для указанной сложности иногда бывает
удобнее, чем ⌊log2 n⌋ + 1, потому что оно имеет смысл и в вырожденном случае n = 0.
Бинарный поиск находит широчайшее применение при поиске информации в разнообразных таблицах. Укажем здесь еще одно его
применение, касающееся вычислительной геометрии: он позволяет
быстро определять, принадлежит ли произвольная точка Q выпуклому n-угольнику, заданному вершинами P1 , P2 , ... Pn . Можно легко
построить какую-нибудь внутреннюю точку O данного n-угольника.
В силу его выпуклости точка Q — внутренняя, если и только если
Q и O лежат в одной полуплоскости относительно любой из прямых
P1 P2 , ..., Pn−1 Pn , Pn P1 . Это соображение приводит к имеющему временную сложность Θ(n) алгоритму. Но допустим, что проведены n добавочных лучей (рис. ), исходящих из точки O и проходящих через
P5

...

P4

Q

O
P3

P1

P2

Рис. . Точка Q лежит между двумя лучами, проведенными из внутренней
точки O многоугольника через его вершины.

вершины (считаем, что O 6= Q, иначе мы сразу бы заключили, что
Q принадлежит многоугольнику). Можно установить, какому из углов
∠ P1 OP2 , ..., ∠ Pn−1 OPn , ∠ Pn OP1 принадлежит точка Q: если углы прону-



Глава . Оценивание числа шагов (итераций) алгоритма

мерованы в указанном порядке, то бинарным поиском определяется
номер m угла, 1 ¶ m ¶ n; при этом если Q лежит на одном из проведенных лучей, то из двух значений m берется любое. Узнав m, мы
проверяем согласованность расположения точек O и Q по отношению
к прямой, являющейся продолжением той стороны многоугольника,
концы которой лежат на сторонах m-го угла.
Теперь заметим, что в самом проведении лучей OP1 , OP2 , ..., OPn
нет необходимости: сравнение ∠ P1 OQ с ∠ P1 OPi требует ограниченного числа операций и в том случае, когда нам лишь известны координаты точек O, Q, P1 , Pi .
Основывающийся на бинарном поиске алгоритм распознавания
принадлежности точки выпуклому n-угольнику имеет сложность
O(log n) по общему числу операций и пространственную сложность
O(1).
Полезным для решения ряда задач является то обстоятельство, что
если точка не принадлежит данному выпуклому n-угольнику, то с помощью этого алгоритма мы дополнительно определяем одну из сторон n-угольника, которая из этой точки видна целиком (рис. ).

...

Q
O

Рис. . Для точки Q , не принадлежащей данному выпуклому n-угольнику,
находим сторону n-угольника, которая из Q видна целиком.

Пример .. Установим число этапов слияния при сортировке,
предложенной Дж. фон Нейманом (которая является одним из вариантов сортировки слияниями). При сортировке фон Неймана шаг за
шагом происходят переброски элементов исходного массива в дополнительный массив и наоборот, и каждая переброска сопровождается слиянием соседних сегментов массива (рис. ). В данном случае в качестве вспомогательного размера массива удобно рассмотреть k — число сегментов (первоначально k = n, затем, шаг за шагом, k довольно быстро убывает). При анализе бинарного поиска
места элемента мы фактически использовали, что если 2m−1 ¶ k < 2m ,

§ . Функции, убывающие по ходу выполнения алгоритма
а)

б)


в)

Рис. . Три последовательных шага сортировки фон Неймана, удлиняющих
упорядоченные участки (сегменты): а) переход от семи сегментов к четырем; б) переход от четырех сегментов к двум; в) переход от двух сегментов
к одному (массив полностью упорядочен).

то при k > 1 на следующем шаге мы будем иметь дело с k ′ таким,
что k ′ < 2m−1 . В случае же сортировки фон Неймана ситуация такова,
что если на каком-то шаге имеем k > 1 уже построенных сегментов
и 2m−1 < k ¶ 2m (это соответствует тому, что ⌈log2 k ⌉ = m), то на следующем шаге сегментов будет k ′ < k и 2m−2 < k ′ ¶ 2m−1 (это соответствует тому, что ⌈log2 k ′ ⌉ = m − 1). Поэтому функция L(k) = ⌈log2 k ⌉,
где k — текущее число построенных сегментов, убывает с каждым
шагом ровно на единицу. Таким образом, число этапов слияния, или
число перебросок сортируемых элементов из массива в массив, равно
⌈log2 n⌉. Это позволяет утверждать следующее:
Сложность сортировки фон Неймана по числу сравнений меньше,
чем n⌈log2 n⌉; сложность по числу присваиваний равна n⌈log2 n⌉.
В самом деле, каждый этап слияния, сопровождаемый переброской элементов из массива в массив, требует n присваиваний. Число
сравнений при каждом слиянии по крайней мере на единицу меньше, чем длина получаемого упорядоченного сегмента: известно, что
число тех сравнений, которые априори могут потребоваться для слияния двух упорядоченных массивов, содержащих соответственно k и m
элементов, k ¶ m, лежит в диапазоне от k до k + m − 1 (обе указанные
границы достижимы).
Вновь обращаясь к примеру ., мы видим, что, основываясь на
сортировке фон Неймана, можно получить алгоритм построения выпуклой оболочки данных n точек координатной плоскости, имеющий
сложность O(n log n) в худшем случае по общему числу операций.
Некоторое различие между примером . и примерами ., . состоит в том, что в примере . мы определяли L как функцию самого
входа алгоритма и из полученной оценки для затрат выводили оценку для сложности (переходили от входа как такового к его размеру),
а в ., . мы изначально рассматривали L как функцию размера.



Глава . Оценивание числа шагов (итераций) алгоритма

В этих двух последних примерах значения функции L возникали из
сравнений размера n с элементами некоторой последовательности sk ,
k = 0, 1, ... (в обоих случаях было sk = 2k ). В примере . удобно было считать, что L(n) = k, если sk−1 ¶ n < sk , а в примере . — если
s k −1 < n ¶ s k .
Типичный итерационный алгоритм содержит цикл, в котором набор v начальных величин преобразуется в набор v ′ , затем v ′ преобразуется в v ′′ и т. д. Функция L, которую мы подбираем, должна принимать неотрицательные значения и быть определенной либо на самих
наборах величин, либо на их размерах; в обоих случаях функция должна убывать по ходу выполнения алгоритма:
L(v) > L(v ′ ) > L(v ′′ ) > ...
в первом случае, или
L(kv k) > L(kv ′ k) > L(kv ′′ k) > ...
во втором. Значение L(v) или соответственно L(kv k) дает верхнюю
границу для числа шагов цикла. 
Заметим попутно, что, исходя из установленной в примере .
сложности бинарного поиска, мы сразу можем получить верхнюю
оценку
TB (n) ¶ (n − 1)⌈log2 n⌉
(.)
для сложности по числу сравнений сортировки бинарными вставками; мы используем для обозначения этой сортировки букву B, от
английского слова binary — бинарный. По числу перемещений сложность этой сортировки квадратична, здесь эта сортировка уступает
сортировке фон Неймана. Пространственную сложность сортировки
бинарными вставками можно считать равной нулю (все делается на
том же месте), а для сортировки фон Неймана эта сложность есть n.
Пример .. Число итераций численных алгоритмов тоже часто
оценивают сравнением размеров данных, соответствующих текущим
итерациям, с элементами последовательности, которая может иметь,
n
например, вид q n или q 2 (q < 1), n = 0, 1, ..., и т. д. Этим способом

Такую функцию можно назвать функцией Ляпунова цикла, подразумевая аналогию
с функцией, убывающей вдоль решения обыкновенного дифференциального уравнения
(аналогия принадлежит С. С. Лаврову, см. [, разд. ..]). Это не единственная аналогия между дифференциальными уравнениями и циклическими алгоритмами и программами. Например, понятие первого интеграла, или закона сохранения, сопоставимо с понятием инварианта цикла и т. д.

§ . Качество оценок



получаются оценки числа итераций для классических методов (алгоритмов) приближенного решения уравнений. Вспомним две такие
оценки.
Пусть корень уравнения f (x) = 0 разыскивается на отрезке [a, b],
на котором функция f (x) непрерывна, f (a) f (b) ¶ 0. Ошибка не должна превышать данного ǫ > 0. При ǫ → 0 и фиксированных f (x), a, b
число итераций метода делений пополам есть
log2

1
+ O(1).
ǫ

(.)

Метод же Ньютона (касательных) требует


1
O log log

(.)

ǫ

итераций при соблюдении ограничений на функцию f (x), обеспечивающих сходимость метода.
§ . Качество оценок
После вывода оценки сложности алгоритма часто возникает вопрос
о том, насколько эта оценка хороша и нельзя ли входящие в оценку константы и функции заменить другими так, чтобы оценка стала
более точной, и, как следствие, несущей больше информации об исследуемом алгоритме.
Пример .. В примере . для сложности TE (a1 ) по числу делений алгоритма Евклида мы легко получили верхнюю оценку a1 , а затем, после некоторых усилий, пришли к логарифмической верхней
оценке (.). Отвлекаясь от значений констант, перейдем от (.) к
TE (a1 ) = O(log a1 ).

(.)

Нами пока не доказано, что оценка (.) pявляется точной, и, как
следствие, что не верна, скажем, оценка O( log a1 ) или O(log log a1 )
и т. д. Чтобы доказать точность (.), достаточно подобрать для алгоритма Евклида последовательность входов
(1)
(2)
(2)
(a(1)
0 , a1 ), (a0 , a1 ),

a(n)
1

...

таких, что последовательность
(последовательность размеров вхо(n)
(n)
да) неограниченно возрастает и CE (a(n)
0 , a1 ) = Ω(log a1 ) при n → ∞;
(n)
(n)
тогда, очевидно, будем иметь TE (a1 ) = Ω(log a1 ).
Фактически, нам нужна последовательность таких входов возрастающего размера, для каждого из которых алгоритм Евклида работает медленно. Подойдет, например, последовательность входов



Глава . Оценивание числа шагов (итераций) алгоритма

(Fn+1 , Fn ), n = 0, 1, ..., где F0 , F1 , F2 , ... — числа Фибоначчи, определяемые равенствами F0 = 0, F1 = 1 и правилом «каждое следующее число равно сумме двух предыдущих», т. е. рекуррентным соотношением
Fn+2 = Fn+1 + Fn . Из определения чисел Фибоначчи следует, что применение алгоритма Евклида к Fn+1 , Fn при n ¾ 1 требует n делений
(все частные будут равны единице), поэтому CE (Fn+1 , Fn ) = n.
По индукции доказывается, что для всех неотрицательных n справедлива формула Бине:
1
5

Fn = p (φ n − (−φ )−n ),
где
φ=

(.)

p
1+ 5
= 1,61803...
2

(деление отрезка в отношении 1 : φ называют золотым сечением).
Так как φ > 1, то из (.) получаем
p
(.)
φ n = 5Fn (1 + o(1)),
и, поскольку logφ (1 + o(1)) = o(1), с помощью логарифмирования
(.) по основанию φ имеем
CE (Fn+1 , Fn ) = n = logφ Fn + O(1) = Ω(log Fn ),
откуда следует, что оценка (.) точная.
Мы докажем более сильное утверждение:
TE (a1 ) >

1
logφ a1 + γ,
4

(.)

где γ — некоторая константа. Это вместе с (.) даст
TE (a1 ) = Θ(log a1 ).

(.)

Приступая к доказательству, мы перейдем от функции CE (a0 , a1 ),
имеющей два аргумента, к функции одного аргумента. Каждому вхоa
ду (a0 , a1 ), a0 ¾ a1 > 0, мы сопоставим рациональное число r = 0 ¾ 1,
a1

которое однозначно определяет число шагов алгоритма Евклида для
a0 , a1 . (Пусть

a0
ã
= 0 , ã0 и ã1 взаимно просты, a0 = uã0 , a1 = uã1 ; тоa1
ã1

гда остатки a2 , a3 , ... и ã2 , ã3 , ..., возникающие в ходе применения алгоритма Евклида к a0 , a1 и соответственно к ã0 , ã1 , отличаются лишь
множителем u.) Будем обозначать это число шагов через CE′ (r). Таким
образом, если r =

a0
, то CE′ (r) = CE (a0 , a1 ).
a1

§ . Качество оценок



Для дальнейшего будет полезным следующее свойство чисел Фибоначчи:
Fn2 − Fn−1 Fn+1 = (−1)n , n = 1, 2, ...
(.)
(доказывается индукцией по n). Рассмотрим вложенные отрезки Φ1 ⊃
⊃ Φ2 ⊃ Φ3 ⊃ ... числовой прямой:
i
h F
F
2n
, 2n+1 , n = 1, 2, ...
Φn =
F2n−1

F2n

Соотношение (.) позволяет установить, что ни один из этих
1
. Очевидно, что
отрезков не пуст и что длина отрезка Φn равна
F2n−1 F2n

Φ1 = [1, 2] (рис. ). Далее можно доказать, что если рациональное
z
z
z

1
F2
F1

F4
F3

F6
F5

Рис. . Расположение чисел

Φ1
}|
Φ2
}|
Φ3
}|
...

...

φ ...

{
{
{

2
F7
F6

F5
F4

F3
F2

Fn+1
и интервалов Φn , n = 1, 2, ...
Fn

a0
принадлежит Φn , n > 2, то деление a0 на a1 дает ненулевой
a1
a
остаток a2 , и 1 принадлежит Φn−1 . В самом деле, мы имеем
a2

число

1<

F2n+1
a
F2n
¶ 0¶
< 2.
F2n−1
a1
F2n

Следовательно, частное от деления a0 на a1 с остатком равно 1, т. е.
a2 = a0 − a1 . Далее,
a0 − a1
a
= 0 − 1,
a1
a1

поэтому
F2n+2
F2n
a
−1¶ 2 ¶
− 1.
F2n−1
a1
F2n

Но

F − F2n−1
F
F2n
− 1 = 2n
= 2n− 2 ,
F2n−1
F2n−1
F2n−1



Глава . Оценивание числа шагов (итераций) алгоритма
F2n+1
F
F
a
− 1 = 2n−1 ; мы имеем, следовательно, 2n−2 ¶ 2 ¶
F2n
F2n
F2n−1
a1

и, аналогично,
¶

F2n−1
и
F2n

F
F2n
a
¶ 1 ¶ 2n− 1 .
F2n−1
a2
F2n−2

Получаем
a1
∈
a2

h F
2n
F2n−1

,

(.)

F2n−1 i h F2n−2 F2n−1 i
⊂
,
= Φ n −1 .
F2n−2
F2n−3 F2n−2

Отрезки Φ2 , Φ3 , ... не содержат целых чисел, поэтому из доказанного
можно заключить, что если r ∈ Φn ∩ Q, n > 2, то CE′ (r) ¾ n.
Пусть теперь фиксировано a1 ∈ N+ . Рассмотрим множество
n
o
a
M = r : r = 0 , a0 = a1 , a1 + 1, ... .
a1

Точки, соответствующие элементам множества M, расположены на
1
правой полуоси, начиная с , с шагом ; хотя бы одна из этих точек
a1

непременно принадлежит отрезку Φn , коль скоро
отрезка Φn , т. е.

1
меньше длины
a1

1
1
¶
, или, что то же самое, a1 ¾ F2n−1 F2n . Пусть
a1
F2n−1 F2n

N — самое большое значение n, для которого выполняется это неравенство (такое N существует, так как единственной точкой, принадлежащей бесконечному числу отрезков рассматриваемого семейства,
является φ ∈
/ Q). Тогда F2N F2N +1 > a1 . Из формулы Бине следует, что
1
5

F2N F2N +1 = φ 4N (1 − (−φ )−4N )(φ − (−φ )−4N −1 ),
откуда
F2N F2N +1 < cφ 4N ,
где c — некоторая положительная константа. Таким образом, cφ 4N >
> a1 и
N>
1

1
logφ a1 − logφ c.
4

Имеем CE′ (r) ¾ N − 1 > logφ a1 − logφ c − 1 по крайней мере для од4
ного рационального числа r ∈ M, откуда следует соотношение (.).
Переходя к размеру входа m = λ(a1 ), мы можем воспользоваться теоремой . из §  и получить для сложности TE∗ (m) по числу

§ . Качество оценок



делений соотношение TE∗ (m) = Θ(m). (В силу теоремы . TE∗ (m) =
= Ω(log 2m−1 ) = Ω(m) и TE∗ (m) = O(log 2m ) = O(m).)
Число шагов расширенного алгоритма Евклида (см. пример .)
совпадает с числом шагов обычного алгоритма Евклида. Мы получаем следующее:
Если рассматривать a1 как размер входа (a0 , a1 ) расширенного
алгоритма Евклида, то для мультипликативной сложности TEE (a1 )
этого алгоритма выполнено TEE (a1 ) = Θ(log a1 ). При рассмотрении
m = λ(a1 ) в качестве размера входа a0 , a1 расширенного алгоритма
∗
Евклида имеем для мультипликативной сложности оценку TEE
(m) =
= Θ(m). Все это сохраняет силу и для сложности TE∗ (m) «обычного»
алгоритма Евклида.
Запись алгоритма Евклида в форме (.) далека от записи в виде
«приличной» компьютерной программы не только в смысле использованной символики, но, главное, в смысле предписываемого расточительного расхода памяти (использован массив, и при буквальном
следовании алгоритму (.) мы бы имели SE (a1 ) = Θ(log a1 )). С точки зрения программирования более приемлемой будет, например,
запись
a := a 0 ; b := a 1 ;
while b > 0 do
d := rem(a, b); a := b; b := d

od
(rem — знак операции нахождения остатка). После выполнения алгоритма имеем a = íîä(a0 , a1 ). Использовано только три дополнительных переменных (a, b и d), и мы получаем SE (a1 ) = 3.
Оценку (.) можно усилить, показав, что найдется константа γ′
такая, что
1
(.)
TE (a1 ) > logφ a1 + γ′
2

(см. задачу ). Часто в литературе оценки снизу для сложности в худшем случае алгоритма Евклида по числу делений выводят из оценки,
полученной в  г. Г. Хейлбронном для сложности в среднем:
¯T¯E (a1 ) = 12 ln 2 ln a1 + O(1).
2
π

(.)

Последняя оценка обосновывается весьма непросто. Из (.) выводится, что
TE (a1 ) >

12 ln 2
ln a1 + γ′′
π2



Глава . Оценивание числа шагов (итераций) алгоритма

для некоторой константы γ′′ . Однако при больших a1 оценка (.)
для TE (a1 ) является более строгой (

1
12 ln 2
ln φ = 0,40554... < ) и вдо2
π2

бавок выводится элементарно  .
Может быть доказано (см. задачу ), что TE (a1 ) < logφ a1 + c, где
c — некоторая константа (заметим, что logφ 2 = 1,44... < 2)  .
Рассуждения, сходные с приведенными при доказательстве неравенства (.), показывают, что для каждого a0 можно подобрать a1 ,
a0 ¾ a1 , так, что будет выполняться
CE (a0 , a1 ) >

1
logφ a0 + β ,
4

(.)

где β — некоторая константа. В данном случае можно рассмотреть
вложенные отрезки Ψ1 ⊃ Ψ2 ⊃ Ψ3 ⊃ ...:
i
h F
F
2n
, 2n−1 , n = 1, 2, ...
Ψn =
F2n+1

F2n

(при n > 1 отрезок Ψn не содержит чисел вида
делится нацело на a1 и
этим в § .

1
, m ∈ N+ ); если a0 не
m

a1
a
∈ Ψn , то 2 ∈ Ψn−1 и т. д. Мы воспользуемся
a0
a1

Пример .. Сортировка массива длины n бинарными вставками выполняется за n − 1 шаг, причем на l-м шаге число сравнений не
превосходит ⌈log2 (l + 1)⌉ и, следовательно, не превосходит ⌈log2 n⌉ на
любом из шагов, — это приводит к оценке (.). Возникает вопрос,
не сможем ли мы получить существенно лучшей оценки сверху, расnP
−1
смотрев сумму
⌈log2 (l + 1)⌉, которая совпадает со значением TB (n),
l =0

т. е. сложности по числу сравнений (такое число сравнений достигается, например, в случае, когда изначально массив имеет обратную
упорядоченность: x1 > x2 > ... > xn ). Замена переменной суммирования дает
n
X
TB (n) =
⌈log2 k ⌉.
(.)
k =1


Приведенный выше и дополненный в указании к задаче  элементарный вывод
оценки (.) принадлежит М. Оналбекову; в [, разд. .., упр. ] со ссылкой на
статью Я. Микусинского ( г.) приведена оценка, фактически совпадающая с (.),
но ее вывод опирается на теорию цепных дробей и не столь элементарен и нагляден.

Предположение о том, что TE (a1 ) ∼ logφ a1 , насколько известно автору, не доказано
и не опровергнуто ( г.).

§ . Завершимость работы алгоритма



Для получения простой асимптотической
оценки TB (n) воспользуемся
p
формулой Стирлинга n! ∼ nn e−n 2πn, или, что то же самое,
p
n! = nn e−n 2πn(1 + o(1)),
которая после логарифмирования принимает вид
log2 n! = n log2 n − n log2 e +

1
1
1
log2 n + log2 π + + o(1)
2
2
2

(принято во внимание, что log2 (1 + o(1)) = o(1)). Так как 1 < log2 e <
< 2, то
n log2 n − 2n < log2 n! < n log2 n − n
(.)
для всех достаточно больших n; в частности, это означает, что
log2 n! = n log2 n + O(n).
Имеем
n
X
k =1

⌈log2 k ⌉ =

n
X

log2 k + O(n) = log2 n! + O(n) = n log2 n + O(n).

k =1

Отсюда получаем оценку
TB (n) = n log2 n + O(n),

(.)

из которой следует, в частности, что TB (n) ∼ n log2 n.
Таким образом, тщательный анализ суммы (.) не приводит к существенно лучшей, чем (.), оценке, но зато дает асимптотику TB (n).
В §  будет показано, что из того, что сложность по числу сравнений некоторой сортировки не превосходит n log2 n + cn, где c — некоторая константа, следует, что эта сложность есть n log2 n + O(n). Из
этого будет следовать, что для сложности по числу сравнений сортировки фон Неймана выполнено TvN (n) = n log2 n + O(n); мы обозначаем эту сортировку буквами vN, от фамилии von Neumann.
§ . Завершимость работы алгоритма
Если выполнение циклического (итерационного) алгоритма не завершается для некоторого входа v, то сложность этого алгоритма не
определена для значения аргумента, равного kv k. Поэтому анализ
сложности алгоритма прямо или косвенно включает исследование завершимости.
Установление завершимости может быть рассмотрено и как самостоятельная задача. Когда функция L подбирается для выяснения
зависимости числа шагов алгоритма от размера входа задачи, то при



Глава . Оценивание числа шагов (итераций) алгоритма

наличии выбора более предпочтительной является функция с медленным ростом (имеется в виду рост при увеличении размера входа);
даже если при этом усложняется доказательство того, что L обладает
всеми нужными свойствами, мы зато получаем более точную оценку
числа шагов алгоритма. Но иногда речь может идти только о доказательстве завершимости работы алгоритма — тогда характер роста
функции L отходит на второй план. То, что выполнение алгоритма Евклида завершается, было доказано в самом начале обсуждения этого
алгоритма без обращения к функциям с логарифмическим ростом.
Пример .. Алгоритм, заданный оператором цикла

while n > 3 do
if 2 | n then n := n2 + 1 else n := n + 1 fi
od
(запись 2 | n означает, что n делится на 2) завершает свою работу
для любого натурального n. Для доказательства достаточно рассмотреть функцию n − (−1)n и убедиться в ее убывании при n > 3 в ходе
выполнения алгоритма.
Пример .. Если n — данное неотрицательное целое число, то
завершимость выполнения алгоритма
s := 0;
for i = 1 to n do s := s + 1i od
очевидна — выполнение оператора цикла завершится после n шагов;
легко видеть, что при выполнении этого оператора значение L(n, i) =
= n − i убывает, оставаясь при этом неотрицательным целым.
В доказательствах завершимости, основанных на подборе подходящей убывающей целочисленной функции, используется следующее
свойство множества N неотрицательных целых чисел:
Не существует бесконечной убывающей последовательности n0 >
> n1 > n2 > ... элементов множества N.
Имеются и другие примеры (частично) упорядоченных множеств
с этим свойством, и соответствующие порядки используются для доказательства завершимости выполнения алгоритмов  .

Вместо сложных примеров, мы адресуем читателя к задачам , , заимствованным из [, разд. .]. В книге [] кроме двух названных задач содержится интересный
и полезный материал о частично упорядоченных множествах и некоторых специальных типах таких множеств. (Решения задач ,  не обязательно должны содержать
явные упоминания порядков на множествах, хотя введение некоторых порядков полностью проясняет ситуацию.)

§ . Завершимость работы алгоритма



Установление завершимости выполнения алгоритма иногда оказывается очень трудной задачей.
Пример .. Завершимость для любого натурального n выполнения алгоритма

while n > 1 do
if 2 | n then n := n2 else n := 3n + 1 fi
od
не доказана и не опровергнута по сей день, хотя на это направлялись
серьезные усилия (см. []).
В случае рандомизированных алгоритмов мы сталкиваемся
(см. ниже пример . и первую часть примера .) с возможностью
того, что алгоритм завершается с вероятностью 1, но математическое
ожидание времени от начала выполнения до полного завершения
алгоритма бесконечно. Поэтому утверждения о завершимости возможны в двух формах: завершимость с вероятностью 1 и конечность
ожидаемого времени выполнения. Вторая форма является, вообще
говоря, более сильной.
Пример .. В теории вероятностей подробно рассматривается
задача о блуждании частицы по прямой: за один шаг частица передвигается на 1 вправо или на то же расстояние влево, направление же движения на каждом шаге выбирается случайно, вероятно1
сти выбора каждого из направлений одинаковы и равны . Пусть
2
в начальный момент частица находится в точке 0, и на прямой отмечена некоторая точка m с целой координатой. Доказывается, что
с вероятностью 1 частица через некоторое время попадает в точку m.
Попытаемся теперь вычислить математическое ожидание a времени
(общего числа шагов), которое потребуется для достижения точки m.
Легко убедиться, что уже в случае m = ±1 это среднее бесконечно.
Пусть, например, m = 1. Используем формулу полного математического ожидания: если шаг сделан вправо, то за этот один шаг мы
достигаем цели, если же шаг сделан влево, то придется дождаться
момента, когда частица вернется в точку 0 и тем самым повторится
начальная ситуация:
a=1·

1
1
+ 2a · .
2
2
1

Если бы a было конечным, это бы дало 0 = . Поэтому среднее бес2
конечно.



Глава . Оценивание числа шагов (итераций) алгоритма

Рассмотрим с этой точки зрения задачу . Итак, путник столкнулся со стеной, простирающейся бесконечно в обе стороны. Имеется
дверь в этой стене, но путник не знает ни расстояния до двери, ни
направления к ней. Если путник использует алгоритм поиска двери,
состоящий в бросании перед каждым шагом монеты для определения
направления (вправо или влево) этого шага, то он с вероятностью 1
найдет дверь, но математическое ожидание числа шагов равно бесконечности, коль скоро в начальный момент путник не стоит прямо
перед дверью. Иными словами, если pk (k ¾ 1) есть вероятность того,
что после k шагов путник впервые окажется перед дверью, то
∞
X
k =1

pk = 1 и

∞
X

kpk = ∞.

k =1

Пример .. Обратимся к системам автоматизированного обучения. При использовании известного педагогического приема — задания вопросов вразбивку — с каждым выбранным системой вопросом
может быть связана следующая цепочка действий: вопрос обучаемому; прием и проверка ответа; сообщение, правилен ли ответ и объявление правильного ответа, если был дан неправильный ответ. Нетрудно привести примеры учебных тем, когда такой подход выглядит разумно: таблица умножения, исторические даты, иностранные слова
(здесь же — неправильные глаголы), значения иероглифов, название
созвездий (показываются картинки), определение на слух музыкальных интервалов и т. д. Прообразом одного из алгоритмов выбора вопросов служит способ заучивания ответов с помощью колоды карточек, на лицевой стороне каждой из которых написан вопрос, а на
обороте — ответ. Из колоды выбирается наугад карточка, и делается попытка ответить на вопрос. Если это не удается, ответ прочитывается на обороте. Затем карточка возвращается в колоду, и все
повторяется. На примере колоды карточек предлагаемый рандомизированный алгоритм (называемый алгоритмом кратных карт  ) может
быть проинтерпретирован так: выбранная карточка, содержащая вопрос с известным обучаемому ответом, уже не возвращается в колоду; если же обучаемый не смог дать правильный ответ, то, кроме
того что в колоду возвращается эта карточка, туда добавляется еще
один ее экземпляр. Сеанс обучения заканчивается, когда в колоде не
остается карточек.
Пусть вопросы занумерованы числами 1, 2, ..., n. Каждый этап
сеанса обучения характеризуется кратностями m1 , m2 , ..., mn вопро

См. [].

§ . Завершимость работы алгоритма



сов (не исключается равенство нулю каких-то кратностей); пусть
m = m1 + m2 + ... + mn . Если m = 0, то сеанс заканчивается, иначе выбирается очередной вопрос; вероятность того, что будет выбран i-й
m
вопрос, должна равняться i .
m
Сеанс обучения становится бесконечным, если, например, с некоторого момента обучаемый начинает давать только неправильные ответы. Но можно интересоваться вероятностями и средним временем
ожидания некоторых событий в течение этого бесконечного сеанса.
Пусть в некоторый момент только один вопрос, скажем, вопрос с номером , имеет кратность 1, а все остальные — кратности большие,
чем 1. Предположим, что начиная с этого момента обучаемый стабильно дает неправильные ответы на предлагаемые вопросы. Найдем
вероятность того, что рано или поздно обучаемый получит вопрос
с номером , а также математическое ожидание времени, проходящего до появления этого вопроса (время измеряется количеством заданных вопросов). Пусть m — суммарная кратность, а n — общее число
вопросов, m > n ¾ 2. Вероятность получить вопрос с номером  после
1
i вопросов с другими номерами равна , если i = 0, и равна
m

m−1
m
m+i−2
1
m−1
·
...
·
=
,
m
m+1
m+i−1 m+i
(m + i − 1)(m + i)

если i ¾ 1. Поэтому вероятность получить рано или поздно вопрос
с номером  равна
1
+ (m − 1)
m

Так как

∞
X
i =1

1
.
(m + i − 1)(m + i)

(.)

1
1
1
=
−
,
(m + i − 1)(m + i)
m+i−1
m+i

то для частичной суммы
sN =

N
X
i =1

1
(m + i − 1)(m + i)

имеем
sN =
и lim s N =
n→∞

1
1
−
,
m
m+N

1
, откуда значение выражения (.) (искомая вероятm

ность) есть
1
m−1
+
= 1.
m
m



Глава . Оценивание числа шагов (итераций) алгоритма
Математическое ожидание времени есть
(m − 1)

∞
X
i =1

i
.
(m + i − 1)(m + i)

(.)

∞
P

i
расходится: члены этого ряда поло(m + i − 1)(m + i)
 
1
1
жительны, и i-й член есть Θ
(является величиной порядка ).
i
i

При этом ряд

i =1

Отсюда математическое ожидание (.) равно бесконечности.
Пусть теперь u вопросов (будем считать, что это вопросы с номерами 1, 2, ..., u) имеют кратность 1, а остальные n − u вопросов — кратность большую, чем 1, и пусть u ¾ 2. Оказывается, что при
стабильных неправильных ответах обучаемого на задаваемые вопросы математическое ожидание времени, проходящего до получения
всех, кроме какого-то одного, вопросов с номерами 1, 2, ..., u, есть
конечная величина. Докажем конечность среднего времени ожидания какого-нибудь одного вопроса с номером от 1 до u, далее можно
применить индукцию. Вероятность получить такого рода вопрос после i вопросов с номерами из диапазона от u + 1 до n полностью
определяется значениями u, m, i:
m−u+i−1
u
m−u m−u+1
·
...
·
.
m
m+1
m+i−1
m+i

Эта вероятность при i > u равна
u(m − u)(m − u + 1)...(m − 1)
.
(m − u + i)(m − u + i + 1)...(m + i − 1)(m + i)

Поэтому искомое математическое ожидание есть сумма некоторого
конечного числа слагаемых и ряда
∞
X
i = u +1

u(m − u)(m − u + 1)...(m − 1)
(i + 1),
(m − u + i)(m − u + i + 1)...(m + i − 1)(m + i)

или
u(m − u)(m − u + 1)...(m − 1)

∞
X
i = u +1

i+1
.
(m − u + i)(m − u + i + 1)...(m + i)

Упрощая, получаем
u(m − u)(m − u + 1)...(m − 1)

∞
X
j =1

j +u+1
.
( j + m)( j + m + 1)...( j + m + u)

§ . Вложенные циклы (дополнительные примеры)



Ряд,
в это выражение, сходится, так как j-й член ряда есть

 входящий
1
Θ u и u ¾ 2.
j

Это рассуждение сохраняет силу и в том случае, когда вопросы
с номерами 1, 2, ..., u являются одним и тем же вопросом, что позволяет отметить следующую характерную черту алгоритма кратных
карт:
Если изначально все вопросы имеют кратность 1 и обучаемый дает на все вопросы неправильные ответы, то математическое ожидание времени до наступления момента, к которому обучаемый получит хотя бы по одному разу каждый из вопросов, равно бесконечности, хотя вероятность наступления такого момента равна 1. Если
же изначально все вопросы имели большие единицы кратности (например, все они имели кратность 2), то обсуждаемое математическое ожидание конечно.
§ . Вложенные циклы (дополнительные примеры)
При анализе сложности вложенных циклов мы естественно приходим
к вычислению и оцениванию кратных сумм.
Пример .. Число обменов при транспонировании (n × n)-матрицы (aij )

for i = 1 to n − 1 do
for j = i + 1 to n do aij ↔ a ji od
od
есть

nP
−1

n
P

i =1 j = i +1

1=

nP
−1
i =1

(n − i) =

n2 − n
. Аналогично, распознавание сим2

метричности данной (n × n)-матрицы требует в худшем случае сравnP
−1
n
nP
−1 P
(n + 1)(n − 2)
(n − i + 1) =
1=
и т. д.
нений в количестве
i =1 j = i

i =1

2

Легкое получение ответов в примере . объясняется тем, что
в выписанных формальным путем суммах нижние границы суммирования не превосходили верхних; в таких случаях всегда, например,
q
P
1 = q − p + 1. Но, получая сумму этим формальным путем из опеj=p

ратора цикла, можно столкнуться с тем, что p > q (оператор цикла
затратит 0 шагов), и ответ q − p + 1 будет неправильным. Соответствующий пример дается в задаче .



Глава . Оценивание числа шагов (итераций) алгоритма

Подходя к асимптотическим оценкам, отметим один простой, но
полезный факт.
Предложение .. Пусть Λ — один из символов O, Θ, Ω. Пусть
a(k), b(k) определены для всех k ∈ N+ и принимают положительные
значения (не обязательно целые); пусть a(k) = Λ(b(k)), k → ∞. Тогда
P

n
n
P
a(k) = Λ
b(k) , n → ∞. Утверждение остается справедливым
k =1

k =1

и при замене верхней границы суммирования n на ϕ (n) для любой
функции ϕ (n), определенной для всех n ∈ N+ и принимающей значения
в N+ .
Доказательство. Докажем первую часть утверждения для Λ = Θ,
остальные случаи доказываются аналогично. В силу замечания, сделанного в §  после предложения .,
c1 b(k) ¶ a(k) ¶ c2 b(k)
для всех k ∈ N+ и некоторых c1 , c2 > 0. Отсюда
c1

n
X
k =1

b(k) ¶

n
X

a(k) ¶ c2

n
X

b(k).

k =1

k =1

Пример .. Проведем асимптотический анализ следующего алгоритма, оценивая общее число выполняемых операций в зависимости от исходного значения n:
l := 0;
p
for i = 1 to ⌊ n3 + 1⌋ do
k := i ;
j k
while k > 1 do l := l + k ; k := k od
3

od

Для внутреннего цикла, выполняемого при начальном значении k,
равном значению i, число шагов и общее число операций допускают оценку Θ(log i) (можно представить себе, что k записано в троичной системе счисления, тогда каждый шаг удаляет одну цифру из записи k). Таким образом, затраты на выполнение внешнеϕP
(n)
p
го цикла представляют собой
a(k), где ϕ (n) = ⌊ n3 + 1⌋, a(k) =
k =1

= Θ(log k), и по предложению . допускают оценку Θ

ϕP
(n)



log k

k =1

или Θ(log(ϕ (n)!). Так как ϕ (n) → ∞ при n → ∞, то можно применить соотношение log(ϕ (n)!) = Θ(ϕ (n) log ϕ (n)), которое являет-

§ . Нецелые размеры входа и непрерывные оценочные функции



ся следствием
формулы
Стирлинга (см. § ). Это дает нам оценку
p
p
3
3
Θ(⌊ n + 1⌋ log⌊ n + 1⌋) для интересующих нас затрат. После упрощения получаем Θ(n3/2 log n). В этом примере затраты однозначно
определяются по n, поэтому полученная оценка определяет асимптотику сложности рассматриваемого алгоритма при использовании n
в качестве размера
входа. p
p

Оценку O(⌊ n3 + 1⌋ log⌊ n3 + 1⌋) и, тем самым, O(n3/2 log n) можно было бы получить не прибегая к формуле Стирлинга, исходя из
того, что сумма конечного числа неотрицательных слагаемых не превосходит произведения наибольшего слагаемого на число слагаемых
суммы. Для Θ этот прием не работает, как показывает пример суммы
n
P
2i .
i =1

§ . Нецелые размеры входа и непрерывные оценочные
функции
Предложение .. Пусть для некоторого алгоритма A можно
указать входы v0 , v1 , ..., размеры которых ограничены сверху и снизу
положительными константами c1 и c2 :
c1 ¶ kvi k ¶ c2 ,

i = 0, 1, ...,

и в то же время затраты C AT (vi ) неограниченно возрастают при
i → ∞. Тогда не существует такой непрерывной на отрезке [c1 , c2 ]
функции f (x) вещественной переменной, что TA (x) ¶ f (x) для всех
значений x размера входа, принадлежащих отрезку [c1 , c2 ].
Доказательство. Очевидно, что TA (kvi k) ¾ C AT (vi ), и поэтому последовательность TA (kvi k), i = 0, 1, ..., не ограничена. В то же время,
любая функция f , непрерывная на [c1 , c2 ], ограничена на этом отрезке.
Сформулируем еще одно столь же легко доказываемое утверждение (доказательство опускаем).
Предложение .. Пусть A — некоторый алгоритм, и f (x) —
функция вещественной переменной, определенная на некотором интервале I. Пусть TA (x) ¶ f (x) всякий раз, когда x ∈ I и значение TA (x)
определено. Пусть x0 ∈ I и для любых ǫ > 0, N > 0 найдется такой
вход v алгоритма A, что | x0 − kv k| < ǫ и C AT (v) > N. Тогда f (x) разрывна в точке x0 .



Глава . Оценивание числа шагов (итераций) алгоритма

Пример .. Вновь рассмотрим алгоритм Евклида, используя теa
перь в качестве размера входа (a0 , a1 ) рациональное число 0 , котоa1

рое, как указывалось в примере ., однозначно определяет

 соответ′ a0
, соотствующее количество делений с остатком (сложность TE
a1

ветствующая этому размеру, совпадает с затратами: CE (a0 , a1 )). В силу формулы Бине (.) имеем
lim

n→∞

Fn+1
= φ,
Fn

при этом CE (Fn+1 , Fn ) = n. Поэтому если функция
вещественной пеa0 
ременной f (x) такова, что CE (a0 , a1 ) ¶ f
, то, в силу предложеa1

ния ., f (x) разрывна в точке φ . Мы воспользовались тем, что для
любого ǫ > 0 и любого натурального N найдется рациональное число
u
u/v такое, что |φ − | < ǫ и CE (u, v) ¾ N.
v
Можно доказать, что здесь дело не в числе φ — то же самое справедливо для любого x0 > 1. Пусть 0 < ǫ < x0 − 1. Докажем, что в рациональных точках ǫ -окрестности Vx0 ,ǫ числа x0 функция TE′ (r) не является ограниченной. Предположим противное: пусть r =

u0
∈ Vx0 ,ǫ — раu1

циональное число, на котором достигается максимум. Пусть частные,
возникающие в процессе применения алгоритма Евклида к u0 , u1 ,
равны q1 , q2 , ..., qn :
u i −1 = q i u i + u i +1 ,

i = 1, 2, ..., n,

un+1 = 0.

Выберем δ > 0 столь малым, что Vr,δ ⊂ Vx0 ,ǫ , и возьмем любое s ∈ Q \ Z

u
u n− 1
− s < δ (легко заметить, что n−1 = qn ∈ Z). Пусть
un
un
l
l, m — такие целые, что s = . Используя q1 , q2 , ..., qn , найдем v0 , v1 , ...
m

такое, что

..., vn ∈ N+ , для которых

vi−1 = qi vi + vi+1 ,

i = 1, 2, ..., n,

и vn−1 = l, vn = m. Индукцией по k легко доказать, что для k = 0, 1, ...
..., n − 1
u
vn−k−1
− n− k − 1 < δ .
vn−k
u n− k

(.)

В самом деле, для k = 0 это очевидно; остается показать, что при
0 < k < n − 1 из (.) следует
u
vn−k−2
− n− k − 2 < δ .
vn−k−1
u n− k − 1

(.)

§ . Нецелые размеры входа и непрерывные оценочные функции



Имеем

откуда

q
v
+v
v
vn−k−2
= n− k − 1 n− k − 1 n− k = q n − k −1 + n− k ,
vn−k−1
vn−k
vn−k−1
u n− k − 2
q
u
+ u n− k
u
= n− k − 1 n− k − 1
= q n − k −1 + n− k ,
u n− k − 1
u n− k
u n− k − 1
u n− k − 2
u n− k
vn−k−2
| un−k−1 vn−k − un−k vn−k−1 |
vn−k
−
−
.
=
=
vn−k−1
u n− k − 1
vn−k−1
u n− k − 1
un−k−1 vn−k−1

Неравенство (.) можно переписать в виде
| un−k−1 vn−k − un−k vn−k−1 |
< δ;
un−k vn−k

это неравенство влечет

| un−k−1 vn−k − un−k vn−k−1 |
< δ,
un−k−1 vn−k−1

так как un−k−1 vn−k−1 > un−k vn−k . Неравенство (.) доказано, и индукv
v
ция завершена. Следовательно, 0 ∈ Vs,δ и, тем самым, 0 ∈ Vx0 ,ǫ . Но
v
v1
1
v 
v
TE′ 0 > n, так как s = n−1 ∈
/ Z. Это противоречит предположению
v1
vn
u 
о максимальности значения TE′ 0 .
u1

В силу предложения . мы получаем следующее:
Пусть размер каждого входа (a0 , a1 ) алгоритма Евклида определен
как r = a0 /a1 (рациональное число ¾ 1), и в соответствии с этим рассматривается сложность TE′ (r) этого алгоритма по числу делений.
Пусть функция f (x) вещественной переменной, определенная всюду
на бесконечном полуинтервале I = [1, ∞), такова, что TE′ (r) < f (r) при
всех рациональных r ¾ 1. Тогда f (x) является разрывной в любой принадлежащей I точке.
Нелишне заметить, что при целочисленном размере входа условие
предложения . может выполняться, если только для некоторого целого n, c1 ¶ n ¶ c2 , сложность TA (n) бесконечна.
Приводившиеся ранее оценки (.), (.) для числа итераций методов деления пополам и касательных используют, фактически, нецелый размер 1/ǫ . Положение спасается тем, что при малом изменении ǫ не происходит катастрофического увеличения числа итераций.
Эту ситуацию можно было бы считать типичной, а пример . искусственным, если бы упомянутые возможные трудности не приводили бы иногда к реальным ошибкам. В приложении C рассмотрена
известная алгоритмическая проблема, связанная с алгебраическими



Глава . Оценивание числа шагов (итераций) алгоритма

числами («проблема орбит»), для которой в свое время было предложено и опубликовано неверное решение, и причина ошибки была
в том, что авторы проглядели ту негативную возможность, которая
показана в примере ..
В ситуациях, подобных описанной в примере ., мы не можем
использовать в оценках вида TA (x) < f (x), TA (x) = O( f (x)), TA (x) =
= Θ( f (x)) в качестве функции f (x), скажем, логарифм, степенную
и показательную функции, полиномы и т. д. Во многих случаях это
означает, что размер как функция входа выбран неудачно. В качестве
размера входа алгоритма надо, по возможности, выбирать такие величины, исходя из которых сложность алгоритма может быть выражена
или оценена с помощью простых аналитических функций. Это позволит составить представление об изменении сложности при возрастании размера входа. Появление функций, поведение которых трудно
себе вообразить, лишает возможности получения такой информации.
Задачи
. Функцию L(s) не обязательно выбирать целочисленной. Достаточно, чтобы ее значения были неотрицательными и каждый шаг
алгоритма понижал ее значение на величину, ограниченную снизу
некоторым положительным числом d. Как с помощью такой функции оценить число шагов?
. При использовании m = λ(a1 ) в качестве размера входа алгоритма Евклида и его расширенного варианта для соответствующих
мультипликативных сложностей справедливы верхние оценки 2m − 1
и, соответственно, 6m + 3.
. Бинарный алгоритм Евклида
на том, что если a0 и a1

 a a основан
0
1
,
; если a0 четно, но a1 нечетчетны, то íîä(a0 , a1 ) = 2 íîä
2 2
a
0
, a ; если a0 нечетно, но a1 четно,
но, то íîä(a0 , a1 ) = íîä
2 1


a1
; если a0 и a1 нечетны, то можно пето íîä(a0 , a1 ) = íîä a0 ,
2
рейти к вычислению íîä(a0 − a1 , a1 ) при a0 ¾ a1 и к вычислению
íîä(a0 , a1 − a0 ) при a0 < a1 . Вычисления заканчиваются, как только
на некотором этапе вычитание даст нуль. Выполнение этого алгоритма завершается для любых исходных a0 , a1 , для которых a0 ¾ a1 > 0.
Для числа шагов алгоритма как функции от a0 , a1 справедлива оценка O(log a0 ).
Указание. По крайней мере на одном из двух последовательных шагов
этого алгоритма по крайней мере одно из чисел делится на два.

Задачи



. Пусть в ходе применения алгоритма Евклида к числам a0 , a1 ,
a0 > a1 , возникают ненулевые остатки a2 , a3 , ..., an , и an+1 = 0. Тогда
an−t ¾ Ft +2 , t = 0, 1, ..., n − 1. Отсюда следует справедливость следующего предложения, обычно именуемого в литературе теоремой Ламе.
Пусть в ходе применения алгоритма Евклида к числам a0 , a1 , a0 > a1 ,
возникают ненулевые остатки a2 , a3 , ..., an . Тогда a1 ¾ Fn+1 .
. (Продолжение задачи .) Пусть в ходе применения алгоритма Евклида к числам a0 , a1 , a0 > a1 , возникают
ненулевые остатки
p
a2 , a3 , ..., an . Тогда n < logφ (a1 + 1) + logφ 5 − 1, и, как следствие,
n < logφ a1 + c для некоторой константы c.
. Привести доказательство равенства (.).
. Доказать оценку (.).
Указание. В §  при рассмотрении примера . уже доказано, что если
F2n−2
a0
∈ Φn , n > 2, то выполнены неравенства (.). Вывести отсюда, что
¶
a1
F2n−3
F2n−1
a2
a2
¶
, т. е.
∈ Φn−1 , n > 2.
¶
a3
F2n−2
a3

. Разработать алгоритм, распознающий существование у уравнения
ax + by = c, a, b, c ∈ Z,
(.)
решения в неотрицательных целых числах, и исследовать мультипликативную сложность этого алгоритма.
Указание. Уравнение (.) тогда и только тогда имеет решение в целых
числах, когда d | c, где d = íîä(a, b).

. Если x0 , y0 — одно из целочисленных решений уравнения
(.), то все решения описываются формулами
b
d

x = x0 + t,

a
d

y = y0 − t,

t = 0, ±1, ±2, ...,

d = íîä(a, b).
Указание. Если x0 , y0 и x1 , y1 — два различных решения уравнения (.),
то x0 − x1 , y0 − y1 — решение уравнения

a
b
x + y = 0.
d
d

. Числа si , ti , получаемые в ходе выполнения расширенного алгоритма Евклида, являются взаимно простыми при i = 0, 1, ..., n + 1.
Указание. Индукцией по i доказать равенство
 



t
− q i −1 1
−q1 1
= i
...
si
1
0
1
0

t i −1
s i −1



для i = 2, 3, ..., n − 1 и рассмотреть определители обеих его частей.



Глава . Оценивание числа шагов (итераций) алгоритма

. При некоторых значениях n число сравнений, затрачиваемых
при бинарном поиске, не определяется однозначно исходя лишь из
значения n (например, зная лишь, что n = 6, мы не можем указать
точное число сравнений). Но существует бесконечно много n таких,
для которых это значение определяется единственным образом и равно ⌊log2 n⌋ + 1.
. Бинарный поиск места элемента y в упорядоченном массиве
x1 < x2 < ... < xn требует ⌊log2 (n + 1)⌋ сравнений в лучшем случае. Как
следствие, для значений n вида 2k − 1, k = 1, 2, ..., и только для них
число сравнений однозначно определено.
Указание. Пусть µ(n) — минимум числа сравнений при бинарном поиске
места элемента. Имеем µ(1) = 1, и по индукции
можно доказать, что при
k
j
n−1

+ 1. Отсюда следует, что
n ¾ 2 выполнено µ(n) ¾ µ(n − 1) и µ(n) = µ
2
µ(n) равно числу положительных элементов последовательности

jn−1k
k
j
−1
n−1
2
, ...
(.)
,
n,
2

j

Заметим, что λ
k

n−1
2

k

2

= λ(n) − 1, если n 6= 2k , и λ
k

j

n−1
2

k
= λ(n) − 2,

если n = 2 , k > 0. Если n = 2 − 1, k > 0, то число положительных элементов (.) равно λ(n); в остальных случаях в последовательности (.) имеется в точности один элемент вида 2k , k > 0, и число положительных элементов рассматриваемой последовательности равно λ(n) − 1.

. Опорная прямая к многоугольнику P, проходящая через точку Q, внешнюю по отношению к многоугольнику, — это прямая, которой принадлежит по крайней мере одна вершина многоугольника P, и при этом все вершины этого многоугольника лежат в одной
полуплоскости по отношению к этой
прямой (рис. ). Предложить имеющий сложность в O(n) по общему числу операций алгоритм проведения двух
P
опорных прямых к данному выпуклому
n-угольнику из данной точки.
Q
Указание. Сначала найдем сторону
n-угольника, которая видна из точки Q
Рис. . Опорные прямые
(см. пример .). Это даст две соседние верк многоугольнику.
шины n-угольника. Через точку Q и каждую
из этих вершин проведем прямые. Затем
сдвигаемся от каждой из этих двух вершин в сторону, противоположную
другой вершине, пока увеличивается угол с вершиной Q .

Задачи



. Сложность алгоритма, схематически описанного в указании к
предыдущей задаче, есть Θ(n). (Вместе с тем, возможно построение
опорных прямых со сложностью Θ(log n) — для этого надо применить
некий вариант бинарного поиска для нахождения каждой из тех двух
вершин, через которые проходят искомые опорные прямые.)
. Предложить имеющий сложность O(n1 + n2 ) по общему числу операций алгоритм построения выпуклой оболочки объединения
двух выпуклых многоугольников, имеющих, соответственно, n1 и n2
вершин, считая n1 + n2 размером входа.
Указание. Один из известных алгоритмов этого построения основывается
на том, что, взяв некоторую точку Q , принадлежащую первому многоугольнику, мы, в том случае, когда эта точка принадлежит и второму многоугольнику, можем путем слияния двух упорядоченных последовательностей получить
последовательность всех вершин обоих многоугольников, упорядоченных по
величине углов, под которыми видны эти вершины по отношению к какой-нибудь фиксированной прямой, проходящей через Q . После этого, как в алгоритме Грэхема (см. пример .), можно удалить вдавленные вершины. Если Q не
принадлежит второму многоугольнику, то проведем из Q две опорные прямые
ко второму многоугольнику. Пусть S и T — вершины второго многоугольника, через которые проходят опорные прямые (если опорная прямая проходит
через несколько вершин, то из них выбирается наиболее удаленная от Q ). Исключим из рассмотрения все принадлежащие треугольнику QST вершины второго многоугольника, кроме вершин S и T (рис. ). Оставшиеся вершины рассматриваем в порядке возрастания углов; сливаем, как и в первом случае, две
упорядоченные последовательности, а затем удаляем вдавленные вершины.

а)

S

Q

б)

в)

Q

Q

T
Рис. . Этапы построения выпуклой оболочки объединения двух выпуклых
многоугольников.

. Верно ли, что сложность по числу сравнений сортировки массива из n элементов бинарными вставками есть n log2 n + O(1)?
. Обратимся к известной школьной задаче: имеются 3m монет,
из которых одна фальшивая (более легкая); с помощью чашечных
весов без гирь надо за m взвешиваний определить фальшивую мо-



Глава . Оценивание числа шагов (итераций) алгоритма

нету. Сравнение по весу двух групп по 3m−1 монет сужает диапазон
последующего поиска до 3m−1 монет, поэтому в итоге будет затрачено m взвешиваний, как и требуется. Для числа монет n = 3m мы
имеем алгоритм, использующий log3 n взвешиваний. (Здесь мы рассматриваем n в качестве размера исходной группы монет.) Можно
обобщить этот алгоритм на произвольное число монет n так, что
число взвешиваний будет ограничено близкой к log3 n функцией:
сравниваем по весу две группы, в каждой из которых по ⌈n/3⌉ монет, это сужает диапазон дальнейшего поиска до не превосходящего
⌈n/3⌉ числа монет; затем действуем тем же способом. Получить верхнюю границу ⌈log3 n⌉ для числа взвешиваний сопоставлением размеров групп с элементами последовательности 1, 3, 9, ... подобно тому, как при анализе сортировки фон Неймана количество упорядоченных сегментов сопоставлялось с элементами последовательности
1, 2, 4, ...
. Изменим алгоритм поиска фальшивой монеты (задача ): будем сравнивать по весу две группы, в каждой из которых по ⌊n/3⌋
монет, и т. д.
а) Показать, что этому алгоритму может потребоваться число
взвешиваний, которое превосходит ⌈log3 n⌉.
б) Получить верхнюю границу ⌊log3 n⌋ + 2 для числа взвешиваний сопоставлением размеров групп с элементами последовательности 1 + 2, 3 + 2, 9 + 2, ... подобно тому, как в при анализе бинарного
поиска размеры сегментов сопоставлялись с элементами последовательности 1, 2, 4, ...
. Вернемся к начальному варианту алгоритма определения фальшивой монеты (задача ). При некоторых значениях n количество
взвешиваний не определяется однозначно исходя лишь из значения n
(например, при n = 10), хотя и существует бесконечно много n таких,
для которых это значение определяется единственным образом.
. Каждый день бизнесмен дает черту одну монету, и в обмен
получает любой набор монет по своему выбору, но меньшего достоинства. Видов монет конечное число; менять или получать деньги
в другом месте бизнесмен по условиям сделки не может. Если у бизнесмена не остается монет достоинством выше минимального, он
проигрывает. На таких условиях рано или поздно бизнесмен терпит
поражение, каков бы ни был первоначальный запас его монет.
. Имеется конечная последовательность нулей и единиц. Разрешается найти в ней группу 01 и заменить на 100...00 (при этом
можно написать сколько угодно нулей). Доказать, что это преобразование не может быть произведено бесконечно много раз.

Задачи



. Алгоритм, приведенный в примере ., затрачивает O(log n)
шагов.
. Вернемся к алгоритму кратных карт (пример .). Если изначально все вопросы имели большие единицы кратности и обучаемому
удалось дать ряд правильных ответов на один из вопросов, понизив
его кратность до единицы, причем этого ему удалось добиться на
фоне плохих ответов на все остальные вопросы, то дальнейшее рассмотрение этого вопроса будет как бы отложено до тех пор, пока
обучаемый не усвоит еще по крайней мере один вопрос, сведя и его
кратность к единице. Алгоритм препятствует слишком быстрому изъятию из рассмотрения отдельных вопросов.
. Найти число операций прибавления единицы к r при выполнении алгоритма для заданного натурального n
r := 0;
for i = 1 to n do
for j = i + 1 to n do
for k = i + j − 1 to n do r := r + 1 od
od
od
(иначе: определить, чему равно r). Формальное построение и последующее столь же формальное вычисление суммы по аналогии с проделанными в примере . привело бы к неправильному ответу (причина указывалась в §  в замечании к примеру .).
. Исследовать зависимость от целого n > 0 общего числа арифметических операций, требуемых алгоритмом
l := 0;
for i = 1 to n do
for j = 1 to ⌊log2 i ⌋ do l := l + i + j od
od
. Исследовать зависимость от n > 0 общего числа арифметических операций, требуемых алгоритмом
l := 0;
p
for i = 1 to ⌊ n⌋ do
z := i ;
while z > 1 do l := l + 1; z := 7z od
od
(значения z не обязательно целые).

Глава 

Нижняя граница сложности алгоритмов
некоторого класса. Оптимальные алгоритмы

§ . Понятие нижней границы сложности
Хорошо известно, что существуют алгоритмически неразрешимые задачи. Но если даже задача алгоритмически разрешима, то возможно,
что сложность каждого из алгоритмов ее решения будет в определенном смысле достаточно высокой.
Пример .. Рассмотрим задачу поиска наименьшего элемента
с помощью сравнений в массиве длины n. Для того чтобы иметь
основания отсеять элемент массива как заведомо не являющийся
наименьшим, необходимо, чтобы этот элемент участвовал хотя бы
в одном сравнении и оказался бо́льшим. Мы должны отсеять n − 1
элемент, а в каждом сравнении ровно один элемент оказывается
бо́льшим. Это означает, что потребуется не менее n − 1 сравнения.
Введем основное понятие этой главы.
Определение .. Пусть A — класс алгоритмов решения некоторой задачи. Пусть принято соглашение о том, в чем измеряются
затраты алгоритмов и что считается размером входа, и пусть n — обозначение размера входа. Функция f (n) называется нижней границей сложности принадлежащих A алгоритмов, если для сложности
TA (n) любого A ∈ A мы имеем TA (n) ¾ f (n) при всех допустимых значениях размера входа n. (Если используются несколько параметров
n1 , n2 , ..., nk размера входа, то нижняя граница — это, соответственно, функция аргументов n1 , n2 , ..., nk .)
Это определение имеет смысл как для сложности в худшем случае,
так и для сложности в среднем. Далее в примерах этого и следующего
параграфов мы рассматриваем сложность в худшем случае; к сложности в среднем мы вернемся в § . Всюду будет рассматриваться вре-

§ . Понятие нижней границы сложности



менная сложность. Мы можем сформулировать обнаруженный при
рассмотрении примера . факт следующим образом.
Предложение .. Функция f (n) = n − 1 является нижней границей сложности алгоритмов поиска наименьшего элемента массива
длины n c помощью сравнений.
(Иными словами, не существует такого алгоритма выбора наименьшего элемента массива длины n c помощью сравнений, сложность которого хотя бы для одного значения n была меньше чем
n − 1.)
В роли класса A здесь выступает класс алгоритмов поиска наименьшего элемента массива с помощью сравнений. Если бы помимо
сравнений были допустимы какие-то еще операции, то, возможно,
n − 1 уже не годилось бы в качестве нижней границы. Например, если было бы разрешено пользоваться операцией выбора наименьшего
из нескольких элементов, то задачу можно было бы решить одной
операцией.
Пример .. Рассмотрим класс алгоритмов сортировки с помощью сравнений. Если алгоритм работает для массивов любой длины, то, разумеется, можно рассмотреть этот алгоритм применительно к массивам некоторой фиксированной длины n. Любая сортировка
с помощью сравнений может быть для каждого конкретного n изображена бинарным деревом. В корне и внутренних вершинах находятся выполняемые сравнения, в листьях выписаны результаты сортировки. Априори в исходном массиве возможен любой порядок элементов, поэтому дерево будет иметь n! листьев. Если взять, например,
сортировку простыми вставками, то при n = 2 ее можно изобразить
деревом, представленным на рис. а. При n = 3 дерево принимает
вид, показанный на рис. б. Сложность в худшем случае для каждого n равна высоте соответствующего дерева (напомним, что высотой
листа называется число ребер в том единственном пути, который ведет от корня дерева к этому листу; высотой дерева называется максимум высот его листьев). Если высота некоторого бинарного дерева
равна h, то, очевидно, оно содержит не более 2h листьев (максимальное возможное число листьев достигается в случае полного бинарного дерева, которое имеет ровно 2h листьев). Поэтому если T(n) — это
временная сложность некоторой сортировки сравнениями, то должно
выполняться неравенство
2T (n) ¾ n!,

 Глава . Нижняя граница сложности. Оптимальные алгоритмы
x1 < x2

а)

б)

x1 < x2

0

1
x1 , x2

x2 , x1
0

1

x2 < x3

x3 < x1
0

1

x3 < x2

x1 < x3

x1 , x2 , x3
1
x1 , x3 , x2

0

1

0
x3 , x1 , x2

1
x3 , x2 , x1

x2 , x1 , x3
0
x2 , x3 , x1

Рис. . Дерево сортировки простыми вставками для случаев а) n = 2
и б) n = 3.

откуда T(n) ¾ log2 n!; так как значение T(n) — целое число (мы измеряем сложность числом сравнений), то T(n) ¾ ⌈log2 n!⌉. Доказанное
можно сформулировать в виде предложения.
Предложение .. Функция f (n) = ⌈log2 n!⌉ является нижней границей сложности алгоритмов сортировки массивов длины n c помощью сравнений.
Отсюда можно вывести, например, следующее предложение.
Предложение .. Пусть сложность T(n) некоторой сортировки по числу сравнений не превосходит n log2 n + cn, где c — некоторая константа. Тогда T(n) = n log2 n + O(n) и, как следствие, T(n) ∼
∼ n log2 n.
Доказательство. В силу предложения . и формулы (.) для
всех достаточно больших n мы имеем T (n) ¾ ⌈log2 n!⌉ > n log2 n − 2n,
и, следовательно, n log2 n − 2n < T(n) ¶ n log2 n + cn. Отсюда следует
требуемое.
Это позволяет, например, заключить, что для сложности по числу сравнений сортировки фон Неймана имеет место оценка TvN (n) =
= n log2 n + O(n) и асимптотическое равенство TvN (n) ∼ n log2 n, — мы
уже видели, что TvN < n⌈log2 n⌉ < n log2 n + n.

§ . Оптимальные алгоритмы



Добавим, что никакая сортировка не может иметь сложность T(n)
по числу сравнений, допускающую оценку αn log2 n + o(n log n), α < 1
(в частности, оценку αn log2 n + O(n)), — это следует из того, что для
всех достаточно больших n выполнено T(n) > n log2 n − 2n.
Пример .. Обратимся к задаче поиска места элемента в упорядоченном массиве длины n.
Предложение .. Функция f (n) = ⌈log2 (n + 1)⌉ является нижней
границей сложности алгоритмов поиска места элемента в упорядоченном массиве длины n c помощью сравнений.
Доказательство. Любой алгоритм поиска места элемента в упорядоченном массиве фиксированной длины n может быть изображен
бинарным деревом. Число листьев такого дерева есть n + 1. Далее
рассуждаем так же, как при доказательстве предложения ..
Пример .. Рассмотрим задачу вычисления an с помощью умножений (пример .). Будем считать n размером входа. Затраты будем
измерять количеством умножений.
Предложение .. Функция f (n) = ⌈log2 n⌉ является нижней границей сложности алгоритмов вычисления an с помощью умножений.
Доказательство. На каждом этапе алгоритма мы имеем вычисленный набор степеней
am1 , am2 , ..., amk ,

(.)

при этом на начальном этапе набор состоит из одного элемента a1 .
Выполнив одно умножение, мы, очевидно, не можем увеличить максимальный показатель m = max{m1 , m2 , ..., mk } более чем вдвое. Поэтому если определить на наборах вида (.) функцию L, равную
log2 n − log2 m, то в результате одного шага (одного умножения) эта
функция не может уменьшиться больше чем на 1. В то же время значение этой функции на исходном наборе равно log2 n, а на итоговом
наборе она заведомо неположительна.
§ . Оптимальные алгоритмы
Нижняя граница сложности класса алгоритмов определяется не единственным образом. Например, f (n) = 0 всегда является нижней границей, равно как и любая отрицательная функция. Чем больше найденная нижняя граница, тем она нетривиальнее и ценнее. Сигналом
о том, что мы не сможем построить нижнюю границу бо́льшую, чем

 Глава . Нижняя граница сложности. Оптимальные алгоритмы
уже имеющаяся у нас нижняя граница f (n), может служить, например, наличие A ∈ A , для которого TA (n) = f (n). С такой ситуацией мы
сталкиваемся в предыдущем параграфе в примерах . и .. Известный нам алгоритм поиска наименьшего элемента и алгоритм бинарного поиска места элемента в упорядоченном массиве имеет каждый
сложность, совпадающую с найденной нижней границей. Эти алгоритмы являются оптимальными в смысле следующего определения.
Определение .. Пусть A — класс алгоритмов решения некоторой задачи. Пусть принято соглашение о том, в чем измеряются
затраты алгоритмов и что считается размером входа, и пусть n — обозначение размера входа. Алгоритм A ∈ A называется оптимальным
в A , если TA (n) является нижней границей сложности алгоритмов
из A .
Пример .. При получении нижней границы сложности и доказательстве оптимальности иногда бывает полезным привлечение
функций на наборах тех величин, которые возникают в процессе выполнения алгоритма, например, на наборах значений переменных,
используемых алгоритмом.
l m
3n
− 2 является нижней
Предложение .. Функция f (n) =
2
границей сложности алгоритмов одновременного выбора наибольшего
и наименьшего элементов массива длины n c помощью сравнений.
Доказательство. Каждый этап выполнения произвольного алгоритма V, основанного на сравнениях и предназначенного для поиска
наибольшего и наименьшего элементов массива, может быть охарактеризован четверкой (A, B, C, D) подмножеств множества исходных
элементов {x1 , x2 , ..., xn }, где
• A состоит из всех тех элементов, которые вообще не сравнивались;
• B состоит из всех тех элементов, которые участвовали в некоторых
сравнениях и всегда оказывались бо́льшими;
• C состоит из всех тех элементов, которые участвовали в некоторых сравнениях и всегда оказывались меньшими;
• D состоит из всех тех элементов, которые участвовали в некоторых сравнениях, иногда оказываясь бо́льшими, а иногда — меньшими.
Пусть a, b, c, d — количества элементов множеств A, B, C, D соответственно. Исходная ситуация характеризуется равенствами a = n, b =
= c = d = 0. После завершения алгоритма должны выполняться равен-

§ . Оптимальные алгоритмы



ства a = 0, b = c = 1, d = n − 2. После первого сравнения на протяжении всего выполнения алгоритма постоянно будут иметь место неравенства b ¾ 1, c ¾ 1.
Все сравнения, совершаемые при выполнении алгоритма V , можно разбить на типы, обозначаемые AA, AB, AC, AD, BB, BC, BD, CC,
CD, DD, например: сравнение принадлежит типу AB, если один из
сравниваемых элементов берется из A, другой — из B, и т. д. Исходя из
этого, можно выписать все возможные изменения четверки (a, b, c, d)
под действием сравнений разных типов:
AA : (a − 2, b + 1, c + 1, d),

AB : (a − 1, b, c + 1, d) | (a − 1, b, c, d + 1),
AC : (a − 1, b + 1, c, d) | (a − 1, b, c, d + 1),

AD : (a − 1, b + 1, c, d) | (a − 1, b, c + 1, d),
BB: (a, b − 1, c, d + 1),
BC : (a, b − 1, c − 1, d + 2) | (a, b, c, d),
BD : (a, b − 1, c, d + 1) | (a, b, c, d),

CC : (a, b, c − 1, d + 1),
CD : (a, b, c − 1, d + 1) | (a, b, c, d),

DD : (a, b, c, d)

(вертикальная черточка здесь означает «или»). Рассмотрим функцию
3
L(a, b, c, d) = a + b + c − 2. Для начальной и конечной стадий имеем
2
3

L(n, 0, 0, 0) = n − 2 и L(0, 1, 1, n − 2) = 0 соответственно.
2
Каждое сравнение типов AA, BB, CC понижает значение L на 1,
т. е. дает ∆ L = −1. Выпишем все возможные значения ∆ L при выполнении сравнений различных типов:
AA, BB, CC :
BD, CD :

−1,

−1 | 0,
3
2

1
2

AB, AC :

− |− ,

BC :

−2 | 0,

AD :

− ,

DD :

0.

1
2

Сравнения, относящиеся к типам AB, AC, BC, могут приводить
к ∆ L < −1, но это не может быть гарантировано никаким специальным выбором элементов из соответствующих множеств четверки

 Глава . Нижняя граница сложности. Оптимальные алгоритмы
(A, B, C, D), даже если принимать во внимание результаты всех сравнений, в которые были вовлечены конкретные элементы этих множеств. Например, сравнение типа AB в том случае, когда выбранный
элемент из A оказывается больше выбранного элемента из B, преобразует (a, b, c, d) в (a − 1, b, c, d + 1), что дает ∆ L < −1. Но результаты
предшествующих сравнений не дают оснований для отметания возможности того, что выбранный элемент из B равен max{x1 , x2 , ..., xn }
(ибо этот элемент оказался бо́льшим во всех сравнениях, в которые
1
он был вовлечен). Но тогда будет выполнено ∆ L = − . Аналогичным
2
образом дело обстоит для сравнений, принадлежащих типам AC, BC.
Поэтому, рассматривая поведение алгоритма V в худшем случае, надо считать, что на всех этапах ∆ L ¾ −1. Но тогда для достижения равенства L(a, b, c, d) = 0 потребуется не менее ⌈ L(n, 0, 0, 0)⌉ сравнений.
Это значит,
l m что общее число сравнений в худшем случае не меньше,
3n
чем
− 2.
2

Представленный в приложении A алгоритм одновременного поиска
наибольшего и наименьшего
элементов массива, требующий в худшем
l m
3n
случае не более
− 2 сравнений, является оптимальным  .
2

Наряду с алгоритмами поиска наименьшего элемента, бинарного поиска места элемента в упорядоченном массиве и алгоритма одновременного поиска наибольшего и наименьшего элементов массива примером оптимального алгоритма может служить алгоритм
(«схема») Горнера вычисления значения полинома в данной точке
(см. приложение D).
Для произвольного класса A оптимальный алгоритм может и не
существовать: если, например, A содержит ровно два алгоритма,
A1 , A2 , и при этом A1 имеет низкую сложность при четных значениях целочисленного размера входа n и высокую — при нечетных,
а A2 — наоборот, то, очевидно, ни A1 , ни A2 не будут оптимальными в A . Ясно, что если оптимальные алгоритмы в классе A существуют, то их сложности совпадают: из неравенств TA1 (n) ¾ TA2 (n)
и TA2 (n) ¾ TA1 (n) следует, что TA1 (n) = TA2 (n). Несколько более содержательный пример можно найти в задаче .
В отличие от поиска наименьшего элемента, поиска места в упорядоченном массиве и одновременного поиска наибольшего и наи
Этот алгоритм и идея использования четверок (A, B, C, D) в доказательстве его оптимальности были предложены И. Полом в [], но при этом убывающие функции в его
доказательстве не привлекались, из-за чего потребовались дополнительные словесные
мотивации.

§ . Оптимальные алгоритмы



меньшего элементов, задача сортировки не столь проста: те алгоритмы, которыми пользуются на практике для ее решения, не являются,
строго говоря, оптимальными (см. приложение F).
Заметим при этом, что для каждого конкретного n за конечное
число шагов может быть найдено наименьшее число сравнений, достаточное в худшем случае для сортировки n элементов, а вместе
с ним и алгоритм сортировки с такой сложностью. Это следует из того, что при каждом конкретном n алгоритм сортировки может быть
представлен бинарным деревом. Можно порождать одно за другим
все бинарные деревья с высотой, не превосходящей ⌈log2 n!⌉, в вершинах каждого такого дерева различными способами расставлять выражения вида xi < x j , где i, j ¶ n, а в листьях — различные перестановки длины n. Для каждого размеченного таким способом дерева
нужно проверить, действительно ли каждая ветвь приводит именно
к тому порядку, который указан в листе, и что все возможные порядки охвачены. Из всех «правильных» деревьев выбирается имеющее
наименьшую высоту. Оно определяет оптимальный алгоритм для заданного n.
Таким образом, мы имеем алгоритм, который, исходя из n > 0,
строит оптимальный по числу сравнений алгоритм сортировки массивов из n элементов (алгоритм строит алгоритм). Этот алгоритм
построения оптимального алгоритма сортировки требует огромной
работы, даже если применить все средства экономии перебора. Этот
пример еще раз показывает, что понятие алгебраической сложности
требует осторожного обращения, — объем неучитываемых операций
может превзойти разумные пределы.
Бинарный алгоритм возведения в степень n также не является
оптимальным по числу умножений при использовании n в качестве
размера входа (см. задачу ), хотя и легко показать, что для случая n = 2k при рассмотрении k в качестве размера входа оптимальность имеет место: из предложения . следует, что возведение в степень n = 2k не может быть выполнено с затратами меньшими, чем
k умножений, а бинарный алгоритм обходится в точности этим числом умножений.
В общем же случае, как и многие известные алгоритмы сортировки, бинарный алгоритм возведения в степень оптимален лишь
в некотором асимптотическом смысле, о чем пойдет речь в следующем параграфе.
Если затраты для каждого входа являются целыми числами (например, они являются количеством выполненных операций), то для
фиксированного размера n0 входа в рассматриваемом классе A ал-

 Глава . Нижняя граница сложности. Оптимальные алгоритмы
горитмов решения некоторой задачи P существует такой, сложность
которого при n = n0 есть минимум сложностей всех алгоритмов из A .
Можно определить такой минимум для любого значения n, получаемую таким способом функцию от n иногда называют сложностью
задачи P по отношению к классу алгоритмов A . Важно, что при разных n минимумы могут доставляться разными алгоритмами из A
(см. задачу ). В дальнейшем мы не будем касаться этих вопросов.
§ . Асимптотические нижние границы. Алгоритм,
оптимальный по порядку сложности
Известно не очень много алгоритмов, оптимальных в смысле определения .. Рассмотрим дополнительно понятие алгоритма, оптимального по порядку сложности.
Определение .. Пусть A — класс алгоритмов решения некоторой задачи. Пусть принято соглашение о том, в чем измеряются
затраты алгоритмов и что считается размером входа, и пусть n — обозначение размера входа. Функция f (n) называется асимптотической
нижней границей сложности принадлежащих A алгоритмов, если
для сложности TA (n) любого A ∈ A мы имеем TA (n) = Ω( f (n)). (Если используются несколько параметров n1 , n2 , ..., nk размера входа, то
асимптотическая нижняя граница — это, соответственно, функция аргументов n1 , n2 , ..., nk .) Алгоритм A ∈ A называется оптимальным по
порядку сложности в A , если TA (n) является асимптотической нижней границей сложности алгоритмов из A .
Очевидно, что любая неотрицательная нижняя граница сложности является и асимптотической нижней границей, и что любой оптимальный алгоритм является оптимальным по порядку сложности.
Ниже в примере . мы увидим, что может существовать несколько
оптимальных по порядку сложности в A алгоритмов. Однако сложности таких алгоритмов оказываются величинами одного порядка.
Теорема .. Пусть A, B ∈ A оптимальны по порядку сложности
в A . Тогда TA (n) = Θ(TB (n)).
Доказательство. Так как алгоритм A оптимален по порядку сложности, имеем TB (n) = Ω(TA (n)) или, что то же самое, TA (n) = O(TB (n)),
что вместе с TA (n) = Ω(TB (n)) (алгоритм B оптимален по порядку
сложности) дает TA (n) = Θ(TB (n)).

§ . Асимптотические нижние границы



Укажем достаточное условие оптимальности алгоритма по порядку сложности.
Теорема .. Если функция f (n) является асимптотической нижней границей сложности принадлежащих классу A алгоритмов и если
алгоритм A ∈ A таков, что TA (n) = O( f (n)), то этот алгоритм оптимален в A по порядку сложности и TA (n) = Θ( f (n)).
Доказательство. Для произвольного B ∈ A имеем TB (n) = Ω( f (n));
учитывая, что TA (n) = O( f (n)), получаем TB (n) = Ω(TA (n)), т. е. алгоритм A оптимален по порядку сложности.
Из TA (n) = Ω( f (n)) и TA (n) = O( f (n)) получаем TA (n) = Θ( f (n)).
Пример .. Из предложения . следует, что функция f (n) =
= log2 n является асимптотической нижней границей сложности алгоритмов вычисления an с помощью умножений (эта функция даже
является нижней границей в смысле определения .). Для сложности бинарного алгоритма вычисления an мы имеем TRS (n) = O(log n)
(см. пример .). Из теоремы . теперь получаем:
Бинарный алгоритм возведения в степень является оптимальным
по порядку сложности в классе алгоритмов вычисления an с помощью
умножений.
Иногда, хотя не часто, из совершенно элементарных соображений
удается найти такую нижнюю границу сложности, что далее по теореме . оказывается возможным обосновать оптимальность некоторого известного алгоритма по порядку сложности. Рассмотрим два
примера из теории графов.
Пример .. Вопрос о существовании и построении эйлерова
цикла данного ориентированного графа сформулирован в задаче .
Остановимся на случае связного графа. Очевидно, что если избрать
число ребер | E | в качестве размера входа, то | E | является нижней
границей сложности класса всех алгоритмов построения эйлеровых
циклов, так как, во-первых, любой эйлеров цикл содержит по определению все ребра графа и на любое ребро уйдет по крайней мере
одна операция, и, во-вторых, для любого натурального n существует
граф с | E | = n, содержащий эйлеров цикл. Поэтому тот алгоритм со
сложностью O(| E |), который требуется дать в задаче , будет оптимальным по порядку сложности.
Пример .. Рассмотрим задачу построения минимального остовного (покрывающего) дерева данного связного графа, каждое ребро

 Глава . Нижняя граница сложности. Оптимальные алгоритмы
которого имеет некоторый неотрицательный вес. Имеется в виду дерево:
(a) которое охватывает все вершины данного графа,
(b) все ребра которого являются ребрами данного графа,
(c) которое среди всех деревьев, обладающих свойствами (a), (b),
имеет минимальный суммарный вес ребер  .
Будем считать, что граф не содержит кратных ребер. Пример графа с соответствующим остовным деревом дан на рис. . Для построения минимального остовного дерева известны остроумные алгоритмы, например,
4
5
алгоритм Р. Прима  с оценкой сложности
20

2

O(| E | + | V | log| V |).

1

(.)

В этой оценке | V | и | E | рассматриваются
как два параметра размера входа. Не обсуждая вопрос, является или нет алгоритм
2
Прима оптимальным по порядку сложности при таком выборе параметров размера
Рис. . Граф с припивхода и не рассматривая детали алгоритма
санными ребрам весами
Прима, мы покажем, что этот алгоритм опи его остовное дерево.
тимален по порядку сложности при использовании | V | как размера (единственного параметра размера) входа. Так как среди всех графов без кратных ребер, имеющих | V | вершин, наибольшее число ребер
3

6

3

6

| V |(| V | − 1)
2

имеет полный граф, то оценка (.) имеет следствием оценку
O(| V |2 ). С другой стороны, асимптотическая нижняя граница Ω(| V |2 )
для алгоритмов такого рода получается тривиально: эту оценку допускает число ребер полного графа, а на каждое ребро графа алгоритм затрачивает по крайней мере одну операцию (он не может не
принять в расчет вес какого-либо ребра).
Если использовать для входов алгоритмов построения остовного
дерева размер | V |, то | V |2 даст асимптотическую нижнюю границу
сложности этих алгоритмов, и алгоритм Прима будет оптимальным по порядку сложности (его сложность, соответствующая этому
размеру входа, есть Θ(| V |2 )).



См. [, гл. ].
Этот алгоритм описан, например, в [, разд. .].

§ . Асимптотические нижние границы



Из этого примера видно, что само свойство оптимальности находится в зависимости от выбора размера входа  .
В следующем примере, касающемся сортировки массивов, рассматривается сложность в худшем случае по числу сравнений.
Пример .. Аналогично тому, как это сделано в примере .,
мы получаем, что любая сортировка, сложность которой допускает
оценку O(log n!), является оптимальной по порядку сложности. В силу
формулы Стирлинга мы имеем n log2 n = O(log n!), откуда следует, что
любая сортировка, сложность которой по числу сравнений допускает
оценку O(n log n), является оптимальной по порядку сложности.
Сортировка бинарными вставками и сортировка фон Неймана являются оптимальными по порядку сложности по числу сравнений.
(Позднее мы установим оценку O(n log n) и для сложности рекурсивной сортировки слияниями.) Эти сортировки имеют разные сложности как функции от n: например, TvN (5) = 9, TB (5) = 8. Но, повторим,
их сложности являются величинами одного порядка при n → ∞.
Резюмируем наши наблюдения.
Предложение .. Необходимым и достаточным условием оптимальности сортировки по порядку сложности является справедливость оценки O(n log n) для сложности этой сортировки. Если для
некоторой сортировки справедлива оценка O(n log n), то справедлива
и оценка Θ(n log n).
Доказательство. Достаточность уже установлена выше. Оставшаяся часть доказательства следует, например, из теоремы . и оптимальности по порядку сложности сортировки бинарными вставками.
Заметим при этом, что для сортировок бинарными вставками и
фон Неймана справедливо значительно более сильное утверждение,
чем утверждение об их оптимальности по порядку сложности. Для
их сложностей и сложности Topt (n) оптимального алгоритма имеет
место асимптотическая эквивалентность:
TB (n) ∼ TvN (n) ∼ Topt (n) ∼ n log2 n ∼ log2 n!.
Коснемся нижних границ пространственной сложности алгоритмов
сортировки. Если из всех этих алгоритмов выделить класс таких, которые используют для перемещения элементов обмены (↔), а не присва

Этот пример сообщил автору Е. В. Зима.

 Глава . Нижняя граница сложности. Оптимальные алгоритмы
ивания (:=), то для этого класса единственной нижней границей, если
говорить о функциях, принимающих неотрицательные значения, будет
тождественно равная нулю функция, так как существуют, например,
пузырьковая сортировка, сортировки простыми и бинарными вставками, не использующие дополнительных переменных того типа, к которому относятся элементы сортируемого массива. (То, что требуются
переменные для хранения значений индексов элементов, несущественно при изучении алгебраической сложности сортировки.) Алгоритмы,
использующие присваивания для перемещения сортируемых элементов, не могут, естественно, обойтись без дополнительного места для
хранения хотя бы одной величины того же типа, что и элементы сортируемого массива, и одной из нижних границ будет функция, тождественно равная единице. Если рассматривать все алгоритмы сортировки вместе, то вновь единственная неотрицательная целочисленная граница — это 0. В соответствии с этим определяются как оптимальные,
так и оптимальные по порядку сложности алгоритмы.
Для произвольного класса A оптимальный по порядку сложности
алгоритм может и не существовать: если A содержит всего два алгоритма A1 , A2 и при этом A1 имеет низкую сложность при четных
значениях целочисленного размера входа n и высокую — при нечетных, а A2 — наоборот, то, очевидно, ни A1 , ни A2 не будут оптимальными в A по порядку сложности (представим себе, что TA1 =
= (1 + (−1)n )n, TA2 = (1 − (−1)n )n). В то же время, если допустить, что
TA1 = (2 + (−1)n )n, TA2 = (2 − (−1)n )n, то TA1 (n) = Θ(TA2 (n)) (обе функции имеют порядок n), и это говорит о возможности существования
оптимального по порядку сложности алгоритма при отсутствии оптимального.
§ . Нижняя граница сложности в среднем
При рассмотрении сложности в среднем мы основываемся на тех же
понятиях нижней границы, оптимального и оптимального по порядку
сложности алгоритма, которые были введены для сложности в худшем случае.
Пример .. Вновь обратимся к классу алгоритмов сортировки.
Будем, как и в § , рассматривать вероятностное пространство Πn .
Предложение .. Функция log2 n! является нижней границей
сложности в среднем для класса алгоритмов сортировки массивов
длины n с помощью сравнений.

§ . Нижняя граница сложности в среднем



Прежде всего докажем вспомогательное утверждение.
Лемма .. В любом двоичном дереве с m листьями сумма высот
всех листьев не меньше m log2 m.
Доказательство. Пусть непусто множество M всех двоичных деревьев, для которых сумма высот всех листьев меньше m log2 m. Выберем в M какое-нибудь из деревьев, имеющих наименьшую сумму высот, и обозначим его U (сумму высот всех листьев будем обозначать
через H(U)). Это дерево не может состоять из одного лишь корня,
потому что для такого дерева обсуждаемое неравенство выполнено.
Далее, из корня этого дерева не может выходить только одно ребро,
потому что для дерева, получающегося из исходного удалением корня и этого ребра, обсуждаемое неравенство не выполняется, и такое
новое дерево имеет сумму высот меньшую, чем дерево U (противоречие со способом выбора дерева U). Поэтому из корня дерева U
выходит два ребра, концы которых являются корнями двух деревьев
U1 и U2 , для которых выполнено обсуждаемое неравенство. Пусть эти
деревья имеют, соответственно, m1 и m2 листьев, m1 , m2 > 0. Имеем
соотношение для сумм высот всех листьев
H(U) = H(U1 ) + H(U2 ) + m ¾ m1 log2 m1 + m2 log2 m2 + m.
Отсюда получаем
H(U) ¾ m1 log2 m1 + (m − m1 ) log2 (m − m1 ) + m
при некотором m1 таком, что 1 ¶ m1 ¶ m − 1.
Легко показать, что при фиксированном m функция f (x) = x log2 x +
+ (m − x) log2 (m − x) достигает минимума на отрезке [1, m − 1] в точке
(не обязательно целой) m/2. Поэтому
H(U) ¾

m
m
m
m
log2 + log2 + m = m log2 m.
2
2
2
2

Но это противоречит способу выбора U. Лемма доказана.
Доказательство предложения .. Рассмотрим какое-либо дерево
сортировки массива длины n. Это дерево имеет ровно n! листьев,
каждый лист соответствует перестановке элементов исходного массива. Появление на выходе рассматриваемой сортировки любой из этих
1
перестановок имеет одну и ту же вероятность , количество сравнеn!
ний, приводящее к этой перестановке — это высота соответствующего
этой перестановке листа. Поэтому математическое ожидание числа
1
сравнений равно произведению суммы высот всех листьев на .
n!

 Глава . Нижняя граница сложности. Оптимальные алгоритмы
Согласно лемме . сумма высот всех листьев должна быть не
меньше, чем n! log2 n!. Отсюда математическое ожидание числа сравнений не меньше, чем log2 n!.
Доказанные ранее теорема . и предложение . справедливы
в равной мере и для сложности в худшем случае, и для сложности
в среднем. Принимая это во внимание, мы получаем следствие предложения .:
Сортировка бинарными вставками и сортировка фон Неймана,
а также быстрая сортировка являются оптимальными по порядку
сложности в среднем по числу сравнений.
К этому списку позднее мы добавим и рекурсивную сортировку слияниями. Наиболее же существенно упоминание в этом списке
быстрой сортировки. С одной стороны, как мы знали и раньше, эта
сортировка очень удобна и имеет низкую пространственную сложность, с другой — мы видим теперь, что и в смысле временной сложности в среднем эта сортировка в определенном смысле может быть
отнесена к наилучшим.
Можно показать существование оптимальной в среднем сортировки: для каждого фиксированного n в множестве всех деревьев сортировки массивов длины n можно рассмотреть подмножество деревьев,
имеющих наименьшую сумму H высот всех листьев (тогда и H /n!
будет иметь наименьшее значение), и взять какое-нибудь из деревьев этого подмножества. Определяя сортировку этим способом для
всех n мы получаем оптимальную сортировку. Для любой оптимальной в среднем сортировки выполнено
¯T¯opt (n) ∼ log2 n! ∼ n log2 n,
так как, например, мы имеем TvN (n) ∼ log2 n! и
TvN (n) ¾ ¯T¯vN (n) ¾ ¯T¯opt (n) ¾ log2 n!.
В этом примере, как и во всем этом параграфе, мы не касаемся
рандомизированных алгоритмов, о которых будет говориться в § .
Как мы ранее наблюдали в некоторых примерах, рассмотрение
функции L, подобранной надлежащим образом, и изучение изменения ее значений в ходе выполнения алгоритма нередко позволяет
получать хорошие оценки (в частности, нижние границы) сложности
в худшем случае. Рассмотрение такого рода функций может приводить к цели и при исследовании сложности в среднем. В задаче 
функцию L можно определить как максимум значений компонент

§ . Нижняя граница сложности в среднем



инверсионного вектора перестановки. Эта функция является случайной величиной на Πn , при этом ∆ L = −1 на каждом шаге алгоритма.
В других ситуациях начальное значение L может определяться однозначно, тогда как ∆ L является случайной величиной. Сформулируем
теорему, полезную в этих ситуациях.
Теорема .. Пусть ξ1 , ξ2 , ... — последовательность неотрицательных случайных величин на некотором вероятностном пространстве. Пусть числовая последовательность h1 , h2 , ... такова, что для
каждого k ¾ 1 выполнено E(ξk |ξ1 , ξ2 , ..., ξk−1 ) ¶ hk при всех значениях
ξ1 , ξ2 , ..., ξk−1 . Зафиксируем неотрицательное число q и введем целочисленную случайную величину
§
n
ª
X
τ = min n:
ξk ¾ q .
k =1

Пусть τ < ∞ всюду на рассматриваемом вероятностном пространP

τ
стве. Тогда E
hk ¾ q.
k =1

Доказательство приведено в приложении E.
Для того чтобы воспользоваться этой теоремой, можно опять попытаться определить некоторую неотрицательную функцию L, отражающую степень «недорешенности» рассматриваемой задачи: значение L равно нулю, если алгоритм доработал до конца и задача решена. Считаем, что всем входам фиксированного размера сопоставляется одно и то же значение функции L. После выбора такой функции L мы должны показать, что последовательность величин E(−∆ L),
соответствующих идущим друг за другом этапам алгоритма, ограничена сверху некоторой известной числовой последовательностью
h1 , h2 , ...; тогда случайная величина τ, равная для данного входа общему количеству этапов, приводящих к завершению алгоритма, таP

τ
кова, что E
hk ¾ q, где q — значение функции L, сопоставляеk =1

мое входам алгоритма рассматриваемого фиксированного размера.
Это неравенство можно использовать, чтобы оценить снизу значение
Eτ. Конечность величины τ следует из завершимости алгоритма для
любого входа.
Пример .. Вернемся к задаче одновременного выбора наибольшего и наименьшего элементов массива длины n, n ¾ 2, с помощью
сравнений (пример .). Вероятностным пространством здесь вновь
будем считать Πn . Каждая перестановка из Πn отражает, как обычно,

 Глава . Нижняя граница сложности. Оптимальные алгоритмы
взаимный порядок элементов исходного массива. Все перестановки
считаются равновероятными.
Чтобы воспользоваться теоремой ., мы полагаем, что случайные величины ξ1 , ξ2 , ... для произвольного алгоритма одновременного выбора наибольшего и наименьшего элементов равны значениям
−∆ L на последовательных шагах этого алгоритма, об определении
функции L будет сказано ниже. Значения ξ1 , ξ2 , ... зависят от конкретной перестановки из Πn , отражающей взаимный порядок элементов в исходном массиве. После того, как алгоритм закончил работу,
значения ξk при последующих значениях k равны нулю.
Предложение .. Функция


3
2
f (n) =
3
1
n−2+ ,
2
2n

 n − 2,

если n четно,
(.)
если n нечетно,

является нижней границей сложности в среднем алгоритмов одновременного выбора наибольшего и наименьшего элементов массива длины n, n ¾ 2, c помощью сравнений.
Доказательство. Вновь обратимся к множествам A, B, C, D, к рассмотренным в доказательстве предложения . типам AA, AB, ..., DD
сравнений, количествам a, b, c, d элементов множеств A, B, C, D и функ3
ции L(a, b, c, d) = a + b + c − 2 (равенство L = 0 является необходимым
2
и достаточным условием того, что искомые элементы найдены).
Пусть в процессе выбора наибольшего и наименьшего элементов
массива уже произведены некоторые сравнения элементов этого массива. При каждом из этих сравнений получался некоторый результат
«истина» или «ложь», и эти результаты нам известны. Если процесс
выбора наибольшего и наименьшего элементов еще не завершен, то
следующим шагом вновь будет некоторое сравнение одного из типов
AA, AB, ..., DD. Сравнения AB, AC и BC представляют особый интерес,
так как можно бы предположить, что здесь получится E∆ L < −1. Но
на самом деле это неравенство не имеет места ни при одном из этих
трех типов сравнений.
Тип BC. Покажем невозможность такого выбора индексов i и j,
основанного только на результатах уже произведенных сравнений,
что xi ∈ B, x j ∈ C и при этом с вероятностью, не меньшей половины,
выполняется xi < x j .
Пусть сделан некий выбор индексов i и j, при котором xi ∈ B,
x j ∈ C. Рассмотрим множество M всех массивов y1 , y2 , ..., yn , которые

§ . Нижняя граница сложности в среднем



получаются перестановками элементов массива x1 , x2 , ..., xn и при
этом сравнения элементов с теми же самыми индексами, которые
использовались в уже произведенных сравнениях элементов массива
x1 , x2 , ..., xn , дают для массивов из M результаты, совпадающие с полученными для x1 , x2 , ..., xn . Представим множество M в виде объединения двух непересекающихся подмножеств M1 и M2 , где в M1 входят те массивы, для которых yi < y j , а в M2 — те, для которых y j < yi .
Покажем, что в M1 больше элементов, чем в M2 . Операция обмена
yi ↔ y j определяет взаимно однозначное отображение на себя множества всех массивов, которые получаются перестановками элементов массива x1 , x2 , ..., xn . Обратным к этому отображению является
оно само. В силу определения множеств B и C это отображение переводит элементы множества M1 в элементы множества M2 . Следовательно, в M1 элементов не больше, чем в M2 . Но в M2 найдется массив, который при этом отображении не переходит в массив из M1 и,
более того, вообще покидает множество M (чтобы убедиться в этом,
достаточно заметить, что в M2 имеется такой массив y1 , y2 , ..., yn , для
которого y j = min{ y1 , y2 , ..., yn }). Поэтому в M1 элементов меньше,
чем в M2 . Если m1 , m2 обозначают количества элементов множеств
M1 и M2 , то имеем
m2
m1
<
m1 + m2

и, следовательно,

m1 + m2

m1
1
< .
m1 + m2
2

Таким образом, вероятность того, что i-й элемент меньше j-го, есть
1
− ǫ , ǫ > 0. Получаем
2


1
E∆ L = −2 − ǫ = −1 + 2ǫ > −1.
2

Тип AB. Аналогично предыдущему можно показать, что при любом способе выбора индексов таких, что xi ∈ A, x j ∈ B, вероятность
1

выполнения неравенства xi > x j есть − ǫ , ǫ > 0. Получаем
2




3 1
1 1
E∆ L = −
−ǫ −
+ ǫ = −1 + ǫ > −1.
2 2

2 2

Тип AC. Рассматривается аналогично типу AB.
В дальнейшем будет полезна оценка ǫ для сравнений типов AB
и AC. Рассмотрим для определенности AB. Очевидно, что чем больше
сравнений к рассматриваемому моменту прошел элемент x j ∈ B, тем
меньше вероятность того, что элемент xi ∈ A окажется больше него.

 Глава . Нижняя граница сложности. Оптимальные алгоритмы
Наибольшая же вероятность получится в случае, когда x j сравнивался только с одним элементом, например с x s , и x s — это наименьший
элемент исходного массива. Вычислим вероятность, с которой в этом
случае xi > x j . Итак, если упорядочить все элементы, кроме xi , x j , то
x s окажется наименьшим (первым). Общее число способов, которыми
к этой упорядоченной совокупности можно добавить xi , x j , с учетом
x s < x j равно n(n − 2) (для добавления x j существует n − 2 способа, за 
n
тем добавляем xi , и для этого существует n способов). Из них
−1
2
соответствуют неравенству xi < x j (возможен любой выбор двух среди
n мест, кроме двух первых). Интересующая нас вероятность равна
n(n − 2) −

n
+1
2

n(n − 2)

Это дает нам ǫ ¾

=

1
1
− .
2
2n

1
, и, таким образом,
2n

E∆ L ¾ −1 +

1
2n

для AB и AC. Если при четном n удастся обойтись сравнениями ти3
пов AA, BB, CC, то сравнений потребуется в точности n − 2. Если
2
n нечетно, то для решения задачи обязательно потребуется произвести хотя бы одно сравнение типа AB, AC или AD. Сравнение типа AD
1
1
дает ∆ L = − > −1 + .
2
2n
Можно убедиться и в том, что для сравнений типов AB и AC
1
выполняется E∆ L ¾ −1 + , если E∆ L рассматривается как матема2n
тическое ожидание при условии, что значения ∆ L для всех предыдущих сравнений, предписываемых алгоритмом, известны. Эти известные значения определяют некоторое событие V в вероятностном пространстве Πn . Событие V может быть представлено как сумма V1 + V2 + ... + Vl попарно несовместных событий, где каждое Vk
состоит из тех элементов Πn , для которых все предыдущие сравнения образуют некоторую фиксированную последовательность сравнений элементов с вполне определенными для данного k индексами, и при этом возникающие значения ∆ L совпадают с известными
1
для кажиз условия. В силу доказанного выше E(∆ L|Vk ) ¾ −1 +
2n
дого k ¶ l. Отсюда по формуле полного математического ожидания
1
E(∆ L|V) ¾ −1 + .
2n
τ
P
В сумме
hk , о которой идет речь в теореме ., мы можем полоk =1

жить hk = 1 для всех значений k, кроме какого-то одного значения k0 ,

§ . Нижняя граница сложности в среднем
для которого hk0 = 1 −

E



1
. Это дает нам
2n

X
τ
k =1


1
hk = E(τ − 1) + 1 − ,
2n

и с помощью следующего из теоремы . соотношения
X
τ

3
E
hk ¾ n − 2
2

k =1

мы находим

E(τ − 1) + 1 −

1
3
¾ n − 2.
2n
2

После упрощения получаем
3
2

Eτ ¾ n − 2 +

1
.
2n

Таким образом, все доказано и для четных, и для нечетных n.
Если существует алгоритм решения рассматриваемой задачи, который требует ровно (.) сравнений, то, по только что доказанному предложению, этот алгоритм является оптимальным в среднем по
числу сравнений. Укажем такой алгоритм. Если n четно, то действуем
в соответствии с алгоритмом, обсуждавшимся в примере .. Пусть
n = 2k + 1, k ¾ 0. Находим
mi = min{x2i−1 , x2i },

Mi = max{x2i−1 , x2i },

i = 1, 2, ..., k, и
m = min{m1 , m2 , ..., mk },
что потребует n − 2 сравнений. Без дополнительных затрат можно
найти s, 1 ¶ s ¶ 2k, такое, что m = m s . Далее сравниваем xn (т. е. x2k+1 )
c M s . Согласно рассуждениям, проведенным выше при анализе срав1
1
нений типа AB, вероятность того, что xn > M s , равна − . Если
2
2n
xn > M s , то результатом работы алгоритма будет
max{M1 , ..., M s−1, M s+1 , ..., Mk , xn },

m,

в противном случае —
max{M1 , M2 , ..., Mk },

min{m, xn }.

Среднее число сравнений при нечетном n равно


 


1
1
3
1
1
n−1
1
−
+2
+
+
−1 = n−2+ ,
(n − 2) +
2

что и требовалось.

2n

2

2n

2

2

2n

 Глава . Нижняя граница сложности. Оптимальные алгоритмы
Существует оптимальный в среднем алгоритм одновременного нахождения наибольшего и наименьшего элементов массива длины n,
n ¾ 2, с помощью сравнений. Этот алгоритм имеет сложность (.).
§ . Нижние границы сложности рандомизированных
алгоритмов. Принцип Яо
Этот параграф начнем с формулировки и обсуждения одного факта из
теории игр. С произвольной квадратной числовой матрицей M = (mij )
порядка k связывается матричная игра двух игроков, которых мы назовем I и J. Один раунд игры состоит в том, что I и J независимо
друг от друга называют соответственно целые i и j из диапазона от 1
до k, и после этого J выплачивает своему сопернику I сумму в mij
рублей (при mij < 0 сумма в −mij рублей выплачивается игроком I
игроку J). Стратегией называется вектор p = (p1 , p2 , ..., pk ) с вещественными неотрицательными компонентами, в сумме дающими единицу; стратегии (1, 0, ..., 0), (0, 1, ..., 0), ..., (0, 0, ..., 1) называются чистыми. Допустим, что игроки независимо избирают для себя некоторые стратегии — обозначим их соответственно p и q, — и затем в последовательных раундах игрок I называет число i с вероятностью pi ,
а игрок J называет число j с вероятностью q j . Математическое ожидание выигрыша игрока I равно, как нетрудно подсчитать,
XX
mij pi q j ,
i

j

эту величину мы будем обозначать M(p, q). Допустим также, что вместо проведения большого числа раундов игры каждый из игроков,
основываясь на известной матрице M, один раз выбирает, независимо от другого игрока, для себя некоторую стратегию и сообщает
ее судье, который по полученным от игроков стратегиям (векторам
p и q) вычисляет M(p, q), умножает его на количество предполагавшихся раундов и объявляет полученное число выигрышем игрока I.
Естественно, что игрок I заинтересован в нахождении такой стратегии, которая максимизирует M(p, q), а у игрока J цели прямо противоположные. Одна из теорем раздела теории игр, посвященного
матричным играм  , утверждает, что для игроков существуют оптимальные стратегии p ∗ , q ∗ такие, что M(p ∗ , q ∗ ) является одновременно
значением величин
max min M(p, q) и
p



q

См., например, [, теорема .].

min max M(p, q).
q

p

§ . Нижние границы сложности рандомизированных алгоритмов 
В дальнейшем нас не будут интересовать оптимальные стратегии, однако равенство
max min M(p, q) = min max M(p, q)
q

p

q

p

(.)

окажется для нас очень ценным.
При фиксированной стратегии p значение min M(p, q) равно миq
нимальному значению среди
X
X
X
mi1 pi ,
mi2 pi , ...,
mik pi ,
i

т. е. min
j

P

i

i

mij pi (в качестве стратегии q, на которой достигается ми-

i

нимум, выступает некоторая
чистая стратегия). Аналогичным обP
разом max M(p, q) = max mij q j . Это позволяет переписать равенp

i

ство (.) в виде
max min
p

j

j

X
i

mij pi = min max
q

i

X

mij q j ,

(.)

j

откуда следует, что для любых стратегий p = (p1 , p2 , ..., pk ) и q = (q1 ,
q2 , ..., qk ) выполнено
X
X
min
mij pi ¶ max
mij q j .
(.)
j

i

i

j

То, что исходная матрица квадратная, не играло никакой роли в выводе последней формулы, каждая из переменных i и j могла пробегать свое множество значений. Можно даже не нумеровать строки
и столбцы исходной матрицы, а дать им какие-то имена. Для матриц с такого рода именованием строк и столбцов чаще используют
название таблица.
Вернемся теперь от матричных игр к анализу сложности алгоритмов. Пусть имеется конечное множество A алгоритмов решения
некоторой задачи и конечное множество X входов фиксированного
размера, и для них составлена числовая таблица, элементы которой
проиндексированы элементами множества X (первый индекс) и множества A (второй индекс). В качестве элемента таблицы с индексами x, A берется величина затрат (например, временных) C A (x). Если
рассмотреть какие-либо распределения вероятностей на X и A , то
в силу (.) будем иметь
min E X C A (x) ¶ max EA C A (x),
A∈A

x∈ X

(.)

 Глава . Нижняя граница сложности. Оптимальные алгоритмы
где символами E X и EA обозначены математические ожидания, связанные с заданными (произвольными) распределениями вероятностей на X и A .
Будем рассматривать рандомизированный алгоритм как конечное
множество детерминированных («обычных») алгоритмов с некоторым распределением вероятностей на нем, — о возможности такого
взгляда на рандомизированные алгоритмы говорилось в конце § .
Тогда можно определить усредненные затраты этого рандомизированного алгоритма для каждого входа. Фиксируя размер входа, мы
можем рассмотреть сложность в худшем случае такого рандомизированного алгоритма A как максимум усредненных затрат по входам данного размера, эта сложность записана в правой части неравенства (.). Левая же часть этого неравенства может быть интерпретирована как наименьшая из сложностей в среднем алгоритмов
класса A , для определения этой сложности используется некоторое
распределение вероятностей на X .
Мы приходим к принципу, предложенному А. Яо.
Теорема . (принцип Яо). Пусть для размера входа зафиксировано некоторое значение n, и пусть все входы размера n образуют
конечное множество X , на котором задано некоторое распределение
вероятностей. Пусть A — конечное множество алгоритмов, применимых к элементам множества X , и пусть на A тоже задано некоторое распределение вероятностей. Множество A с этим распределением можно рассматривать как единый рандомизированный алгоритм, считая его сложностью T(n) усредненные затраты в худшем
случае. Тогда, если найти некоторую нижнюю границу f (n) сложностей в среднем (в соответствии с данным распределением вероятностей на множестве X входов размера n) всех детерминированных
алгоритмов класса A , то, независимо от конкретного вида распределений на X и A , будет выполняться неравенство f (n) ¶ T(n).
Пример .. Рассмотрим произвольную рандомизированную сортировку массивов фиксированной длины n, которую, по крайней мере теоретически, можно задать как конечное множество детерминированных алгоритмов сортировки массивов длины n с приписанными этим детерминированным алгоритмам вероятностями, в сумме
дающими единицу. (Предполагаем, что это вероятностное пространство алгоритмов не зависит от конкретного входа, т. е. конкретного массива длины n.) Тогда в соответствии с принципом Яо сложность этой рандомизированной сортировки не может быть меньше
чем log2 n!, так как при равномерном распределении вероятностей

Задачи



на Πn для сложности в среднем детерминированных алгоритмов сортировки мы имеем в силу предложения . нижнюю границу log2 n!
при любом n. 
Задачи
. Для обсуждавшихся в задаче  алгоритмов сортировки вагонов функция 3n − 1 является нижней границей их сложности, откуда
следует, что тот алгоритм, который требуется указать в задаче , является оптимальным в рассматриваемом классе.
. Для сложности класса обсуждавшихся в задаче  алгоритмов
поиска двери в стене функция n является асимптотической нижней
границей, откуда следует, что тот алгоритм, который требуется указать в задаче , является оптимальным по порядку сложности в рассматриваемом классе.
. (Продолжение предыдущей задачи.) Для поиска двери можно указать класс A алгоритмов, каждый из которых определяется
некоторым целым k ¾ 2: путник делает k шагов вправо, и если дверь
не найдена, то возвращается назад и делает k шагов влево, и опять
возвращается назад, если дверь не найдена; затем делает k 2 шагов
вправо, возвращаясь назад в случае неуспеха, затем k 2 шагов влево и т. д. Таким образом, A = {A2 , A3 , ...}, и для сложности по числу
шагов имеем TAk (n) = 3n, если k = n, и TAk (n) > 3n, если k 6= n. Как
следствие, в классе A нет оптимального алгоритма, но каждый алгоритм из этого класса является оптимальным в нем по порядку сложности.
Указание. Пусть m таково, что km−1 < n ¶ km . Возможно, что потребуется
число шагов, равное 2(k + k2 + ... + km ) + 2(k + k2 + ... + km−1 ) + n.

. Нарисовать дерево быстрой сортировки для случая n = 3, считая, что первый элемент всегда выбирается в качестве разбивающего.
. Дать другое доказательство предложения .. Рассмотреть
последовательности из нулей и единиц, соответствующие результатам всех проводимых сравнений в процессе применения сортировки
к массивам длины n (каждому массиву сопоставляется своя последовательность).
Указание. Если некоторый алгоритм сортировки требует не более h(n)
сравнений, то длина каждой из последовательностей не превосходит h(n),
и общее число последовательностей не превосходит 2h(n) .


Дополнительные примеры применения принципа Яо можно найти в [, гл. ].

 Глава . Нижняя граница сложности. Оптимальные алгоритмы
. Аналогично предыдущей задаче, дать другое доказательство
предложения ..
. Как уже отмечалось (со ссылкой на приложение D), n является
нижней границей сложности как по числу аддитивных операций, так
и по числу умножений для класса алгоритмов, вычисляющих значение полинома an x n + ... + a1 x + a0 с помощью операций сложения, вычитания и умножения (при рассмотрении числа n как размера входа
x, a0 , a1 , ..., an ). Означает ли это, что при вычислении любого фиксированного полинома p(x) степени n при заданном значении переменной x потребуется не менее n аддитивных операций и n умножений?
Указать такие нижние границы сложности (по числу аддитивных операций и по числу операций умножения) алгоритмов вычисления поn  
P
n
линома
x k , которые растут при n → ∞ существенно медленнее,
k =0

k

чем n.
. Имеется плитка шоколада размера k × l клеток, которую требуется разломать на отдельные клетки. Каждый разлом применяется к одному куску плитки и производится по прямой линии. Затраты каждого алгоритма решения этой задачи применительно к конкретной плитке измеряются числом потребовавшихся разломов. Указать оптимальный алгоритм решения этой задачи и выписать его
сложность. Числа k, l считаются параметрами размера входа алгоритмов.
. Если условно изобразить элементы массива длины n точками
на плоскости, соединяя отрезками те из них, которые непосредственно сравнивались в процессе некоторого алгоритма поиска, — скажем,
поиска наименьшего элемента, одновременного поиска наибольшего
и наименьшего элементов, поиска
l m k-го по величине элемента (в частn
-го элемента), — то получающийся
ности, поиска медианы, т. е.
2
граф должен быть связным, иначе мы бы ничего не могли сказать
о том, как соотносятся между собой элементы из разных компонент.
Показать, что для всех алгоритмов поиска, сопоставляющих указанным (неявным) образом связные графы конкретным массивам, n − 1
является нижней границей сложности по числу сравнений (как в худшем случае, так и в среднем); в частности, это верно для алгоритмов
поиска медианы.
Указание. Дерево с n вершинами имеет n − 1 ребро.

. Рассмотрим класс алгоритмов поиска k первых (меньших) по
величине элементов массива без установления порядка между найденными элементами и класс алгоритмов поиска k-го по величине

Задачи



элемента. Как обычно, имеется в виду поиск с помощью сравнений.
Доказать, что любая нижняя граница сложности по числу сравнений
алгоритмов первого класса является нижней границей и для второго
класса.
. Дать доказательство предложения ., построенное по той же
схеме, что и доказательство предложения ..
Указание. Рассмотреть тройки множеств (A, B, C), включая в A на каждом
этапе алгоритма все те элементы, которые еще не сравнивались, в B — все
те, которые участвовали в сравнениях и всегда оказывались меньшими,
в C — все те, которые участвовали в сравнениях и в некоторых оказывались
бо́льшими.

. Доказать содержащееся в доказательстве предложения . утверждение, что после первого сравнения постоянно будет выполнено
b ¾ 1, c ¾ 1.
. В классе алгоритмов вычисления an с помощью умножений (a
фиксировано, n ∈ N) при рассмотрении n в качестве размера входа
существует оптимальный алгоритм. То же самое — при рассмотрении
m = λ(n) в качестве размера входа.
. Бинарный алгоритм возведения в степень n не является оптимальным по числу умножений и при использовании m = λ(n) в качестве размера входа.
Указание. Рассмотреть алгоритм, который для всех n 6= 15 работает как
бинарный алгоритм, а при n = 15 — несколько быстрее (см. задачу ), и показать, что такой алгоритм при m = 4 имеет сложность меньшую, чем бинарный.

. (Продолжение задачи .) Является ли оптимальным по порядку сложности бинарный алгоритм возведения в степень n при использовании m = λ(n) в качестве размера входа?
. Рассмотренный в задаче  алгоритм поиска фальшивой монеты, требующий в худшем случае не более ⌈log3 n⌉ взвешиваний,
является оптимальным для худшего случая.
. Нижней границей сложности любого алгоритма деления отрезка на n равных частей с помощью циркуля и линейки (см. задачу ) при рассмотрении числа n в качестве размера входа является,
n−1
.
в частности,
2
. Отсутствие указания основания логарифма в (.) является
корректным.
. Функция log2 (n + 1) является нижней границей сложности в
среднем алгоритмов поиска места элемента в упорядоченном массиве

 Глава . Нижняя граница сложности. Оптимальные алгоритмы
длины n с помощью сравнений (считаем, что в диапазоне от 1 до
1
).
n + 1 место может быть любым с одинаковой вероятностью
n+1

Указание. Для доказательства воспользоваться предложением ..

. (Продолжение предыдущей задачи.) Алгоритм бинарного поиска является оптимальным в среднем по порядку сложности в классе
алгоритмов поиска места элемента с помощью сравнений.
. Алгоритм, описанный в задаче , является оптимальным как
в худшем случае, так и в среднем.
. Пусть ¯T¯QS (n) и ¯T¯opt (n) — сложности в среднем быстрой сортировки и оптимальной в среднем сортировки. Верно ли, что ¯T¯QS (n) ∼
∼¯
T¯opt (n)? Если нет, то можно ли подобрать константу c такую, что
¯T¯Q (n) ∼ c¯T¯opt (n)?
. Утверждение теоремы . перестает быть верным, если его
изменить, удалив условие, что τ < ∞ всюду на рассматриваемом вероятностном пространстве: при выполнении всех остальных условий
∞
P
может оказаться, что τ = ∞ при том, что
hk имеет конечное значение.

k =1

Указание. Рассмотреть постоянные величины ξk =

1
, k = 1, 2, ... ,
k(k + 1)

взяв hk = ξk для всех k; при любом q ¾ 1 получается противоречие с измененным утверждением. 

. Функция log2 (n + 1) является нижней границей сложности рандомизированных алгоритмов поиска места элемента в упорядоченном массиве длины n с помощью сравнений. (Предполагается, что
каждый из рассматриваемых рандомизированных алгоритмов может
быть задан как конечное множество детерминированных алгоритмов
поиска места элемента в упорядоченном массиве длины n, с приписанными этим детерминированным алгоритмам вероятностями,
в сумме дающими единицу; при этом такое вероятностное пространство алгоритмов не должно зависеть от конкретного входа размера n.)



Эта задача сообщена автору А. В. Бернштейном.

Глава 

Битовая сложность

§ . Битовые операции
Каждый алгоритм строится на основе некоторого фиксированного
набора базовых операций, и, согласно определениям из § , алгебраическая сложность алгоритма рассматривается при допущении, что
затратность операций не зависит от размеров операндов. С позиций
компьютерной арифметики это допущение вполне приемлемо, если
каждый из операндов умещается в одном слове памяти. Но оно перестает быть приемлемым, если разрешаются операнды любой длины
и вычисления проводятся в рамках арифметики многократной точности (арифметики длинных чисел). Здесь анализ сложности должен
исходить из других принципов.
Приемлемой является, например, следующая модель как система допущений, принимаемых нами при анализе алгоритмов. Число
представляется набором бит, являющихся содержимым его двоичных
разрядов (знак числа — тоже бит, например, обычно знаки + и −
изображаются соответственно нулем и единицей), и все арифметические операции сводятся, в конечном счете, к битовым операциям. В качестве битовых операций могут выступать булевы операции
∨, ∧, ¬ (другая нотация: or, and, not) при интерпретации 1 = «истина»,
0 = «ложь» встречающихся бит; эти операции считаются равнозатратными. Все биты, участвующие в записи числа, считаются равнодоступными.
Можно смотреть на все это так, что ячейки памяти машины содержат по одному биту каждая, а в остальном действует принцип
РАМ — ячеек бесконечно много и они в любой момент равнодоступны. Это — битовая модель вычислений (соответствующее сокращение
БМ может расшифровываться как «битовая модель» и как «битовая
машина»).
Для анализа сложности с использованием БМ нет необходимости
переписывать алгоритмы, детализируя их до уровня битовых опера-



Глава . Битовая сложность

ций. Вместо этого можно рассматривать привлекаемые алгоритмом
базовые арифметические операции как основанные на битовых вычислениях процедуры, полагая временные и пространственные затраты алгоритма равными числу затрачиваемых битовых операций и,
соответственно, требующихся дополнительных бит памяти. В качестве размера входа часто рассматривается либо суммарная битовая
длина всего входа (всех входных данных), либо максимум этих длин.
В некоторых случаях вместо битовых длин целых чисел берутся сами
эти числа. Возможно и использование нескольких параметров размера входа.
Определение .. Пусть выбран какой-то размер входа. Рассмотрение каждой из базовых операций алгоритма A как процедуры, основанной на битовых вычислениях, и измерение затрат на выполнение A для каждого конкретного входа в битовых операциях или,
соответственно, в хранимых дополнительных битах, приводит к битовой сложности (временной или пространственной) алгоритма A.
Для нахождения битовой сложности какого-либо алгоритма, построенного на основных арифметических операциях над целыми числами, полезно знать битовые сложности самих основных арифметических операций. Мы исследуем школьные алгоритмы сложения, вычитания, умножения и деления «столбиком» неотрицательных целых
чисел в двоичной системе.
В процессе сложения «столбиком» мы шаг за шагом вычисляем
двоичные цифры суммы, продвигаясь от младших разрядов к старшим. При этом в старшие разряды каждый раз переносится 0 или 1.
Таким образом, на каждом шаге мы работаем с тремя битами (на начальном шаге, когда рассматриваются самые младшие разряды, бит
переноса полагаем равным нулю). Для сложения многозначных чисел нам нужны две битовые процедуры трех аргументов (два аргумента — это цифры одноименных разрядов двух данных чисел, третий — это бит переноса из предшествующих разрядов), одна из процедур дает цифру соответствующего разряда суммы, вторая — новый
бит переноса в старшие разряды. Мы не станем рассматривать этот
вопрос более подробно, потому что и без деталей ясно, что затраты
по построению каждого разряда суммы ограничены сверху некоторой
константой.
Алгоритм сложения «столбиком» будем обозначать буквами Add,
от английского слова addition — сложение. Обозначим через a и b
операнды алгоритма (a, b ∈ N+ ), через m1 , m2 — их битовые длины:
m1 = λ(a), m2 = λ(b).

§ . Битовые операции



T
Лемма .. Количество CAdd
(a, b) битовых операций, затрачиваемых при сложении a и b «столбиком», удовлетворяет неравенствам
T
(a, b) ¶ c(max{m1 , m2 } + 1),
min{m1 , m2 } ¶ CAdd

(.)

где c — некоторая положительная константа.
Доказательство. Принимая во внимание замечание относительно ограниченности затрат на построение каждого разряда суммы,
а также то, что битовая длина суммы a + b не может превышать
T
max{m1 , m2 } + 1, получаем оценку CAdd
(a, b) ¶ c(max{m1 , m2 } + 1).
′
Пусть m = min{m1 , m2 }. Очевидно, что m′ младших цифр суммы a + b
получаются выполнением битовых операций над соответствующими
цифрами обоих слагаемых и битами переноса (в то время как часть
цифр старших разрядов большего из слагаемых может быть просто
перенесена в старшие разряды суммы). Это дает нам неравенство
T
min{m1 , m2 } ¶ CAdd
(a, b).
В дальнейшем будем полагать
m = max{m1 , m2 }.

(.)

∗
Предложение .. Пусть TAdd
(m) — сложность по числу битовых операций алгоритма сложения «столбиком» при использовании m
∗
в качестве размера входа. Тогда TAdd
(m) = Θ(m).

Доказательство. При фиксированном m мы можем выбрать a и b
так, что m1 = m2 = m, тогда min{m1 , m2 } = max{m1 , m2 } = m; далее
применяем лемму ..
Алгоритм сложения «столбиком» позволяет получать сумму a и b
на месте максимального из этих двух чисел, в этом случае для битовой пространственной сложности имеем S∗Add (m) = O(1). Если для
суммы чисел используется дополнительное место (чтобы не изменять
данные слагаемые), то, соответственно, S∗Add (m) = m + O(1).
Утверждения леммы . и предложения . верны, как легко
убедиться, и для операции вычитания (при вычитании «столбиком»
в старших разрядах занимается 0 или 1; битовая длина разности не
превосходит m).
∗
Формула TAdd
(m) = Θ(m) говорит о том, что алгоритм сложения
«столбиком» при рассмотрении m в качестве размера входа является
оптимальным по порядку битовой сложности: мы не можем игнорировать содержимое разрядов, и поэтому m является нижней границей битовой сложности алгоритмов сложения. Для алгоритмов умножения и деления «столбиком» в дальнейшем будет показано, что их



Глава . Битовая сложность

сложность имеет порядок m2 , и в этой ситуации уже ниоткуда не
следует, что не может существовать алгоритмов с лучшей асимптотикой сложности, и такие алгоритмы действительно существуют (мы
об этом еще будем говорить). Поэтому умножение и деление «столбиком» мы будем называть, как это делается в некоторых книгах, наивным умножением и делением соответственно, используя обозначения
NM и ND (от английских слов naive multiplication/division — наивное
умножение/деление). Сложение «столбиком» будем просто называть
сложением.
Пример .. Допустим, что для умножения двух целых положительных чисел a и b мы используем сложения:
a + a, (a + a) + a, ..., (a| + {z
... + }a) + a.

(.)

b −1

Исследуем битовую сложность такого «сверхнаивного» умножения,
считая m размером входа. В силу леммы . при m1 = m2 = m на
каждое сложение уйдет не менее m битовых операций. Учитывая,
что b > 2m−1 , получаем для исследуемой сложности оценку Ω(2m m).
С другой стороны, ab < 22m , поэтому результат каждого шага в (.)
имеет не превосходящую 2m битовую длину. Это означает, что число битовых операций на каждом из шагов не превосходит c · 2m, где
c — константа. Отсюда получаем оценку O(2m m), и в итоге — оценку
Θ(2m m).
Наряду с размером входа (.) часто рассматривают два параметра m1 , m2 размера входа.
Предложение .. Если рассмотреть два параметра m1 = λ(a),
∗∗
m2 = λ(b) размера входа, то битовая сложность TAdd
(m1 , m2 ) алгоритма сложения будет допускать оценку Θ(max{m1 , m2 }).
Доказательство. Пусть, например, max{m1 , m2 } = m1 . Тогда оцен∗∗
ка TAdd
(m1 , m2 ) = Ω(max{m1 , m2 }) подтверждается наличием входа a =
m1
∗∗
= 2 − 1, b = 2m2 − 1. Оценка же TAdd
(m1 , m2 ) = O(max{m1 , m2 }) следует из леммы ..
Битовая сложность рассматривается не только в связи с арифметическими задачами. Например, булевы матрицы смежности, которые
служат одним из стандартных средств представления графов без кратных ребер, являются битовыми матрицами, и целому ряду алгоритмов решения задач на графах естественным образом сопоставляется
битовая сложность. Об этом будет идти разговор в § . Но прежде,

§ . Наивная арифметика: умножение



в §  и , мы займемся битовой сложностью наивного умножения
и деления.
Еще одно замечание в заключение этого параграфа. Битовый анализ может учесть мельчайшие затраты, связанные с выполнением алгоритма. Вопрос в том, нужен ли настолько детализированный подход, коль скоро компьютеры выполняют операции над основными
структурами данных на уровне слов, длина же слова — это, как правило,  бита. В связи с этим иногда вместо битовой рассматривается
так называемая словесная сложность  . Но принципиальной разницы
между битовой и словесной сложностью нет. Можно сказать так, что
битовая сложность предполагает использование системы счисления
с основанием 2, а словесная — с основанием 64. Анализ словесной
сложности не является, в сравнении с анализом битовой сложности,
ни более легким, ни более информативным.
§ . Наивная арифметика: умножение
∗
Предложение .. Пусть TNM
(m) — временная битовая сложность наивного умножения при использовании m в качестве размера
∗∗
входа, а TNM
(m1 , m2 ) — временная битовая сложность этого же алгоритма при использовании m1 , m2 в качестве двух параметров размера
входа. Тогда
∗
TNM
(m) = Θ(m2 ),

∗∗
TNM
(m1 , m2 ) = Θ(m1 m2 ).

(.)

Доказательство. Затраты наивного умножения a на b связаны с
суммированием m2 чисел n1 , n2 , ..., nm2 , где каждое ni равно 0 или
a · 2i−1 в зависимости от соответствующей цифры в двоичной записи b. Несложной индукцией доказывается, что для si = n1 + n2 + ...
... + ni , i = 1, 2, ..., m2 , выполнено λ(si ) ¶ m1 + i. Если ni+1 6= 0, то последние i цифр числа ni+1 суть нули, и при вычислении si+1 = si + ni+1
мы не притрагиваемся к этим цифрам, а преобразуем si в si+1 сложением двух чисел, первое из которых образовано всеми разрядами
числа si , кроме i последних (согласно сказанному, битовая длина этого числа не превосходит m1 ), второе же слагаемое есть a, и его битовая длина равна m1 . Число битовых операций, требующихся для
преобразования si в si+1 , не превосходит c(m1 + 1) для некоторой положительной константы c. В том случае, когда все цифры числа b
равны 1, это число при любом i не меньше, чем m1 , по лемме ..


См., например, книгу []. В литературе на английском языке, в частности в книге [], используется термин «word complexity».



Глава . Битовая сложность

Поэтому битовые затраты, связанные с наивным умножением a на b,
не превосходят c(m1 + 1)m2 , а при b = 2m2 − 1 (двоичная запись этого b состоит только из единиц) затраты не меньше, чем m1 m2 . Это
∗∗
дает оценку TNM
(m1 , m2 ) = Θ(m1 m2 ).
Рассмотрим теперь m как размер входа. Так как m1 ¶ m и m2 ¶ m,
∗
то затраты не превосходят c(m + 1)m, это дает оценку TNM
(m) = O(m2).
m
С другой стороны, если m1 = m2 = m и a = b = 2 − 1, то затраты не
∗
могут быть меньше, чем m2 , и, следовательно, TNM
(m) = Ω(m2 ). Таким
∗
2
образом, TNM (m) = Θ(m ).
Для пространственной битовой сложности наивного умножения
мы имеем, очевидно, оценки
S∗NM (m) = 2m + O(1),

S∗∗
NM (m1 , m2 ) = m1 + m2 + O(1).

Обсудим переход от параметров m1 , m2 размера входа к параметрам a, b (можно считать, что и к параметрам log a, log b — между a, b
и log a, log b в этом смысле нет принципиальной разницы, так как
одни параметры однозначно определяют другие; в то же время мы
не можем восстановить a, b по ⌈log2 (a + 1)⌉, ⌈log2 (b + 1)⌉).
Для перехода в верхних оценках сложности от λ(k) к log2 k, k ∈
∈ N∗ , часто оказывается удобным простое неравенство ⌈log2 (k + 1)⌉ ¶
¶ 2 log2 k, справедливое для всех k ¾ 2:
⌈log2 (k + 1)⌉ = ⌊log2 k ⌋ + 1 ¶ log2 k + 1 ¶ 2 log2 k.

Поэтому, например,
m1 ¶ 2 log2 a,

m2 ¶ 2 log2 b

и
m1 m2 ¶ 4 log2 a log2 b

(.)

для всех a, b ¾ 2. Имеем для достаточно больших m1 , m2 и некоторой
положительной константы c
T
∗∗
CNM
(a, b) ¶ TNM
(m1 , m2 ) ¶ cm1 m2 ¶ 4c log2 a log2 b.
T
Мы можем написать CNM
(a, b) = O(log a log b), считая, что выражение
под знаком O рассматривается как функция двух переменных a, b,
при этом a, b → ∞; считаем также, что логарифмы имеют общее основание (подобные предположения будут подразумеваться и в дальнейшем). Остается заметить, что битовая временная сложность при
использовании самих a, b в качестве параметров размера входа совпадает с битовыми временными затратами. Это позволяет получить
∗∗
из оценки TNM
(m1 , m2 ) = O(m1 m2 ) оценку TNM (a, b) = O(log a log b) для

§ . Наивная арифметика: умножение



временной битовой сложности при использовании двух параметров
размера входа a, b. Итак:
При использовании самих положительных целых a, b в качестве
параметров размера входа сложность наивного умножения a на b по
числу битовых операций допускает оценку O(log a log b).
Выше наивное умножение (умножение «столбиком») понималось
так, что если какая-то цифра числа b равна нулю, то, несмотря на
это, построение соответствующих ni и si требует не менее m1 битовых операций. При таком взгляде сложность будет величиной
Θ(log a log b). Но можно считать, что в рассматриваемом случае битовые затраты на получение si не зависят от a и ограничены константой. Тогда оценка Ω(log a log b) места не имеет: если a = 2k1 , b = 2k2 ,
где k1 , k2 — положительные целые, то битовые затраты будут ограничены линейной функцией от k1 , k2 .
Пример .. Покажем, что битовая временная сложность алгоритма вычисления n! с помощью пошаговых наивных умножений
2 · 3, (2 · 3) · 4, ..., (2 · 3...(n − 1)) · n
при использовании n в качестве размера входа допускает верхнюю
оценку O((n log n)2 ). В силу предложения . и неравенства (.)
рассматриваемая сложность не превосходит cf (n), где c — некоторая
положительная константа, а значение f (n) равно
log2 2 log2 3 + log2 (2 · 3) log2 4 + ... + log2 (2 · 3...(n − 1)) log2 n.
Имеем
f (n) ¶ log2 (2 · 3...(n − 1))(log2 2 + log2 3 + ... + log2 n) ¶ log22 (n!).
Одним из следствий формулы Стирлинга является оценка log2 (n!) =
= O(n log n), откуда log22 (n!) = O((n log n)2 ), и f (n) = O((n log n)2 ).
Пример .. Мы упоминали о том, что для алгоритма, входом
которого является несколько целых чисел, можно в некоторых случаях определять размер входа как суммарную битовую длину всех этих
чисел. Предположим, что имеется несколько целых чисел a1 , a2 , ..., an ,
каждое из которых ¾ 2, и с помощью пошаговых наивных умножений
a1 a2 , (a1 a2 )a3 ,

...,

(a1 a2 ...an−1 )an

(.)

вычисляется произведение A = a1 a2 ...an . Пусть суммарная битовая
длина чисел равна M, и число M рассматривается как размер входа алгоритма (.). Покажем, что тогда битовая сложность этого



Глава . Битовая сложность

алгоритма допускает верхнюю оценку O(M 2 ), — примечательно, что
число n, т. е. общее количество сомножителей, в этой оценке не появляется.
В силу предложения . и неравенства (.) битовые затраты на
вычисление a1 , a2 , ...an не превосходит cF(a1 , a2 , ..., an ), где c — некоторая положительная константа, а значение F(a1 , a2 , ..., an ) равно
log2 a1 log2 a2 + log2 (a1 a2 ) log2 a3 + ... + log2 (a1 a2 ... an−1 ) log2 an
(использовано предположение, что a1 , a2 , ..., an ¾ 2). Мы легко получаем
F(a1 , a2 , ..., an ) ¶ log2 (a1 ... an−1 )(log2 a2 + ... + log2 an )
и
F(a1 , a2 , ..., an ) ¶ (log2 a1 + log2 a2 + ... + log2 an )2 .
Последнее неравенство позволяет перейти к рассмотрению M в качестве размера входа, так как, очевидно,
2
F(a1 , a2 , ..., an ) ¶ ⌈log2 (a1 + 1)⌉+⌈log2 (a2 + 1)⌉+ ...+⌈log2 (an + 1)⌉ = M 2 ,
что дает нам требуемое.
Доказанное утверждение справедливо и в том случае, когда среди a1 , a2 , ..., an имеются единицы, если считать, что умножение на 1
требует одной битовой операции. Если среди a1 , a2 , ..., an имеются
k единиц, то из M ¾ k следует (M − k)2 + k ¶ M 2 .
§ . Наивная арифметика: деление с остатком
Обратимся к наивному делению с остатком. Здесь мы считаем, что
m = m1 ¾ m2 .
∗
Предложение .. Пусть TND
(m) — сложность по числу битовых
операций наивного деления при использовании m в качестве разме∗∗
ра входа. Пусть TND
(m1 , m2 ) — сложность по числу битовых операций
этого же алгоритма при использовании m1 , m2 в качестве двух параметров размера входа. Тогда
∗
TND
(m) = Θ(m2 ),

∗∗
TND
(m1 , m2 ) = Θ((m1 − m2 + 1)m2 ).

(.)

Доказательство. Наивное деление a на b сводится к ряду вычитаний числа b, и в каждом вычитании битовая длина уменьшаемого либо равна, либо на единицу превосходит m2 . Битовые затраты на каждое такое вычитание не могут превзойти, как мы знаем, c(m2 + 1). Количество всех таких вычитаний не превосходит
∗∗
m1 − m2 + 1, откуда TND
(m1 , m2 ) = O((m1 − m2 + 1)(m2 + 1)) и, после

§ . Наивная арифметика: деление с остатком



∗∗
упрощения, TND
(m1 , m2 ) = O((m1 − m2 + 1)m2 ) (см. задачу ). С другой стороны, если, например, a = 2m1 − 1, b = 2m2 −1 , то число вычитаний равно m1 − m2 + 1, и, как следствие, битовые затраты на
наивное деление будут не меньше, чем (m1 − m2 + 1)m2 . Поэтому
∗∗
TND
(m1 , m2 ) = Θ((m1 − m2 + 1)m2 ).
∗
Оценка TND
(m) = O(m2) следует теперь из неравенства m2 ¾ m1 m2 ¾
¾ (m1 − m2 + 1)m2 . Если взять a = 2m − 1, b = 
2⌊m/2⌋j, тоk битовые
затраj k

m
m
+1
+1 ,
ты на наивное деление будут не меньше чем m −

2

∗
∗
и, как следствие, TND
(m) = Ω(m2 ). Получаем TND
(m) = Θ(m2 ).

2

∗∗
Мы не пишем TND
(m1 , m2 ) = Θ((m1 − m2 )m2 ) из-за возможности равенства m1 = m2 (из которого не следует, что a = b). Эта возможность
∗∗
указывает и на то, что неверно соотношение TND
(m1 , m2 ) = Θ(m1 m2 ).

Предложение .. При использовании самих положительных целых a, b, a ¾ b > 1, в качестве параметров размера входа, сложность
наивного деления a на b допускает оценку O(log a log b). При использовании a в качестве размера входа имеем оценку O(log2 a).
Доказательство. Как уже говорилось, число битовых операций,
требуемых наивным умножением, не превосходит произведения

c (⌊log2 a⌋ + 1) − (⌊log2 b⌋ + 1) + 1 (⌊log2 b⌋ + 1)
(c — положительная константа), которое не превосходит в свою очередь
c(log2 a − log2 b + 2)(log2 b + 1).
Каждое слагаемое, возникающее в результате раскрытия скобок в последнем выражении, есть O(log a log b) при a, b → ∞, a ¾ b. Отсюда
следует первая часть утверждения. Вторая часть следует из того, что
log2 a log2 b ¶ log22 a при a ¾ b.
Пример .. Пусть n и k — положительные целые числа, k ¾ 2,
заданные в двоичной системе счисления. Покажем, что при избрании n в качестве размера входа n, k (равно как и при избрании n, k
в качестве двух параметров размера этого входа) битовая сложность
обычного алгоритма построения k-ичной записи числа n с помощью
наивных делений с остатком допускает оценку O(log2 n).
В самом деле, при построении k-ичной записи n шаг за шагом
j q расk
сматриваются числа q0 , q1 , ..., qt , t = ⌊logk n⌋ + 1, где q0 = n, qi = i−1 ,
k
i = 1, 2, ..., t. Очевидно, что qi ¶ n, в силу чего общие затраты всех шагов для данных n и k допускают оценку O(log n log k logk n). Очевидно,
log k logk n = log n (например, log2 k logk n = log2 n), поэтому оценка для



Глава . Битовая сложность

затрат переписывается в виде O(log2 n); при указанных выше размерах
входа эта оценка является и оценкой сложности.
Вновь вернемся к обозначению m для битовой длины максимального из двух данных целых положительных чисел, и пусть m рассматривается как размер входа a, b алгоритмов умножения и деления
с остатком. Для сложностей наивного умножения и деления мы получили оценки Θ(m2 ), следствием которых являются нижние оценки
Ω(m2 ). Вместе с этим, для умножения и деления известны алгоритмы, сложности которых при m → ∞ растут существенно медленнее,
чем m2 : первый алгоритм такого рода для умножения был предложен
в  г. А. А. Карацубой (верхняя оценка O(mlog2 3 )), наилучшую из
известных к настоящему времени верхнюю асимптотическую оценку
битовой сложности O(m log m log log m) имеет алгоритм А. Шенхаге
и Ф. Штрассена. Существуют алгоритмы деления, сложность которых
допускает такие же оценки (см. задачу  к главе ). Алгоритм Карацубы будет рассмотрен нами в § , алгоритм Шенхаге—Штрассена
в этом курсе подробно не рассматривается; несколько слов о нем будет сказано в конце § .
Пример .. Исследуем битовую сложность алгоритма Евклида.
В качестве размера входа можно рассмотреть большее число a0 , но
ни в коем случае не a1 : если фиксировано a1 , то, неограниченно увеличивая a0 , мы будем неограниченно увеличивать битовые затраты,
связанные с первым делением с остатком (a0 на a1 ). Поэтому при выборе a1 в качестве размера входа битовая сложность этого алгоритма
тождественно равна бесконечности — здесь битовая сложность существенно отличается от алгебраической (т. е. в данном случае от сложности по числу делений). Можно считать a0 размером входа, а можно
рассмотреть два параметра a0 , a1 размера входа. Если m0 , m1 — битовые длины данных чисел a0 , a1 , то в качестве размера входа можно рассмотреть m = max{m0 , m1 } = m0 или же два параметра входа
m0 , m1 . В настоящем примере мы будем использовать m.
Прежде всего покажем, что для алгоритма Евклида
a i −1 = q i a i + a i +1 ,

i = 1, 2, ..., n,

an+1 = 0,

выполняется
a0 ¾ q1 q2 ...qn .

(.)

В самом деле,
a0 > q1 a1 ,

a1 > q2 a2 , ...,

a n −2 > q n −1 a n −1 ,

и получаем a0 ¾ q1 q2 ...qn an , откуда следует (.).

a n −1 = q n a n ,

§ . Наивная арифметика: деление с остатком



Для построения ai+1 делением ai−1 на ai с остатком требуется не
более c(⌊log2 qi ⌋ + 1)(⌊log2 ai ⌋ + 2) битовых операций, где c — положительная константа. Это дает общую оценку сверху
n
X
(⌊log2 qi ⌋ + 1)(⌊log2 ai ⌋ + 2),
c
i =1

при этом возможно, что некоторые из qi равны единице. Написанная
сумма не превосходит
n
X
c(⌊log2 a1 ⌋ + 2)
(⌊log2 qi ⌋ + 1).
i =1

При a1 > 1 выполнено ⌊log2 a1 ⌋ + 2 ¶ 3 log2 a1 и, как следствие,
n


n
X
X
c(⌊log2 a1 ⌋ + 1)
(⌊log2 qi ⌋ + 2) ¶ 3c(log2 a1 ) n +
log2 qi =
i =1

i =1

= 3c(log2 a1 )(n + log2 (q1 q2 ...qn )) ¶ 3c(log2 a1 )(n + log2 a0 ).

Как мы знаем, n ¶ 2 log2 a1 + 1; при a1 > 1, очевидно, можем написать n ¶ 3 log2 a1 . Это дает нам оценку сверху
3c(log2 a1 )(3 log2 a1 + log2 a0 )
для числа битовых операций при a1 > 1. Учитывая, что a0 ¾ a1 , мы
получаем отсюда следующее.
Количество битовых операций, затрачиваемых при применении
алгоритма Евклида к a0 , a1 , допускает оценку
O(log a0 log a1 )

(.)

и оценки O(log2 a0 ), O(m2 ), m = λ(a0 ).
Приведенные оценки получены в предположении, что для построения остатков используется наивное деление, имеющее квадратичную
сложность. Может ли быть так, что привлечение имеющего меньшую
битовую сложность алгоритма деления с остатком приведет к существенно меньшим битовым затратам алгоритма Евклида? Ответ отрицательный: нетрудно, например, показать, что если a0 берется в качестве размера входа, то для битовой сложности алгоритма Евклида
выполняется оценка Ω(log2 a0 ).
В самом деле, в примере . было показано, что для каждого a0 можно подобрать меньшее его a1 такое, что для числа делений
с остатком выполняется неравенство (.). Если обозначить это число делений через n, то будем иметь n = Ω(log a0 ), при этом
λ(a0 ), λ(a1 ), ..., λ(an )



Глава . Битовая сложность

является невозрастающей конечной последовательностью натуральных чисел, и в силу предложения . никакое значение не встречается
в ней более двух раз. Так как деление с остатком ai−1 на ai требует
не менее λ(ai ) битовых операций, то общее число битовых операций не j
можетkбыть меньше, чем 1 + 1 + 2 + 2 + ... + k + k = k(k + 1)
n+1
и n = Ω(log a0 ). Следовательно, общее число битовых
при k =
2

операций есть Ω(log2 a0 ).
Вместе с ранее установленной оценкой O(log2 a0 ) это дает оценку
Θ(log2 a0 ). Теорема . из §  приводит нас к оценке Θ(m2 ) для битовой сложности алгоритма Евклида при избрании битовой длины m
числа a0 в качестве размера входа. Итак:
Если алгоритм Евклида основывается на некотором алгоритме деления с остатком, битовые затраты которого применительно к делимому v и делителю w допускают верхнюю оценку O(log v log w),
то при рассмотрении большего входного числа a0 в качестве размера входа битовая сложность алгоритма Евклида допускает оценку
Θ(log2 a0 ). При рассмотрении m = λ(a0 ) в качестве размера входа имеем оценку Θ(m2 ).
Оказывается, что полученные оценки сохраняют силу и при рассмотрении расширенного алгоритма Евклида (пример .) — обстоятельство, имеющее большое значение для модулярной арифметики
(§ ).
Предложение .. Пусть расширенный алгоритм Евклида основывается на некоторых алгоритмах деления с остатком и умножения, битовые затраты каждого из которых применительно к целым
v и w допускают верхнюю оценку O(log v log w). Тогда, при рассмотрении большего входного числа a0 в качестве размера входа, битовая сложность расширенного алгоритма Евклида допускает оценку
Θ(log2 a0 ), а при рассмотрении битовой длины m большего числа a0
в качестве размера входа — оценку Θ(m2 ).
Доказательство. Исходя из вычислительных формул (.) и принимая во внимание (.), (.), мы заключаем, что битовые затраты, дополнительные к затратам собственно алгоритма Евклида («нерасширенного») на вычисление sn , tn , допускают оценку
O(log a0 log a1 ) — это обосновывается так же, как оценка (.). Поэтому сложность добавочной части расширенного алгоритма Евклида допускает оценку O(log2 a0 ) и, в силу теоремы ., оценку O(m2 ).
Остается заметить, что, например, Θ(m2 ) + O(m2 ) = Θ(m2 ).

§ . Модулярная арифметика



§ . Модулярная арифметика
Многие арифметические алгоритмы основываются на вычислениях
по некоторому целому модулю k, или, как говорят, на модулярных
вычислениях; соответственно, говорят о модулярной арифметике. Далее в этом параграфе мы считаем k фиксированным целым положительным числом.
Целые a и b называют сравнимыми по модулю k и пишут
a ≡ b (mod k),

(.)

если k | (a − b), т. е. если k является делителем разности a − b. Соотношение вида (.) называется сравнением. Изложение основ теории
сравнений можно найти в любом учебнике алгебры  . Мы приведем
основные элементарные факты этой теории, не останавливаясь на их
доказательстве:
(i) бинарное отношение сравнимости по модулю k является отношением эквивалентности на множестве целых чисел Z;
(ii) если
a1 ≡ b1 (mod k) и a2 ≡ b2 (mod k),
то
a1 ± a2 ≡ b1 ± b2 (mod k) и a1 a2 ≡ b1 b2 (mod k);
(iii) каждое целое число a сравнимо по модулю k в точности с одним целым числом из множества {0, 1, ..., k − 1}.
В силу (i) множество Z разбивается на классы эквивалентности по
модулю k (кратко: классы по модулю k), и, согласно (ii), эти классы
образуют кольцо, если считать, что сумма двух классов — это класс,
содержащий сумму каких-либо чисел, взятых по одному из складываемых классов, а произведение — это, соответственно, класс, содержащий произведение каких-либо чисел, взятых по одному из перемножаемых классов. Нулем этого кольца является класс, содержащий
число 0. Для введенного кольца используется обозначение Zk , его называют кольцом вычетов по модулю k (вычет — это в данном случае
другое название класса эквивалентности по модулю k).
Любое множество {a0 , a1 , ..., ak−1 } чисел, взятых по одному из каждого класса по модулю k, называется полной системой представителей по модулю k.
Множество
Ik = {0, 1, ..., k − 1},


См., например, [, § , ] и [, гл. , § , п. ].



Глава . Битовая сложность

указанное в (iii), называется канонической (или начальной) полной
системой представителей по модулю k. Иногда используется и симметричная полная система представителей:
m
j ko
nl
k
−k + 1
, ..., −1, 0, 1, ...,
,
Sk =
2

2

которая является симметричной (при условии игнорирования знаков) только при нечетном k: например, S3 = {−1, 0, 1} и S4 =
= {−1, 0, 1, 2}.
Пусть для изображения элементов кольца Zk используется система Ik . Операциям сложения и умножения в Zk соответствуют обычные сложение и умножение в Z с последующей заменой полученного
результата остатком от его деления на k. Если некоторому элементу кольца Zk соответствует число a системы Ik , то противоположному (обратному по сложению) элементу будет соответствовать число
k − a, если a 6= 0, и число 0, если a = 0.
Исследуем битовую сложность операций в кольце Zk . Будем считать размером входа битовую длину m числа k и ограничимся верхними асимптотическими оценками. Для операций сложения и нахождения противоположной величины имеем, очевидно, оценку O(m). Использование операции наивного умножения целых чисел приводит
к оценке O(m2 ) для сложности умножения в Zk . Эта оценка, разумеется, сохраняется и при использовании более быстрого умножения
и деления в Z.
Как известно, в случае простого k кольцо Zk является полем. При
составном k это кольцо полем не является и, более того, содержит делители нуля: если k = pq, p > 1, q > 1, то произведение элементов Zk ,
изображаемых числами p, q ∈ Ik , равно нулю. Допустим, что k является простым и примем для этого простого числа обозначение p,
по-прежнему считая его битовую длину равной m. Нахождение обратного к элементу кольца Z p , представленному целым ненулевым
числом a ∈ I p , может быть выполнено с помощью расширенного алгоритма Евклида. Так как p и a, очевидно, взаимно просты, то c помощью расширенного алгоритма Евклида можно найти s и t такие, что
sp + ta = 1. Получаем ta ≡ 1 (mod p), т. е. обратным к классу, содержащему a, является класс, содержащий t. В силу (.) имеем | t | < p;
если t < 0, то заменяем t на t + p (напомним, что мы используем
элементы системы I p для изображения элементов поля Z p ).
Пример .. Для p = 13, a = 5 получаем с помощью расширенного
алгоритма Евклида 2 · 13 + (−5) · 5 = 1, и отсюда 8 = −5 + 13 является
обратным для 5 в Z13 (проверка подтверждает это: 5 · 8 ≡ 1 (mod 13)).

§ . Модулярная арифметика



Как следствие предложения . получаем такое утверждение.
Предложение .. Пусть расширенный алгоритм Евклида основывается на некоторых алгоритмах деления с остатком и умножения, битовые затраты каждого из которых применительно к целым
v и w допускают оценку O(log v log w). Тогда битовая сложность обращения в поле Z p с помощью расширенного алгоритма Евклида допускает оценку O(log2 p) при использовании числа p в качестве размера
входа и, соответственно, оценку O(m2 ) при использовании в этом
качестве битовой длины m числа p.
Несомненным достоинством алгоритма обращения, основанного
на расширенном алгоритме Евклида, состоит в том, что с его помощью обращение возможно всякий раз, когда обращаемое число и модуль взаимно просты, а не только тогда, когда модуль — простое число. Например, можно определить a такое, что 5a ≡ 1 (mod 6) — среди
чисел, входящих в I6 , значением a является 5. В этом смысле применимость этого алгоритма шире, чем, например, алгоритма, основанного на малой теореме Ферма.
Малая теорема Ферма. Пусть p — простое число, a — произвольное целое. Тогда a p ≡ a (mod p).
(Путь доказательства показан в задаче .) Если a не делится на p,
то согласно этой теореме a p−2 является обратным к a по простому
модулю p. Но это, вообще говоря, неверно для составных p. Например, неверно, что 55 ≡ 1 (mod 6).
С помощью расширенного алгоритма Евклида возможно обращение
по модулю k любого числа a, взаимно простого с k; если a ∈ Ik или
a ∈ Sk , то это обращение имеет битовую сложность O(log2 k) или
O(m2 ), коль скоро в качестве размера входа используется m = λ(k).
Пример .. Уже говорилось, что вопрос о возможности распознавания простоты со сложностью O(md ) с некоторым d ∈ N представляет большой интерес и что, скажем, алгоритм пробных делений
(примеры ., ., .) не обладает указанным свойством даже при
рассмотрении не битовой сложности, а сложности по числу делений,
причем как в худшем случае, так и в среднем.
Если для некоторого a ∈ Z, не делящегося на n, мы обнаружим,
что не выполняется сравнение
an ≡ a (mod n),

(.)



Глава . Битовая сложность

то по малой теореме Ферма из этого можно заключить, что n не
является простым. Если фиксировано число a такое, что 1 < a < n,
то использование бинарного алгоритма возведения в степень с заменой результата каждого из умножений остатком от деления на n
позволяет вычислить an и проверить выполнение сравнения (.),
затратив O(log3 n), или, что то же самое, O(m3 ) битовых операций,
где m = λ(n). Однако это не позволяет утверждать, что мы можем
на основе этого распознавать простоту n за O(m3 ) битовых операций, так как существует бесконечно много составных n таких, что
(.) выполняется для любых a, взаимно простых с n. Это так называемые числа Кармайкла (наименьшее из которых равно 561 =
= 3 · 11 · 17).
Напомним, что алгоритм со сложностью O(md ), где m — размер
входа, d ∈ N, называют алгоритмом с полиномиально ограниченной
сложностью или полиномиальным. В задаче распознавания простоты
числа за размер входа берется количество m двоичных цифр числа n
или же log2 n. После долгих поисков, в которых принимали участие
разные исследователи, алгоритм с полиномиально ограниченной битовой сложностью был в  г. предложен тремя индийскими математиками — М. Агравалом, H. Кайалом и H. Саксеной  . Этот алгоритм
получил в литературе название AKS по первым буквам фамилий авторов. Мы обсудим лишь главную идею алгоритма AKS, основанием
которого служит следующее необходимое и достаточное условие простоты числа n.
Предложение .. Пусть a ∈ Z, n ∈ N взаимно просты, тогда
n является простым, если и только если выполнено полиномиальное
сравнение
(x − a)n ≡ x n − a (mod n),
(.)
которое надо понимать так, что числовые коэффициенты при одинаковых степенях x в полиномах, расположенных в левой и правой
частях, сравнимы по модулю n.
Доказательство. Пусть n — простое. Если n = 2, то выполнение
(.) проверяется непосредственно, и остается рассмотреть случай
нечетного n. Коэффициенты при x k в левой
 и правой частях для
k n
случая 1 < k < n равны соответственно (−1)
an−k и 0. При этом
k
 
n
делится на n, так как n простое (см. задачу ). Коэффициенты
k
при x n в обеих частях (.) равны 1, свободные члены соответствен

См. [].

§ . Модулярная арифметика



но равны (−a)n и −a. В силу нечетности n достаточно показать, что
an ≡ a (mod n), а это сравнение выполняется в силу малой теоремы
Ферма. Мы доказали, что если n — простое, то выполнено (.).
Пусть теперь n — составное. Пусть, далее, простое q и l ∈ N+ таковы, что q l | n и при этом неверно, что q l +1 | n. Имеем
  (n − q + 1)(n − q + 2)...n
n
.
=
q!

q

Так как q | n, то произведение (n − q + 1)(n − q + 2)...(n − 1) не делится на q; при этом один из входящих
 в n множителей, равных q, сокраn
тится со знаменателем. Поэтому
не делится на q l . Помимо этого,
q

q l взаимно просто с an−q , так как a и q взаимно просты. Поэтому
  коq
n− q n− q n
эффициент при x в левой части (.), равный (−1) a
, не
q

делится на q l , следовательно, не делится на n и поэтому не сравним
с  по модулю n. Мы доказали, что если n — составное, то сравнение (.) не имеет места.

Из предложения . следует, что для проверки простоты числа n
можно взять любое a, взаимно простое с n (подходит, например, ),
и проверить (.). Но прямая такая проверка потребует Ω(n) = Ω(2m )
битовых операций, так как раскрытие скобок в левой части (.)
дает n + 1 слагаемое. Алгоритм AKS предписывает проверку (.)
по двум модулям
(x − a)n ≡ x n − a (mod x r − 1, n),

(.)

r > 0. Сравнение (.) понимается в том смысле, что все коэффициенты остатка от деления полинома (x − a)n − x n + a на x r − 1 (они
будут целыми числами) делятся на n. Вычисление остатков от деления (x − a)n и x n на x r − 1 производится с помощью бинарного алгоритма возведения в степень, результат каждого умножения сразу
же заменяется остатком от деления на x r − 1. Но если взять произвольное r ∈ N+ , то может оказаться, что (.) выполняется и при
некоторых составных n. Число r должно подбираться специальным
образом, и авторы показывают, что подходящее для целей алгоритма r всегда существует и может быть выбрано без существенных затрат так, что r = O(m5 ); после выбора r сравнение (.) надо проверить для «небольшого»
числа «легко определяемых» a — количество
p
этих a есть O( rm). Итоговая сложность алгоритма допускает оценку O(m11 ). Заметим попутно, что в литературе по теории сложности
e f (m)) (O
e называется «O мягкое»),
часто используются оценки вида O(



Глава . Битовая сложность

за таким обозначением скрывается O( f (m) logd m), где d — положительное число, значение которого не уточняется. Авторы показывают,
e 21/2 ), укачто битовая сложность их алгоритма допускает оценку O(m
зывая при этом, что если верны некоторые известные в теории чисел
гипотезы (для которых имеются серьезные основания полагать, что
они верны), то можно взять r = O(m2 ), и в этом случае сложность
e 6 ).
алгоритма в целом есть O(m
На этом мы завершим разговор об алгоритме AKS, добавив лишь
ко всему сказанному, что, например, в криптографии практикуются
вероятностные (типа Монте-Карло) алгоритмы распознавания простоты, имеющие меньшую сложность, но не исключающие появления, хоть и с малой вероятностью, неверного ответа. В нашем курсе
такого рода алгоритмы не рассматриваются  .
§ . Булева арифметика
Сложность булевых вычислений как сложность по числу булевых операций может рассматриваться как алгебраическая сложность. Но работа с булевыми величинами является фактически работой с битами, и сложность по числу булевых операций в этом смысле совпадает с битовой сложностью. Таким образом, для алгоритмов булевой
арифметики алгебраическая сложность по числу булевых операций
и битовая сложность — это одно и то же. Аналогично дело обстоит
и с пространственной булевой (= битовой) сложностью.
Пример .. Пусть дан ориентированный граф G = (V , E), n = | V |.
Пусть C = (cij ) — булева матрица смежности графа G: cij = 1, если
и только если i-я вершина соединена ребром с j-й, i, j = 1, 2, ..., n.
Требуется построить для G его матрицу связности D = (dij ): dij = 1,
если и только если i = j или i-я вершина соединена путем из одного
или более ребер с j-й, i, j = 1, 2, ..., n. Если рассматривать G как граф
некоторого бинарного отношения на множестве из n элементов, то
задачу можно интерпретировать как задачу построения транзитивно-рефлексивного замыкания данного бинарного отношения. Соответственно, граф, для которого D является матрицей смежности, называют транзитивно-рефлексивным замыканием графа G, а саму матрицу D — транзитивно-рефлексивным замыканием матрицы C. Для
матрицы D используется обозначение C ∗ . На рис.  показан ориентированный граф и его транзитивно-рефлексивное замыкание. Соот

По поводу этих алгоритмов распознавания простоты числа см. [, гл. ] и [,
гл. ].

§ . Булева арифметика
4



3

а)

4

3

1

2

б)

1

5

2

5

Рис. . а) Ориентированный граф; б) его транзитивно-рефлексивное замыкание.

и C ∗ выглядят следующим образом



1 1 1 1
0 1



1 0
1 1 1 1
.
 , C∗ = 
0 1
1 1 1 1
0 0 0 1
0 0

ветствующие матрицы C

0 1

0 1
C =
1 0
0 0

Нам понадобятся произведения булевых матриц, которые определяются как обычно: например, произведение F квадратных матриц
A и B порядка n определяется формулой
fij =

n
_

(aik ∧ bkj ),

i, j = 1, 2, ..., n.

k =1

Элемент с индексами i, j для краткости будем называть (i, j)-элементом матрицы.
Легко видеть, что C 2 = C ∧ C — это матрица, для которой (i, j)-элемент равен 1, если и только если i-я вершина соединена с j-й путем
длины 2 (т. е. состоящим из двух ребер). Аналогично, C k — матрица,
для которой (i, j)-элемент равен 1, если и только если i-я вершина соединена с j-й путем длины k. Пусть I — матрица, для которой
(i, j)-элемент равен 1, если и только если i = j. Тогда
C ∗ = I ∨ C ∨ C 2 ∨ ... ∨ C n−1 .
Индукцией по k несложно доказать, что для любой квадратной булевой матрицы C и натурального k выполнено
I ∨ C ∨ C 2 ∨ ... ∨ C k = (I ∨ C)k .

(.)

C ∗ = (I ∨ C)n−1 .

(.)

Это дает нам



Глава . Битовая сложность

Тривиальный способ умножения булевых (n × n)-матриц
Θ(n3 ) битовых операций. Если используется именно этот
то оценка числа операций для формулы (.) есть Θ(n4 ).
нение бинарного алгоритма (пример .) для возведения в
булевой матрицы C позволяет перейти к оценке
Θ(n3 log n).

требует
способ,
Приместепень
(.)

Если нежелательно связывать основанный на формуле (.) алгоритм построения транзитивно-рефлексивного замыкания с конкретным способом умножения матриц, то верхнюю оценку числа битовых
операций можно записать как
n + B(n)(λ(n) + λ∗ (n) − 2),

(.)

где B(n) — сложность используемого алгоритма умножения булевых
(n × n)-матриц; слагаемое n отражает расход на сложение с матрицей I.
Рассмотренный пример высвечивает связь задачи построения
транзитивно-рефлексивного замыкания ориентированного графа с задачей умножения булевых матриц. Эта связь оказывается очень тесной, о чем мы еще будем говорить в § .
В следующем примере задача построения транзитивно-рефлексивного замыкания решается без использования умножения булевых
матриц.
Пример .. Исследуем сложность алгоритма С. Уоршелла, предназначенного для построения матрицы C ∗ . В процессе применения
этого алгоритма матрица C ∗ строится за n = | V | шагов, после k-го
шага получается матрица D (k) = (dij(k)), и dij(k) = 1, если и только если
i-я вершина соединена таким путем с j-й, номера всех промежуточных вершин которого не выходят за пределы множества {1, 2, ..., k}.
Вначале полагаем D (0) = I ∨ C. Затем для каждого k = 1, 2, ..., n находим D (k) :
(k −1)
(k −1)
dij(k) = dij(k−1) ∨ (dik
∧ dkj
).
(.)
После этого C ∗ = D (n) .
Формула (.) отражает то, что путь из i-й вершины в j-ю, все
промежуточные вершины которого принадлежат {1, 2, ..., k}, существует, если и только если реализуется хотя бы одна из следующих
возможностей:
• имеется путь из i-й вершины в j-ю, все промежуточные вершины
которого принадлежат {1, 2, ..., k − 1};

§ . Булева арифметика



• имеются пути из i-й вершины в k-ю и из k-й в j-ю, все промежуточные вершины которых принадлежат {1, 2, ..., k − 1}.
На вычисление D (0) уходит n битовых операций, вычисление каждой из матриц D (k) , 1 ¶ k ¶ n, требует 2n2 операций. Итого, требуется
2n3 + n операций.
Алгоритм Уоршелла вычисляет матрицу C ∗ , т. е. строит транзитивно-рефлексивное замыкание ориентированного графа G с n вершинами, заданного матрицей смежности, затрачивая 2n3 + n битовых
операций.
Алгоритм Уоршелла можно легко реализовать так, что храниться
в памяти будут только D (k−1) и D (k) . Но на самом деле алгоритм Уоршелла позволяет производить все вычисления, расходуя всего n2 битов под хранение матричных элементов. Если мы вычислим D = I ∨ C,
а затем n раз обновим матрицу D (каждый раз всю целиком, не
оставляя незатронутых элементов), используя на k-м этапе обновления матрицы D присваивания
dij := dij ∨ (dik ∧ dkj ),
k = 1, 2, ... n, то получим искомую матрицу связности. В самом деле,
индукцией по k можно доказать, что после k-го этапа обновления получаем матрицу, равную D (k) , при этом индуктивный переход от k − 1
к k основывается на том, что имеют место очевидные соотношения
(k)
(k −1)
dik
= dik
,

(k)
(k −1)
dkj
= dkj
,

k = 1, 2, ..., n, т. е. при обновлении элемента dij на k-м этапе не имеет никакого значения, был ли уже обновлен какой-то из элементов
dik , dkj или нет.
Если строить матрицу C ∗ на месте исходной матрицы C, то алгоритм можно изобразить так:

for l = 1 to n do cll := 1 od;
for k = 1 to n do
for i = 1 to n do
for j = 1 to n do
od

cij := cij ∨ (cik ∧ ckj )

od
od
Подводя итог рассмотрению алгоритма Уоршелла, заметим, что,
как и алгоритм Евклида в расширенной версии, он дает довольно



Глава . Битовая сложность

редкий пример, когда низкие временные затраты сочетаются с малым
расходом памяти.
Алгоритм Уоршелла построения замыкания ориентированного
графа имеет битовую временную сложность 2n3 + n, где n = | V | — число вершин графа. Пространственная сложность этого алгоритма
ограничена константой.
При рассмотрении | V |, | E | в качестве двух параметров размера
входа сказанное сохраняет силу, так как затраты алгоритма Уоршелла
не зависят от числа ребер заданного входного графа.
Задачи
. Исследовать битовую сложность вычисления величины 1 +
+ 2 + ... + n последовательными сложениями. Размером входа считать
битовую длину m целого числа n.
. Для временной битовой сложности «сверхнаивного» умножения (пример .) при использовании параметров m1 , m2 верна оценка
сверху O(2max{m1 ,m2 } max{m1 , m2 }), а оценка Θ(2max{m1 ,m2 } max{m1 , m2 })
неверна.
Указание. Неверна оценка Ω(2max{m1 ,m2 } max{m1 , m2 }): она противоречила
бы оценке O(2m2 m1 ), так как для любого N > 0 существуют m1 , m2 > N такие,
что m1 = 2m2 .

. Определение чисел Фибоначчи, данное в § , позволяет вычислить Fn , выполнив n − 1 сложение. Битовая сложность этого алгоритма допускает оценку O(n2 ) при рассмотрении n в качестве размера входа.
. Обосновать использованный в доказательстве предложения
∗∗
. переход от оценки TND
(m1 , m2 ) = O((m1 − m2 + 1)(m2 + 1)) к
∗∗
TND (m1 , m2 ) = O((m1 − m2 + 1)m2 ).
. Можно ли усилить предложение ., заменив приведенные
там оценки O(log a log b), O(log2 a) на Θ(log a log b), Θ(log2 a)?
. Рассмотрим m = λ(n) в качестве размера входа алгоритма вычисления факториала (пример .). Верна ли для соответствующей
временной битовой сложности оценка O(2m m)?
. К числу, первоначально равному нулю, прибавляется шаг за
шагом по единице до получения значения 2n − 1, n ¾ 0. При этих сложениях потребуется 2n − n − 1 переносов единицы в старший разряд.
. Пусть p — простое, a и b — произвольные целые, k — натуk
k
k
ральное. Тогда (a + b) p ≡ a p + b p (mod p).

Задачи



. а) Аддитивная группа кольца Zk является циклической, в качестве образующей этой группы может выступать любой класс, содержащий число l, взаимно простое с k.
б) Пусть p — простое, тогда мультипликативная группа поля Z p ,
т. е. группа всех ненулевых элементов по умножению, является циклической.
. Если
p — простое, а k — неотрицательное целое, мень число

p
шее p, то
≡ 0 (mod p).
k

Указание. Предварительно показать, что p не делит k!.

. Индукцией по a доказать малую теорему Ферма.
Указание. Использовать равенство a p = (1 + (a − 1)) p и предыдущую задачу.

. Имеет место следующая китайская теорема об остатках:
пусть k1 , k2 , ..., k n — взаимно простые натуральные числа (модули); тогда для любых b1 , b2 , ..., bn ∈ Z найдется f ∈ N такое, что f ≡
≡ bi (mod k i ), i = 1, 2, ..., n. (Задача восстановления числа по остаткам
обсуждалась в древних китайских математических трактатах.) Дать
конструктивное доказательство этой теоремы, т. е. доказательство,
содержащее в себе алгоритм построения подходящего f (каждый
такой алгоритм может быть назван китайским алгоритмом).
Указание. Пусть k = k1 k2 ... kn и gi = k/ki , i = 1, 2, ..., n. При всех i = 1, 2, ...
..., n числа ki и gi взаимно просты, поэтому расширенным алгоритмом Евклиn
P
bj h j gj .
да можно определить hi так, что hi gi ≡ 1 (mod ki ) и положить f =
j =1

. Исходя из того, что значение полинома f (x) в точке x = a
равно по теореме Безу остатку от деления f (x) на x − a, установить
параллелизм между интерполяционной формулой Лагранжа и формулой для значения f , данной в указании к задаче .
. Битовая сложность китайского алгоритма, эскизно обрисованного в указании к задаче  и основывающегося на расширенном
алгоритме Евклида, наивном делении и наивном умножении, допускает оценку O(log2 k), если в качестве размера входа рассмотреть k,
и оценку O(m2 ), если в качестве размера входа рассмотреть битовую
длину m числа k.
Указание. По поводу сложности вычисления g см. пример .; сложность

P
n
этапа вычисления всех gi допускает оценку O
log g log ki и т. д.
i =1



Глава . Битовая сложность

. Верно ли, что для битовой сложности
 m в среднем алгоритма
4
пробных делений справедлива оценка Ω
?
3
. Битовая сложность в среднем алгоритма наивного умножения
двух неотрицательных целых чисел a и b допускает оценку Ω(m2 ),
а тем самым — и Θ(m2 ), где m = max{λ(a), λ(b)}.
Указание. Битовые затраты при наивном умножении a на b не могут быть
меньше, чем cλ(a)λ∗ (b). Два случая
λ(a) = m,

λ(b) ¶ m

и

λ(a) ¶ m,

λ(b) = m

приводят к двум вероятностным пространствам V1 , V2 , состоящим из соответствующих пар (a, b) с равномерными распределениями вероятностей.
Определить значения вероятностей событий λ(a) = k и λ(b) = k для произвольного 0 ¶ k ¶ m для каждого из пространств V1 , V2 и найти математические ожидания случайных величин ξ(a, b) = λ(a), η(a, b) = λ∗ (b). В силу
независимости ξ и η можно воспользоваться равенством E(ξ(a, b)η(a, b)) =
= (E(ξ(a, b))(Eη(a, b)).

. Привести полное доказательство равенства (.).
. Основываясь на (.) и бинарном алгоритме возведения
в степень, построение C ∗ можно выполнить с пространственной сложностью 3n2 + O(1).
. Искомая матрица C ∗ будет вычисляться правильно и после
увеличения показателя степени в правой части (.).
. Воспользовавшись утверждением, содержащимся в задаче ,
заменим показатель степени в правой части (.) на 2m , где m —
наименьшее целое, такое что 2m ¾ n − 1. Как изменится верхняя оценка (.) при переходе к этой новой версии алгоритма?
. Исследовать пространственную сложность описанного в задаче  алгоритма.
. Какой наибольшей временной сложностью может обладать
алгоритм умножения булевых матриц, или, другими словами, какую
верхнюю границу должна допускать функция B(n), чтобы временные затраты описанного в задаче  алгоритма допускали бы оценку
O(n3 )?
. Можно ли первую строку приведенного в §  псевдокода алгоритма Уоршелла переместить в конец этого псевдокода?
Указание. Рассмотрим алгоритм в сокращенном виде, удалив эту строку
из псевдокода. Влияют ли значения диагональных элементов исходной матрицы на значения внедиагональных элементов матрицы-результата?

. Описать версию алгоритма Уоршелла для вычисления кратчайших путей между вершинами графа G, считая, что вместо матри-

Задачи



цы смежности дана матрица, содержащая длины соответствующих ребер. Если какие-то вершины не соединены, то длина ребра равна ∞.
Провести анализ сложности по числу операций сложения и операций нахождения минимума (раздельно) и анализ пространственной
сложности. (В этой задаче мы не рассматриваем битовую сложность.)

Глава 

Рекуррентные соотношения как средство
анализа сложности алгоритмов

§ . Простейшие рекуррентные уравнения
Рекуррентные соотношения (уравнения и неравенства) играют существенную роль в анализе алгоритмов. Наиболее известный и простой вид таких соотношений — это линейные рекуррентные уравнения с постоянными коэффициентами.
Пример .. Вернемся к задаче , в которой надо доказать, что
если к числу, первоначально равному нулю, прибавляется шаг за шагом по единице до достижения значения 2n − 1, n ¾ 0, то в целом потребуется 2n − n − 1 переносов единиц в старшие разряды. Коль скоро
заранее указан ответ, для доказательства можно использовать индукцию. Но формулу 2n − n − 1 можно вывести, исходя лишь из условия
задачи. Обозначим через s(n) исследуемое количество переносов и заметим, что если прибавлением единиц уже получено число 2n−1 − 1
(на это потребуется s(n − 1) переносов), то очередное прибавление
единицы потребует n − 1 переносов и приведет к числу 2n−1 , двоичная запись которого есть 10...0 (количество нулей после единицы
равно n − 1). Далее в процессе достижения числа 11...1 (n единиц)
потребуется еще s(n − 1) переносов. Получаем рекуррентное уравнение s(n) = 2s(n − 1) + n − 1 или
s(n) − 2s(n − 1) = n − 1,

(.)

при этом s(0) = 0. Характеристическое уравнение  , соответствующее
рекуррентному уравнению (.), имеет вид λ − 2 = 0. Общее решение однородного уравнения s(n) − 2s(n − 1) = 0 есть c2n . Правую часть
уравнения (.) можно записать в виде квазиполинома (n − 1)1n .
Значение 1 не является корнем характеристического уравнения, по

О методе решения линейных рекуррентных уравнений с постоянными коэффициентами см. в приложении G.

§ . Простейшие рекуррентные уравнения



этому (.) обладает частным решением вида an + b; подставляя это
выражение вместо s(n) в (.), получаем an + b − 2(a(n − 1) + b) =
= n − 1, и, приравнивая в левой и правой частях коэффициенты при
первой и нулевой степенях n, имеем a = b = −1. Получаем общее решение уравнения (.): s(n) = c2n − n − 1. Подбираем значение константы c так, чтобы выполнялось s(0) = 0; для этого должно выполняться c · 2 − 2 = 0, т. е. c = 1. Итак, потребуется 2n − n − 1 переносов
единиц в старшие разряды.
Алгоритм, который содержит прямые или косвенные (т. е. при посредстве других алгоритмов) обращения к себе, как известно, называется рекурсивным. Рекуррентные соотношения являются удобным
средством анализа сложности рекурсивных алгоритмов.
В следующем примере обсуждается использование рекуррентных
уравнений в анализе рекурсивных алгоритмов и указывается один
неудачный вид рекурсии.
Пример .. Рассмотрим построение множества Vn всех целых
чисел, десятичная запись каждого из которых содержит только цифры 1 и 2, а сумма цифр равна заданному числу n ¾ 1. Непосредственно видно, что V1 = {1}, V2 = {11, 2}, V3 = {111, 21, 12}. В общем
случае Vn является, очевидно, объединением двух непересекающихся
подмножеств, в первое из которых входят все числа из Vn , оканчивающиеся цифрой 1, во второе — цифрой 2. Если вычеркнуть последнюю цифру, то при n ¾ 2 первое подмножество превратится в Vn−1 ,
второе — в Vn−2 . Это наблюдение приводит к рекурсивному алгоритму VRec построения Vn : если n = 1 или n = 2, то результатом будет
{1} или соответственно {11, 2}; иначе надо найти Vn−1 (рекурсивное
обращение к алгоритму) и приписать справа ко всем числам этого
множества единицу, затем найти Vn−2 (еще одно рекурсивное обращение) и приписать справа ко всем числам этого множества двойку,
после чего построить объединение двух получившихся множеств.
Не составляет труда заметить, что алгоритм VRec избыточно сложен (о чем еще будет идти речь). Но анализ сложности часто приходится проводить и для «плохих» алгоритмов — например, чтобы показать их практическую непригодность.
Прежде чем исследовать временную сложность этого алгоритма,
установим, чему равно число v(n) элементов Vn . Мы видим, что
v(1) = 1, v(2) = 2, v(n) = v(n − 1) + v(n − 2), n = 3, 4, ... Таким образом, v(n) равно (n + 1)-му числу Фибоначчи: v(n) = Fn+1 . Явное выражение v(n) через n можно получить, воспользовавшись формулой
Бине (.), которая сама может быть выведена с помощью общего



Глава . Рекуррентные соотношения и сложность алгоритмов

метода решения линейных рекуррентных уравнений с постоянными
коэффициентами.
Используя рекуррентные уравнения, мы можем определить количество y(n) преобразований чисел при построении множества Vn
по описанному алгоритму (каждое из этих преобразований состоит в приписывании справа к числу единицы или двойки). Мы можем также определить число z(n) выполняемых операций объединения множеств. Очевидно, имеет место уравнение y(n) = y(n − 1) +
+ y(n − 2) + Fn + Fn−1 , которое мы перепишем в более удобном виде
и добавим начальные значения:
y(n) − y(n − 1) − y(n − 2) = Fn+1 ,

(.)

y(2) = y(1) = 0. Аналогично, имеем
z(n) − z(n − 1) − z(n − 2) = 1,

(.)

z(2) = z(1) = 0.
Начнем со второго уравнения. Будем, как обычно, прибегать
к обозначениям
p
p
φ=

1+ 5
,
2

φ̃ =

1− 5
.
2

Непосредственно видно, что −1 является частным решением нашего рекуррентного уравнения (это частное решение можно получить
и общим методом: правая часть является квазиполиномом 1n , при
этом 1 не есть корень характеристического уравнения
λ2 − λ − 1 = 0,

(.)

и, следовательно, существует частное решение вида c1n , где c — полином нулевой степени, т. е. константа; подстановка в (.) дает
c = −1). Корнями уравнения (.) служат числа φ и φ̃ , входящие
в формулу Бине, и общее решение уравнения (.) может быть записано в виде z(n) = C1 φ n + C2 φ̃ n − 1. Начальные условия z(2) = z(1) = 0
приводят нас к системе
p
p
1+ 5
1− 5
C1 +
C2 = 1,
2
2
p 2
p 2


1+ 5
1− 5
C1 +
C2 = 1.
2
2

Получаем
φ

C1 = p ,
5

φ̃

C2 = − p .
5

(.)

§ . Простейшие рекуррентные уравнения



Таким образом, z(n) = Fn+1 − 1. Отсюда следует ряд асимптотических
формул:
1
5

z(n) = p φ n+1 + O(1),

1
5

z(n) ∼ p φ n+1 ,

z(n) = Θ(φ n )

(.)

и т. д. Обратимся теперь к (.). Характеристическим уравнением
здесь вновь является (.). Поскольку Fn+1 = c1 φ n + c2 φ̃ n , где c1 , c2 —
полиномы нулевой степени, то правая часть уравнения (.) является суммой двух квазиполиномов, и для нахождения интересующего нас решения может быть привлечен общий метод, в результате
чего получится формула вида y(n) = p1 (n)φ n + p2 (n)φ̃ n , где, в силу
того, что φ и φ̃ являются корнями кратности 1 характеристического уравнения, а также того, что c1 , c2 6= 0, степени полиномов p1 (n)
и p2 (n) равны 1. Это показывает, что y(n) = C1 φ n + C2 φ̃ n + p1 (n)φ n +
+ p2 (n)φ̃ n = q1 (n)φ n + q2 (n)φ̃ n при соответствующем выборе полиномов q1 (n), q2 (n) первой степени. Можно было бы найти эти полиномы, но даже не делая этого, а просто принимая во внимание, что
степень q1 (n) равна 1, получаем
y(n) = Θ(nφ n ).

(.)

Мы видим, что анализ сложности простейших рекурсивных алгоритмов часто приводит к линейным рекуррентным уравнениям первого или второго порядка с постоянными коэффициентами (однородным или с правыми частями в виде суммы квазиполиномов). В таких
случаях оказывается возможным найти явные формулы для сложности алгоритма. Асимптотические формулы иногда удается получить
непосредственно из общего решения, не прибегая к вычислению значений входящих в него произвольных постоянных.
С помощью рекуррентных уравнений мы получаем информацию
о вычислительной сложности рекурсивного алгоритма. Правда, дело
не всегда обстоит просто, — иногда возникают уравнения с переменными коэффициентами или нелинейные уравнения и неравенства,
и об этом мы еще будем говорить. Тем не менее, сам метод исследования сложности рекурсивных алгоритмов с помощью рекуррентных
уравнений выглядит очень естественно.
Задержимся на формулах (.), (.). Если бы построение множества Vn при n > 2 разворачивалось не по алгоритму VRec , а несколько иначе, то затрат было бы существенно меньше. Можно находить
шаг за шагом множества V1 , V2 , V3 , ... до появления интересующего
нас Vn , при этом каждое Vk , k = 3, 4, ..., n, строится исходя из уже имеющихся множеств Vk−2 и Vk−1 . Или же можно организовать рекурсию



Глава . Рекуррентные соотношения и сложность алгоритмов

для вычисления пары Pn = (Vn , Vn−1 ) так, чтобы при вычислении Pn
исходя из Pn−1 множество Vn−1 просто переходило бы из пары в пару.
Будем использовать обозначения y ∗ (n) и z ∗ (n) для количества преобразований чисел и соответственно для количества объединений множеств, затрачиваемых при нахождении (Vn , Vn−1 ). При n > 2 имеем
y ∗ (n) = y ∗ (n − 1) + Fn + Fn−1 . Перепишем уравнение в более удобном
виде и добавим начальное значение:
y ∗ (1) = 0. Аналогично,

y ∗ (n) − y ∗ (n − 1) = Fn+1 ,

(.)

z ∗ (n) − z ∗ (n − 1) = 1,
∗

∗

(.)
∗

n

z (1) = 0. Легко получаем z (n) = n − 2 для n ¾ 2 и y (n) = Θ(φ ).
Причина избыточной сложности первого из рассмотренных алгоритмов ясна. Построение Vn требует вычисления Vn−1 и Vn−2 , а Vn−1
в свою очередь потребует построения Vn−2 и Vn−3 . Таким образом, даже не прослеживая ход построений слишком далеко, мы видим, что
требуются два независимых построения множества Vn−2 , при этом построение Vn−2 по тем же причинам будет производиться не лучшим
образом.
Пример .. Достаточно ясно, что при k > 2 рекурсия вида
Yn = U(Yn−1 , ..., Yn−k )

(.)

(например, с заданными Y0 , Y1 , ..., Yk−1 ) заслуживает еще меньше доверия, чем при k = 2, коль скоро эта рекурсия предписывает независимое вычисление Yn−1 , Yn−2 , ..., Yn−k ; при этом не важно, являются
ли Yi числами, множествами или же какими-то другими объектами.
Нахождение Yn с помощью простейшего циклического алгоритма потребует n − k + 1 обращений к U. Если при рекурсивном нахождении
их требуется y(n), то
y(n) − y(n − 1) − ... − y(n − k) = 1,

(.)

y(0) = y(1) = ... = y(k − 1) = 0. Можно найти асимптотику y(n), не
решая полностью рекуррентного уравнения (.), и получить следующее предложение.
Предложение .. Пусть рекурсивный алгоритм организован по
схеме (.), пусть k ¾ 2 и пусть для получения значения функции U
необходимы значения всех ее k аргументов. Тогда количество вычислений значений этой функции при нахождении Yn есть Θ(αnk ), и αk
удовлетворяет условию 2 −

1
¶ αk < 2, k = 2, 3, ...
k

§ . Об одном классе нелинейных рекуррентных соотношений



В приложении H можно найти полное доказательство этого предложения. Оно основывается на исследовании расположения на комплексной плоскости корней алгебраических уравнений
λk − λk−1 − ... − λ − 1 = 0,

k = 2, 3, ... Эти уравнения являются характеристическими для рекуррентных уравнений (.).
§ . Об одном классе нелинейных рекуррентных соотношений
Одним из источников появления рекурсии в алгоритмах служит привлечение стратегии «разделяй и властвуй»: вычислительная задача
с размером входа n разбивается на s > 1 одноименных задач, размер входа любой из которых примерно равен n/s («разделяй»); эти
задачи решаются рекурсивно, т. е. с применением этой же стратегии, а затем полученные решения соединяются в решение исходной
задачи («властвуй»). Для входов маленьких размеров — как правило, 0 или 1 — задачи решаются каким-то простым способом, без рекурсии. При анализе сложности таких алгоритмов возникают специфические нелинейные рекуррентные соотношения в виде уравнений
и неравенств. В общем случае такие соотношения довольно трудны
для решения, но для многих конкретных задач удается исследовать
сложность алгоритмов сведением рекуррентных соотношений к хорошо изученным линейным рекуррентным уравнениям первого порядка
с постоянными коэффициентами и квазиполиномиальными правыми
частями.
Пример .. Обратимся к сортировке слияниями в ее рекурсивном варианте и исследуем ее сложность TMS (n) по числу сравнений
(n — длина массива). Функция TMS (n) подчиняется рекуррентному
неравенству
(
0, j k
если n = 1,
l m
(.)
TMS (n) ¶
n
n
+ TMS
+ n − 1, если n > 1.
TMS
2

2

В самом
1 сортировка первых
j k деле, для любого массива длиныjn >k
n
n
его
элементов потребует не более TMS
сравнений (так как
2
j2 k
n
— это максимальное число сравнений, которое может поTMS
2
требоваться
рассматриваемой сортировке при работе
j k
l m с массивом длиn
n
ны
); аналогично, сортировка последних
элементов потре2

2



Глава . Рекуррентные соотношения и сложность алгоритмов
l m
n
бует не более, чем TMS
сравнений, а слияние потребует срав2
j k l m
n
n
+
− 1 = n − 1. В люнений в количестве, не превосходящем
2
2
j k
n
+
бом, а значит, и в худшем случае потребуется не более TMS
2
l m
n
+ n − 1 сравнений.
+ TMS
2
Рекуррентные неравенства, схожие с неравенством (.), характерны для многих алгоритмов, построенных на стратегии «разделяй
и властвуй». Мы прервем на некоторое время рассмотрение этого
примера и обсудим общую ситуацию с неравенствами возникающего типа.
Предложение .. Пусть вещественная функция f натурального
аргумента удовлетворяет неравенству
(
u, j k
если n = 1,
l m
f (n) ¶
(.)
n
n
vf
+ wf
+ ϕ (n), если n > 1,
2

2

где u, v, w — неотрицательные вещественные числа, причем v + w ¾ 1,
а функция ϕ — неотрицательная неубывающая. Тогда
f (n) ¶ t(⌈log2 n⌉),
где

¨

t(k) =

(.)

u,
если k = 0,
(v + w)t(k − 1) + ϕ (2k ), если k > 0.

(.)

Доказательство. Установим прежде всего, что вещественная
функция F натурального аргумента, удовлетворяющая равенству
(
u, j k
если n = 1,
l m
(.)
F(n) =
n
n
+ wF
+ ϕ (n), если n > 1,
vF
2

2

является неубывающей, т. е. при n ¾ 2 выполнено
F(n) ¾ F(n − 1).

(.)

Проведем индукцию по n. При n = 2 неравенство выполнено, так как
F(2) = (v + w)u + ϕ (2) ¾ u = F(1).
Пусть n > 2 и неравенство (.) выполнено для 2, 3, ..., n − 1; докажем, что тогда оно верно и для n. Воспользуемся тем, что при n > 2
j k j
k
l m l
m
n
n−1
n
n−1
n>
¾
¾ 1, n >
¾
¾ 1.
2

2

2

2

§ . Об одном классе нелинейных рекуррентных соотношений



Имеем
j k

F(n) = vF

n
2

l m
+ wF

n
2

j
¾ vF

+ ϕ (n) ¾
k
l
m
n−1
n−1
+ wF
+ ϕ (n − 1) = F(n − 1).
2

2

Неравенство (.) доказано.
Аналогичным образом по индукции докажем, что
f (n) ¶ F(n)

(.)

для n ¾ 1. Очевидно, f (1) ¶ u = F(1). Пусть n > 1 и неравенство (.)
выполнено для 1, 2, ..., n − 1; докажем, что тогда оно верно и для n.
В силу (.) мы имеем при n > 1
j k
l m
n
n
f (n) ¶ vf
+ wf
+ ϕ (n),
(.)
2

2

j k
l m
n
n
и так как при n > 1 выполняются неравенства
¶n−1 и
¶
2
2
¶ n − 1, то по предположению индукции
j k
l m
j k
l m
n
n
n
n
vf
+ wf
+ ϕ (n) ¶ vF
+ wF
+ ϕ (n). (.)
2

2

2

2

Правая часть последнего неравенства есть F(n). Это доказывает
(.).
Свойства (.), (.) дают нам
f (n) ¶ F(n) ¶ F(2⌈log2 n⌉ )

(.)

для n ¾ 1. Исследуем функцию t(k) = F(2k ), k = 0, 1, ... В силу (.)
¨
u,
если k = 0,
k
F(2 ) =
(v + w)F(2k−1 ) + ϕ (2k ), если k > 0,
и, следовательно, t(k) удовлетворяет линейному рекуррентному уравнению (.). Отсюда и из (.) следует требуемое.
Определение .. Рекуррентное уравнение (.), включающее в
себя начальное условие t(0) = u, мы назовем уравнением, ассоциированным с рекуррентным неравенством (.).
Если u, v, ϕ (n) удовлетворяют условиям, сформулированным в
предложении ., то решение ассоциированного уравнения — неотрицательная функция (см. задачу ).



Глава . Рекуррентные соотношения и сложность алгоритмов

Продолжение примера .. Уравнением, ассоциированным с (.),
будет
¨
0,
если k = 0,
t(k) =
(.)
k
2t(k − 1) + 2 − 1, если k > 0.
Отвлекаясь временно от начального значения t(0) = 0, мы замечаем,
что правая часть в
t(k) − 2t(k − 1) = 2k − 1
(.)
является суммой квазиполиномов 2k и −1; первый из них, т. е. 2k ,
интересен тем, что 2 является корнем характеристического уравнения λ − 2 = 0, и поэтому рекуррентное уравнение t(k) − 2t(k − 1) = 2k
имеет частное решение вида p(k)2k , где p(k) — полином первой степени. Подстановка (p1 k + p0 )2k в рекуррентное уравнение дает
(p1 k + p0 )2k − (p1 (k − 1) + p0 )2k = 2k ,
откуда получаем, что p1 = 1, p0 — любое. Итак, k2k является частным решением рекуррентного уравнения с правой частью 2k . Слагаемое −1 правой части исходного уравнения можно переписать в виде
(−1) · 1k , единица не является корнем характеристического уравнения, поэтому рекуррентное уравнение t(k) − 2t(k) = −1 имеет в качестве частного решения некоторую константу, значение которой определяется без труда — это 1.
Таким образом, любое решение рекуррентного уравнения (.)
может быть записано в виде
c2k + k2k + 1
с некоторым конкретным c. Из условия t(0) = 0 находим c = −1 и
t(k) = k2k − 2k + 1.

(.)

По предложению .
TMS (n) ¶ ⌈log2 n⌉2⌈log2 n⌉ − 2⌈log2 n⌉ + 1 =
= (⌈log2 n⌉ − 1)2⌈log2 n⌉ + 1 ¶

¶ log2 n · 2log2 n+1 + 1 =

= 2n log2 n + 1.

Мы еще раз прервем рассмотрение примера . и сформулируем
следующее предложение.

§ . Об одном классе нелинейных рекуррентных соотношений



Предложение .. Пусть вещественная функция f натурального
аргумента удовлетворяет неравенству
(
u, j k
если n = 1,
l m
(.)
f (n) ¾
n
n
+ wf
+ ϕ (n), если n > 1,
vf
2

2

где u, v, w — неотрицательные вещественные числа, причем v + w ¾ 1,
а функция ϕ — неотрицательная неубывающая. Тогда
f (n) ¾ t(⌊log2 n⌋),

(.)

где t — решение рекуррентного уравнения (.).
Доказательство получается заменой знака ¶ на ¾ в (.), (.)
и (.), а также переходом от (.) к
f (n) ¾ F(n) ¾ F(2⌊log2 n⌋ ).
Сохраняя введенную терминологию, рекуррентное уравнение
(.) будем называть ассоциированным с рекуррентным неравенством (.).
Если же возникает соотношение со знаком = вместо ¾ или ¶, то
мы можем рассматривать его как систему двух рекуррентных неравенств (.), (.). Тогда получим оценки
t(⌊log2 n⌋) ¶ f (n) ¶ t(⌈log2 n⌉).
Завершим рассмотрение примера .. Можно доказать (см. задачу ), что для сложности по числу сравнений рекурсивной сортировки слияниями выполнено
(
0, j k
если n = 1,
l m
TMS (n) =
(.)
n
n
TMS
+ TMS
+ n − 1, если n > 1,
2

2

и прийти к справедливым для всех n оценкам
(⌊log2 n⌋ − 1)2⌊log2 n⌋ + 1 ¶ TMS (n) ¶ (⌈log2 n⌉ − 1)2⌈log2 n⌉ + 1.

(.)

Для исследования сложности TeMS (n) рекурсивной сортировки слияниями по числу перемещений рассмотрим рекуррентное уравнение
(
0, j k
если n = 1,
l m
(.)
TeMS (n) =
n
n
+ TeMS
+ n, если n > 1
TeMS
2

2



Глава . Рекуррентные соотношения и сложность алгоритмов
j k l m
n
n
(при слиянии массивов, содержащих соответственно
и
эле2
2
ментов, требуется ровно n перемещений элементов). Решением ассоциированного уравнения
¨
0,
если k = 0,
t(k) =
2t(k − 1) + 2k , если k > 0,
является k2k , что дает нам
⌊log2 n⌋2⌊log2 n⌋ ¶ TeMS (n) ¶ ⌈log2 n⌉2⌈log2 n⌉ .

(.)

Пространственная сложность этой сортировки есть Ω(n), ибо слияние упорядоченных массивов выполняется с получением результата
на новом месте. (Дополнительно к этому будет использоваться стек
отложенных заданий.) Рассмотрение примера . закончено.
Интересно посмотреть на результаты применения разобранного
метода на каком-нибудь примере, для которого мы знаем точное значение сложности алгоритма, — сколь далеки будут получаемые оценки от известного точного значения?
Пример .. Вернемся к бинарному алгоритму вычисления an
(пример .), который можно легко описать рекурсивно. Для его
сложности по числу умножений имеем
(
0, j k
если n = 1,
(.)
TRS (n) ¶
n
+ 2, если n > 1,
TRS
2

и

(

TRS (n) ¾

0, j k
если n = 1,
n
+ 1, если n > 1.
TRS

(.)

2

Соответствующими ассоциированными уравнениями будут
¨
0,
если k = 0,
t(k) =
t(k − 1) + 2, если k > 1,
и

¨

t(k) =

0,
если k = 0,
t(k − 1) + 1, если k > 1,

их решения суть 2k и k. Отсюда
⌊log2 n⌋ ¶ TRS (n) ¶ 2⌈log2 n⌉.

(.)

Эти оценки не сильно расходятся с точной формулой TRS (n) = λ(n) +
+ λ∗ (n) − 2.

§ . Асимптотические оценки решений рекуррентных неравенств 
§ . Асимптотические оценки решений рекуррентных
неравенств
Рассмотренный метод оценивания решений рекуррентных неравенств (.), (.) приводит к достаточно точным оценкам, но
требует многоэтапной работы. Часто бывает достаточно получить
описание роста решения в виде простой асимптотической оценки.
В §  мы получили оценку (.), указав при этом, что для ее вывода
не нужно определять численные значения коэффициентов, входящих
в соответствующее частное решение ассоциированного рекуррентного уравнения. Этот путь приводит к ряду общих теорем. Для них
в разных литературных источниках используются синонимичные названия «теорема о рекуррентном неравенстве», «основная теорема
о рекуррентных оценках» и т. д.  Мы приведем две теоремы такого
рода.
Теорема . (о рекуррентном неравенстве, случай ¶). Пусть
неотрицательная вещественная функция f натурального аргумента
удовлетворяет неравенству
(
u, j k
если n = 1,
l m
(.)
f (n) ¶
n
n
d
+ wf
+ cn , если n > 1,
vf
2

2

где u, v, w, d — неотрицательные вещественные числа, причем v + w ¾
¾ 1; c — положительное вещественное число. Тогда

d
если d = log2 (v + w),
O(n log n),
f (n) = O(nd ),
(.)
если d > log2 (v + w),

log2 (v +w)
O(n
), если d < log2 (v + w).
Доказательство. Решение ассоциированного уравнения
¨
u,
если k = 0,
t(k) =
d k
(v + w)t(k − 1) + c(2 ) , если k > 0,
имеет вид
t(k) = c0(v + w)k + (c1 k + c2 )(2d )k = c0 (2log2 (v +w) )k + (c1 k + c2 )(2d )k

(.)

с некоторыми конкретными c0 , c1 , c2 , причем c1 6= 0, если и только если 2d = v + w, или, что то же самое, если d = log2 (v + w). Рассмотрим
раздельно три случая.


В литературе на английском языке — «master theorem» (мастер-теорема).



Глава . Рекуррентные соотношения и сложность алгоритмов

Случай d = log2 (v + w). Имеем t(k) = (c1 k + (c0 + c2 ))(2d )k . Для достаточно больших значений k выполняется
t(k) < Ck(2d )k = Ck(2k )d ,
где C — некоторое положительное число. Используя предложение .,
заключаем, что
f (n) < C ⌈log2 n⌉(2⌈log2 n⌉ )d .
Это дает f (n) = O(nd log n).
Случай d > log2 (v + w). Имеем t(k) = c0 (v + w)k + c2 (2d )k . Для достаточно больших значений k будем иметь
t(k) < C(2d )k = C(2k )d ,
где C — некоторое положительное число. Аналогично предыдущему
случаю с помощью предложения . получаем f (n) = O(nd ).
Случай d < log2 (v + w). Вновь имеем t(k) = c0 (v + w)k + c2 (2d )k , но
теперь для достаточно больших значений k будем иметь
t(k) < C(v + w)k = C(2log2 (v +w) )k = C(2k )log2 (v +w) ,
где C — некоторое положительное число. С помощью предложения
. приходим к оценке f (n) = O(nlog2 (v +w) ).
Похожая теорема может быть доказана и для случая неравенства
со знаком ¾ вместо знака ¶.
Теорема . (о рекуррентном неравенстве, случай ¾). Пусть
вещественная функция f (n) натурального аргумента удовлетворяет
неравенству
(
u, j k
если n = 1,
l m
f (n) ¾
n
n
d
vf
+ wf
+ cn , если n > 1,
2

2

где u, v, w, d — неотрицательные вещественные числа, причем v + w ¾
¾ 1; c — положительное вещественное число. Тогда

d
если d = log2 (v + w),
Ω(n log n),
log2 (v +w)
f (n) = Ω(n
(.)
), если d > log2 (v + w),

Ω(nd ),
если d < log2 (v + w).
Доказательство отличается от доказательства теоремы . лишь
тем, что в случаях d 6= log2 (v + w) вместо выбора в (.) слагаемого,
содержащего степень двойки с бо̀льшим показателем, мы выбираем

§ . Асимптотические оценки решений рекуррентных неравенств 
то слагаемое, которое содержит степень двойки с меньшим показателем. Вместо предложения . пользуемся предложением ..
Справедливость следующего предложения проверяется непосредственно.
Предложение .. Если в условиях теорем . и . предположить, что c = 0, то получим соответственно f (n) = O(nlog2 (v +w) ) и
f (n) = Ω(nlog2 (v +w) ).
Пример .. Вновь рассмотрим сложности рекурсивной сортировки слияниями и бинарного возведения в степень. Уравнение
(.) представим как систему двух неравенств со знаками соответственно ¶ и ¾. Применяя к ним теоремы . и . (v + w = 2,
log2 (v + w) = d = 1), из первой теоремы получаем TeMS (n) = O(n log n),
из второй — TeMS (n) = Ω(n log n). В итоге имеем TeMS (n) = Θ(n log n).
Аналогичным образом представим в виде системы двух неравенств
уравнение (.). Заменим в правой части n − 1 на n в случае ¶ и на
n
в случае ¾. Очевидно, что полученные неравенства являются след2
ствиями исходных. С помощью теорем . и . (вновь v + w = 2,
log2 (v + w) = d = 1) получаем TMS (n) = O(n log n) и TMS (n) = Ω(n log n).
В итоге имеем TMS (n) = Θ(n log n).
Сложность рекурсивной сортировки слияниями как по числу сравнений, так и по числу перемещений элементов массива допускает
оценку Θ(n log n).
Применяя теоремы . и . к (.), (.) (теперь v + w = 1,
log2 (v + w) = d = 0), получим TRS (n) = O(log n) и TRS (n) = Ω(log n).
В итоге получаем TRS (n) = Θ(log n).
Асимптотические оценки TMS (n) = Θ(n log n), TeMS (n) = Θ(n log n),
TRS (n) = Θ(log n) можно было бы получить и из выведенных ранее
неравенств (.), (.), (.). Этот пример демонстрирует лишь
то, что теоремы о рекуррентных неравенствах позволяют быстро получать асимптотические оценки непосредственно из первоначальных
рекуррентных неравенств.
Пример .. Известен алгоритм построения выпуклой оболочки объединения двух выпуклых многоугольников, имеющих соответственно n1 и n2 вершин, со сложностью O(n1 + n2 ) по общему числу
операций, n1 + n2 рассматривается как размер входа этого алгоритма
(см. задачу ). Стратегия «разделяй и властвуй» позволяет, исходя
из этого, описать алгоритм построения выпуклой оболочки данного



Глава . Рекуррентные соотношения и сложность алгоритмов

множества n точек, сложность которого по общему числу операций
при выборе n в качестве размера входа определяется соотношением
(
0,j k
если n = 1,
l m
T(n) =
n
n
+T
+ O(n) при n → ∞.
T
2

2

От этого соотношения мы переходим к неравенству
(
0,j k
если n = 1,
l m
T(n) ¶
n
n
T
+T
+ cn, если n > 1,
2

2

где c — некоторое неизвестное нам положительное число, — мы пользуемся здесь тем, что если g(n) = O(h(n)) и h(n) > 0 при n > 1, то
g(n) ¶ ch(n) для некоторой константы c и всех n > 1.
Применяем теорему . (v + w = 2, log2 (v + w) = 1, d = 1). Это дает T(n) = O(n log n). Мы имеем, таким образом, еще один алгоритм
построения выпуклой оболочки n заданных точек, по общему числу
операций имеющий сложность O(n log n).
Теоремы о рекуррентных неравенствах в некоторых книгах формулируется иначе (см. задачу ). Иногда  в условии этой теоремы
предполагается, что исследуемая сложность является неубывающей
функцией от n. Перед тем как применять теорему в таком ее виде
к сложности конкретного алгоритма, необходимо доказывать неубывание этой сложности. Неубывание не является самоочевидным фактом для алгоритмов, построенных по стратегии «разделяй и властвуй». Например, для бинарного алгоритма вычисления an это не так:
TRS (7) = 4, TRS (8) = 3. В теоремах . и . неубывание не предполагается.
Еще одно замечание. В §  мы получали формулы и оценки для
сложностей алгоритма бинарного поиска места элемента, сортировки фон Неймана и т. д. путем сравнения возникающих величин с последовательностью 2l , l = 0, 1, ...; этот прием во многом аналогичен
использованию соотношений вида (.), (.), но в том лишь частном случае, когда одно из чисел v, w равно нулю.
§ . Добавление нулей
Ряд алгоритмов целочисленной арифметики и теории матриц оказывается достаточным (без нанесения сколь-либо существенного ущерба идее алгоритма и его качеству) описать для случая, когда размер


См., например, [].

§ . Добавление нулей



входа есть число вида 2k . При использовании стратегии «разделяй
и властвуй» это облегчает и описание алгоритма, и анализ его сложности. С теоретической точки зрения для задачи умножения двух целых чисел a и b мы можем предполагать, что битовая длина каждого
из данных чисел равна 2k , где
k = max{⌈log2 λ(a)⌉, ⌈log2 λ(b)⌉},

(.)

так как всегда возможно добавить спереди любого из данных чисел
некоторое количество нулей. Если речь идет об умножении квадратных матриц A и B произвольного порядка n, то мы можем добавить
к матрицам несколько нулевых строк и столбцов так, чтобы сделать
их порядки равными 2⌈log2 n⌉ :




A 0
B 0
AB 0
(.)
0 0
0 0
0 0
(нулями обозначены нулевые блоки соответствующего размера).
Несмотря на переход от начальных данных к более громоздким, некоторые из алгоритмов, основанных на стратегии «разделяй и властвуй» и использующих этот переход, имеют существенно меньшую
сложность, чем наивные алгоритмы.
Предложение .. Пусть вещественная функция f натурального
аргумента такова, что f (n) = f (2⌈log2 n⌉ ) для всех n ∈ N+ и
¨
u,
если k = 0,
k
f (2 ) ¶
wf (2k−1 ) + ϕ (2k ), если k > 0,
при k ∈ N, где u, w — вещественные числа, причем u ¾ 0, w ¾ 1, а ϕ —
неотрицательная функция, определенная для всех n ∈ N+ . Тогда при
всех n ∈ N+ выполняется неравенство
(
u, l m
если n = 1,
(.)
f (n) ¶
n
⌈log2 n⌉
+ ϕ (2
), если n > 1.
wf
2

Доказательство. Легко видеть, что
l mm
l
n
= ⌈log2 n⌉ − 1.
log2
2

(.)

l m
n
В самом деле, если 2k−1 < n ¶ 2k , k > 1, то 2k−2 <
¶ 2k−1 , т. е. ес2
l
l mm
n
ли ⌈log2 n⌉ = k, то log2
= k − 1. Для случая n = 2⌈log2 n⌉ неравен2
ство (.) выполнено по условию,
для остальных случаев используем
l m
n
= f (2⌈log2 ⌈n/2⌉⌉ ) = f (2⌈log2 n⌉−1 ).
равенства f (n) = f (2⌈log2 n⌉ ), f
2



Глава . Рекуррентные соотношения и сложность алгоритмов

Теорема .. Пусть вещественная функция f натурального аргумента такова, что f (n) = f (2⌈log2 n⌉ ) для всех n ∈ N+ и
¨
u,
если k = 0,
k
f (2 ) ¶
wf (2k−1 ) + c(2k )d , если k > 0,
при k ∈ N, где u, d ¾ 0, c > 0, w ¾ 1. Тогда при рассмотрении f как
функции, определенной для всех n ∈ N+ , выполняются оценки

d
O(n log n), если d = log2 w,
d
f (n) = O(n ),
если d > log2 w,

log2 w
O(n
),
если d < log2 w.
Доказательство следует из предложения . и теоремы ..
Подобно тому, как доказательство теоремы . было преобразовано в доказательство теоремы ., из приведенного выше доказательства мы можем получить доказательство следующей теоремы
Теорема .. Пусть вещественная функция f натурального аргумента такова, что f (n) = f (2⌈log2 n⌉ ) для всех n ∈ N+ и
¨
u,
если k = 0,
k
f (2 ) ¾
wf (2k−1 ) + c(2k )d , если k > 0,
где u, d ¾ 0, c > 0, w ¾ 1. Тогда для функции f (n), при рассмотрении
ее как функции, определенной для всех n ∈ N+ , выполнено

d
Ω(n log n), если d = log2 w,
log2 w
f (n) = Ω(n
),
если d > log2 w,

d
Ω(n ),
если d < log2 w.
Перейдем к примерам.
Пример . (умножение Карацубы). Пусть a и b — целые положительные числа битовой длины m = 2k . Положив l = 2k−1 , можем
записать
a = e2l + f , b = g2l + h,
где e, f , g, h — целые числа битовой длины l. А. А. Карацубе принадлежит замечательное наблюдение, позволяющее вычислить произведение ab, выполнив всего три умножения чисел половинной длины,
несколько сдвигов (домножений на 2m и 2l ) и несколько аддитивных
операций над числами битовой длины ¶ 2m:
ab = eg22l + ((e + f )(g + h) − eg − fh)2l + fh,

(.)

§ . Добавление нулей



тогда как обычное раскрытие скобок в (e2l + f )(g2l + h) требует выполнения четырех таких умножения:
ab = eg22l + (eh + fg)2l + fh.

(.)

Мы видим, что формула (.) использует произведения eg, fh,
(e + f )(g + h), а формула (.) — произведения eg, eh, fg, fh.
Небольшая проблема, которая выше была замаскирована словами «половинная длина», состоит в том, что битовая длина любого
из чисел e + f , g + h, входящей в произведение (e + f )(g + h), может
оказаться равной l + 1, а не l. Но если
e + f = e1 2l + f1 ,

g + h = g1 2l + h1 ,

где e1 , g1 — однобитовые числа (0 или 1), то
(e + f )(g + h) = e1 g1 22l + (e1 h1 + g1 f1 )2l + f1 h1 .

(.)

Произведение f1 h1 вычисляется рекурсивным обращением к алгоритму, произведения e1 g1 , e1 h1 , g1 f1 , как и все сложения и сдвиги, требуют O(l) операций.
Равенство (.) и предположение, что m = 2k , приводят к рекурсивному алгоритму Карацубы умножения целых положительных чисел (будем обозначать этот алгоритм буквами KM: первая из этих
букв — начальная в фамилии автора алгоритма, вторая — в английском слове multiplication — умножение). Предположение m = 2k приводит к следующему соотношению для битовой сложности умножения Карацубы:
(
1,  
если m = 1,
(.)
TKM (m) ¶
m
+ cm, если m > 1,
3TKM
2

где c — некоторая положительная константа.
Умножение Карацубы при произвольном входе a, b ∈ N+ размера m = max{λ(a), λ(b)} предполагает, что сначала мы находим k =
= ⌈log2 m⌉, затем добавляем спереди каждого из a, b некоторое количество нулей так, чтобы битовая длина каждого из сомножителей
стала равной 2k , а после этого используем рекурсивный алгоритм,
основанный на (.).
Мы можем применить теорему . (w = 3, d = 1), так как при
произвольном m ∈ N+ выполняется TKM (m) = TKM (2⌈log2 m⌉ ). Получаем
TKM (m) = O(mlog2 3 ),
при этом log2 3 = 1,58...

(.)



Глава . Рекуррентные соотношения и сложность алгоритмов
Для m > 1 мы имеем
TKM (m) > G(m),

(.)

где функция G натурального аргумента такова, что G(m) = G(2⌈log2 m⌉ )
для всех m ∈ N+ и
¨
1,
если k = 0,
k
G(2 ) =
3G(2k−1 ), если k > 0,
откуда TKM (m) = Ω(mlog2 3 ) по предложению .. Вместе с (.) это
дает
TKM (m) = Θ(mlog2 3 ).
(.)
При использовании m, равного максимальной из битовых длин двух
данных чисел a, b ∈ N+ , в качестве размера входа битовая сложность
умножения Карацубы допускает оценку
TKM (m) = Θ(mlog2 3 ),
при том, что TNM = Θ(m2 ) — оценка битовой сложности наивного
умножения  .
Стратегия добавления нулей особенно характерна для исследований, в которых главной целью служит преодоление некоторого сложностного барьера; последнее было и остается важным стимулом развития теории сложности.
Пример .. Алгоритм Штрассена умножения двух квадратных
числовых матриц A и B порядка n, являющегося степенью двойки,
основан на том, что если n = 2l и




A11 A12
B11 B12
A=
, B=
,
A21 A22
B21 B22
где все Aij , Bij — квадратные матрицы порядка l, то матрицу


C11 C12
C = AB =
C21 C22
можно получить, выполнив семь умножений квадратных матриц порядка l (при том, что потребовалось бы восемь таких умножений при

История создания алгоритма Карацубы и публикации о нем в  г. сообщения [] увлекательно рассказана в статье [] самого А. А. Карацубы; особенно богат
яркими историческими деталями раздел  этой статьи.

§ . Добавление нулей



использовании простейшего алгоритма, основанного на определении
произведения матриц):
X1 = (A11 + A22 )(B11 + B22 ),
X2 = (A21 + A22 )B11 ,
X3 = A11 (B12 − B22 ),
X4 = A22 (B21 − B11 ),

X5 = (A11 + A12 )B22 ,
X6 = (A21 − A11 )(B11 + B12 ),

X7 = (A12 − A22 )(B21 + B22 ),

далее используются только аддитивные операции:
C11 = X1 + X4 − X5 + X7 ,
C21 = X2 + X4 ,

C12 = X3 + X5 ,
C22 = X1 + X3 − X2 + X6 .

В правильности этого можно убедиться прямой проверкой.
Равенство n = 2k создает возможность для рекурсивного применения алгоритма. Алгоритм Штрассена будем обозначать начальными
буквами St фамилии его автора.
В приведенных формулах использовано восемнадцать сложений
матриц порядка l. Сложение двух матриц порядка l требует l 2 сложений чисел. В предположении, что n = 2k , k ∈ N, имеем для общего
числа операций — сложений и умножений чисел:
(
1,  
если n = 1,
 2
(.)
TSt (n) =
n
n
+ 18
, если n > 1.
7TSt
2

2

+

Если n ∈ N произвольно, то вначале к матрицам A и B добавляются нулевые строки и столбцы (см. (.)) так, чтобы порядки матриц стали равными 2⌈log2 n⌉ , а затем применяется описанный рекурсивный алгоритм. Рассматривая равенство (.) как систему двух
неравенств со знаками ¶ и ¾ и применяя теоремы . и ., получаем следующий результат.
Сложность TSt (n) по числу арифметических операций алгоритма
Штрассена перемножения двух числовых матриц порядка n допускает
оценку TSt (n) = Θ(nlog2 7 ), в то время как алгоритм, непосредственно
следующий из определения произведения матриц, имеет сложность
Θ(n3 ) (при этом log2 7 = 2,81...).
Что касается булевых матриц, то алгоритм Штрассена не может
быть непосредственно применен для их умножения по той, например, причине, что этим алгоритмом используется вычитание, для которого нет аналога в булевой арифметике. Но матрицы A и B порядка n, состоящие из нулей и единиц, можно перемножить как



Глава . Рекуррентные соотношения и сложность алгоритмов

целочисленные. Каждый элемент такого произведения не превосходит n, он равен нулю, если и только если соответствующий элемент произведения булевых матриц равен нулю. Для того, чтобы
в процессе применения алгоритма Штрассена к целочисленным матрицам не возникало больших промежуточных значений, здесь можно все вычисления проводить по модулю n + 1, т. е. проводить вычисления не в кольце Z, а в кольце Zn+1 . Если M(n) — некоторая верхняя граница для числа битовых операций, затрачиваемых
при выполнении одной операции сложения, вычитания или умножения в Zn+1 , то сложность модифицированного таким способом алгоритма Штрассена будет допускать оценку O(nlog2 7 M(n)). Наивное
умножение в Zn+1 дает M(n) = O(log2 n). Таким образом, M(n) растет очень медленно в сравнении с остальными затратами. Так как
log2 7 = 2,81... , мы можем использовать для сложности алгоритма
Штрассена, модифицированного на булев случай, например, оценку
e log2 7 ), — смысл «O мягкого» объяснялся в конO(n2,82 ) или оценку O(n
це § .
Применение алгоритма Штрассена и арифметики по модулю n + 1
дает алгоритм умножения двух булевых матриц порядка n, битовая
e log2 7 ) и O(n2,82 ).
сложность которого допускает оценки O(n
Мы ограничились рассмотрением применения стратегии «разделяй и властвуй» для случая, когда в результате этапа разделения возникают две задачи, и каждый из размеров входа примерно вдвое
меньше изначального размера. Иногда разделение приводит к трем
и более задачам.
В  г. А. Л. Тоом обобщил идею умножения Карацубы  . Пусть
s — большее единицы целое. Предполагая, что битовая длина m каждого из сомножителей имеет вид sk , k ∈ N, последовательность двоичных цифр каждого из сомножителей можно разбить на s групп по
sk−1 цифр. Тоом показал, что умножение исходных чисел сводится
к 2s − 1 умножениям чисел битовой длины sk−1 (в умножении Карацубы s = 2, 2s − 1 = 3), остальные затраты — сложения, сдвиги — будут
ограничены функцией cm, где c — зависящая от выбора s константа.
Здесь этап разделения приводит к 2s − 1 задачам. Для умножения Тоома (TM) неравенство
(
1,
если m = 1,
(s)
 
(.)
TTM (m) ¶
(s) m
+ cm, если m > 1,
(2s − 1)TTM
s



См. [], [].

§ . Добавление нулей



выполненное в случае m = sk , k ∈ N, и равенство
(s)
(s) ⌈logs m⌉
TTM
(m) = TTM
(s
),
(s)
выполненное при произвольном m ∈ N+ , приводят к оценке TTM
(m) =
= O(mlogs (2s−1) ) для битовой сложности алгоритма, использующего
разбиение на s частей. Может быть также показано, что
(s)
TTM
(m) = Θ(mlogs (2s−1) ).

(.)

Очевидно,




1
1
= 1 + logs 2 + logs 1 −
.
logs (2s − 1) = logs 2s 1 −
2s

2s

Отсюда
lim logs (2s − 1) = 1.

s→∞

Это означает, что для любого ǫ > 0 можно найти целое s ¾ 2 такое, что
умножение Тоома с разделением на s частей (битовая длина числа
предполагается равной sk , k ∈ N) будет иметь битовую сложность, допускающую оценку Θ(m1+δ ) при некотором δ таком, что 0 < δ ¶ ǫ ; разумеется, для битовой сложности этого алгоритма справедлива оценка O(m1+ǫ ).
Скажем коротко об основной идее алгоритма Тоома, приводящей
к неравенству (.). Если, как предполагалось, битовая длина каждого из сомножителей a, b есть sk , k ∈ N, то последовательность двоичных цифр каждого из сомножителей a, b можно разбить на s групп
по sk−1 цифр:
a s−1 , ..., a1 , a0 ; bs−1 , ..., b1 , b0 .
Сами сомножители a, b суть значения полиномов
A(x) = a s−1 x s−1 + ... + a1 x + a0 ,

B(x) = bs−1 x s−1 + ... + b1 x + b0

k−1

в точке x0 = 2s . Полином C(x), равный произведению A(x)B(x), есть
полином степени не выше чем 2s − 2 (мы не утверждаем, что эта
степень равна 2s − 2, так как возможно, что к изначально заданным
целочисленным сомножителям спереди дописывались нули), и достаточно знать значения C(x) в 2s − 1 точках (узлах интерполяции) для
того, чтобы затем, например, с помощью интерполяционной формулы Лагранжа найти значение
C(2s

k−1

),

(.)



Глава . Рекуррентные соотношения и сложность алгоритмов

равное ab. Тоом показал, что если в качестве узлов интерполяции
x1 , x2 , ..., x2s−1 взять числа
−(s − 1), −(s − 2), ..., −1, 0, 1, ..., s − 2, s − 1,

рекурсивно с помощью рассматриваемого алгоритма найти
A(xi ),

B(xi ), C(xi ) = A(xi )B(xi ),

i = 1, 2, ..., 2s − 1,

и затем, пользуясь интерполяционной формулой Лагранжа, найти
значение (.), то это приведет к (.), (.). Такое использование интерполяции заключает в себе требуемое обобщение алгоритма
Карацубы.
В  г. Шенхаге и Штрассен, основываясь на идее Тоома использования интерполяции полиномов в алгоритмах умножения целых
чисел, получили алгоритм умножения, битовая сложность которого
допускает оценку O(m log m log log m), мы уже упоминали этот алгоритм в § . Функция m log m log log m растет медленнее, чем m1+δ
при любом δ > 0. Улучшение достигнуто за счет привлечения интерполяции специального вида — так называемого быстрого преобразования Фурье  . До настоящего времени результат Шенхаге—Штрассена остается рекордным. Шенхаге на основе этого алгоритма умножения предложил алгоритм  нахождения íîä(a0 , a1 ), сложность которого допускает оценку O(m log2 m log log m), где m — битовая длина
большего числа a0 (в примере . было показано, что алгоритм Евклида имеет сложность Θ(m2 )).
Необходимо сказать, что преимущества по времени выполнения
рассмотренных алгоритмов перед наивным умножением и алгоритмом Евклида проявляются лишь при очень больших значениях m.
С умножением матриц положение таково, что обобщения алгоритма Штрассена в духе обобщения, предложенного Тоомом для алгоритма Карацубы, до сих пор не найдено. Используя другие идеи, Д. Копперсмит и С. Виноград в  г. предложили алгоритм со сложностью
O(n2,376 ), где n — порядок перемножаемых квадратных матриц  . Этот
результат остается рекордным по сей день. Существует ли для любого ǫ > 0 алгоритм умножения матриц со сложностью O(n2+ǫ ) — это
открытый вопрос.




Об алгоритме Шенхаге—Штрассена см., например, [, разд. .].
См., например, [, разд. .].
См. [].

Задачи



Задачи
. Игра «Ханойские башни». К горизонтальной доске приделаны
три вертикальных столбика. На первый нанизано n дисков, диаметры которых убывают вверх (рис. ). Требуется, перекладывая диски

Рис. . Игра «Ханойские башни». Исходное положение.

по одному, расположить их в прежнем порядке на третьем столбике. Ограничение состоит в том, что больший диск никогда не может
располагаться над меньшим. Разработать рекурсивный алгоритм решения этой задачи и определить его временную сложность по числу
перекладываний дисков.
. (Продолжение предыдущей задачи.) Требуется определить
временную сложность алгоритма перекладывания дисков в игре «Ханойские башни» при условии, что затраты на перекладывание со
столбика на столбик i-го по величине диска равна а) i; б) i 2 ; в) 2i .
. Сформулировать правило нахождения частного решения рекуррентного уравнения ad y(n) + ad−1 y(n − 1) + ... + a0 y(n − d) = f (n)
для случая, когда f (n) принимает постоянное значение c.
. Пусть функция f (n) определена для всех n ∈ N+ и пусть
a — ненулевое число. Любое определенное для всех n ∈ N решение
рекуррентного уравнения y(n) − ay(n − 1) = f (n) имеет вид y(n) =


n
P
f (k)
.
= an y(0) +
k
k =1

a

Указание. Индукция по n.

. Для чисел Фибоначчи выполнено равенство
n = 1, 2, 3, ...

n
P
i =1

Fi = Fn+2 − 1,

Указание. Решением рекуррентного уравнения y(n) − y(n − 1) = Fn , y(0) =
= 1, является y(n) = Fn+2 .



Глава . Рекуррентные соотношения и сложность алгоритмов

. Верно ли, что для любого полинома p(n) найдется полином
q(n) (оба с вещественными коэффициентами) такой, что q(n + 1) −
− q(n) = p(n), и если да, то как различаются степени полиномов p(n)
и q(n)?
. Найти множество всех вещественных последовательностей,
удовлетворяющих рекуррентному уравнению y(n + 1) + y(n) = 0.
. Вернемся к алгоритму VRec из § . Пусть 1 ¶ k ¶ n. Сколько
раз при построении множества Vn будет выполнено построение множества Vk ?
Ответ. Fn−k .

. Найти общее решение рекуррентного равенства (.) при
k = 1. Найти частное решение, удовлетворяющее условию y(0) = 0.
(При k = 1 рекурсия (.) не приводит к избыточным вычислениям
значений U.)
. Назовем перестановку z1 , z2 , ..., zn чисел 1, ..., n критической
длины n, если на ней достигается максимум числа сравнений, требуемых рекурсивной сортировкой слияниями для массивов длины n.
Пусть n > 1, а x1 , ..., xj⌊n/k
2⌋ и ly1 ,m..., y⌈n/2⌉ суть некоторые критические
перестановки длины
ответственно,

n
2

и

n
. Тогда числа z1 , z2 , ..., zn , равные, со2

2x1 , ..., 2x⌊n/2⌋ , 2 y1 − 1, ..., 2 y⌈n/2⌉ − 1
образуют критическую перестановку длины n (рис. ).

Рис. . Случай, когда при n = 7 для сортировки слияниями потребуется максимальное число сравнений.

. Как выглядят критические перестановки длины 6, 7, 8 и 9, полученные с помощью предложенного в предыдущей задаче подхода?

Задачи



. Имеет место равенство (.).
Указание. См. задачу .

. (Продолжение задачи , в которой фактически в рекурсивной форме описан алгоритм построения некоторой критической перестановки длины n.) Исследовать сложности описанного алгоритма
построения некоторой критической перестановки длины n по числу умножений на два и по числу вычитаний единицы. Предложить
нерекурсивный алгоритм (например, можно рассмотреть последовательное построение критических перестановок, длины которых суть
соответственно 1, 2, ..., n) и исследовать его сложности по названным
операциям.
. Чему равно наименьшее n вида 2k , для которого число сравнений при рекурсивной сортировке слияниями превосходит ⌈log2 n!⌉?
. Оценка (.) является следствием оценки TRS (n) = λ(n) +
+ λ∗ (n) − 2.
. Для сложности алгоритма бинарного поиска места элемента
в упорядоченном массиве обосновать рекуррентное неравенство
(
1, j k
если n = 1,
TBS (n) ¶
n
+ 1, если n > 1,
TBS
2

не прибегая к известному явному выражению для TBS (n). Из этого
рекуррентного неравенства получить оценку для TBS (n).
. Указать алгоритм построения пересечения n полуплоскостей
ai x + bi y + ci ¾ 0,

i = 1, 2, ..., n,

имеющий временную сложность Θ(n log n) по общему числу операций.
Указание. Пересечением будет выпуклый многоугольник (возможно, неограниченный). Опираясь на алгоритм Шеймоса—Хоя (задача ), использовать стратегию «разделяй и властвуй».

. По сравнению с теоремами ., . предложения ., .
представляют собой более сильные утверждения, имеющие к тому же
более широкое применение. Используя эти предложения, получить
асимптотические оценки для
(
0,j k
если n = 1,
l m
f (n) =
n
n
f
+f
+ ϕ (n), если n > 1,
2

2

при ϕ (n) = log2 n и ϕ (n) = n log2 n.



Глава . Рекуррентные соотношения и сложность алгоритмов

. Рекуррентное неравенство вида (.) может иметь более одного решения, однако во всех трех случаях, предусмотренных формулой (.), по крайней мере для одного решения соответствующая
оценка из (.) является точной.
. Обобщить предложенную в этой главе технику решения рекуррентных неравенств на случай, когда задача с размеромj входа
n
k
n
или
разбивается на s задач, размер каждой из которых — это
s
l m
n
, где s — некоторое натуральное число ¾ 2. Как будут выглядеть
s
теоремы ., . в этом случае?
. Доказать соотношение (.).
Указание. Рассмотреть количество умножений чисел битовой длины 1 в
процессе применения алгоритма Карацубы к входу размера m и показать,
что G(m) является для него нижней оценкой.

. а) Для любого ǫ > 0 можно указать N > 0 такое, что 3TKM (m) <
< TKM (2m) < (3 + ǫ )TKM (m) при всех m ¾ N.
б) Для любого ǫ > 0 можно указать N > 0 такое, что 7TSt (n) <
< TSt (2n) < (7 + ǫ )TSt (n) при всех n ¾ N.
Указание. См. (.), (.) и, соответственно, (.).

. Теоремы о рекуррентных неравенствах часто формулируются
иначе. Например, в [] и [] теорема дается, с точностью до обозначений и используемых слов, в следующем виде. Пусть s — целое
¾ 2, и при любом n вида sk , k = 1, 2, ..., вещественная функция f (n)
натурального аргумента удовлетворяет неравенству
 
n
f (n) ¶ wf
+ cnd ,
s

где w, c, d — константы, причем w > 0, c > 0, d ¾ 0. Пусть при этом
f (n) не убывает на каждом отрезке [sk−1 + 1, sk ]. Тогда

d
O(n log n), если d = logs w,
f (n) = O(nd ),
если d > logs w,

O(nlogs w ),
если d < logs w.
Доказать эту теорему. (Заметим, что в условии теоремы . нет требования неубывания f (n) на каждом отрезке [sk + 1, sk ], но зато требуется, чтобы, например, неравенство (.) выполнялось для всех n,
а не только для n вида 2k .)

Глава 

Сводимость

В этой главе мы рассматриваем только временную сложность алгоритмов и считаем, что размер входа — это неотрицательное целое
число.
§ . Линейная сводимость
Ниже в сопоставляемых друг с другом вычислительных задачах подразумеваются преобразования каких-то математических объектов,
представляемых одинаково для всех задач, участвующих в сопоставлении. Размер входа для алгоритмов решения рассматриваемых задач
тоже должен определяться единообразно. При сравнительном исследовании задач затраты на выполнение вычислений измеряются количеством операций из одного и того же набора (например, арифметических операций, битовых операций и т. д.).
Определение .. Пусть P и Q — две вычислительные задачи.
Если любому алгоритму AQ решения задачи Q можно сопоставить
такой алгоритм A P решения задачи P, что
TAP (n) = O(TAQ (n)),

(.)

то говорят, что задача P линейно сводится к задаче Q, и пишут P ¶ Q.
В специально оговариваемых случаях утверждение P ¶ Q предполагает, что рассматриваются лишь такие алгоритмы AQ , сложности которых удовлетворяют некоторым фиксированным условиям.
Слово «линейно» в этом определении означает лишь то, что сложность получаемого алгоритма A P не является, скажем, квадратом, кубом и т. д. сложности алгоритма AQ . Возможное присутствие условий
(ограничений) на сложности алгоритмов решения задачи Q облегчает или просто делает возможным доказательство (.). В то же время, предполагается, что эти ограничения отсекают нерациональные
алгоритмы; тогда смысл отношения P ¶ Q состоит в том, что каж-



Глава . Сводимость

дому приемлемому («хорошему») алгоритму решения задачи Q мы
можем сопоставить алгоритм решения задачи P такой, что выполнено (.).
Пример .. Будем рассматривать задачи умножения M и возведения в квадрат S неотрицательных целых чисел, заданных в двоичной системе, считая размером входа в первой задаче максимальную
из битовых длин чисел n1 , n2 , а во второй — битовую длину данного
числа n (будем обозначать этот размер через m), в качестве затрат
будем рассматривать битовые затраты.
Из равенства n2 = n · n следует, что S ¶ M, так как это равенство
дает требуемый определением . алгоритм. Дает ли равенство
n1 · n2 =

(n1 + n2 )2 − n21 − n22
2

(.)

основание считать, что M ¶ S? Битовая длина числа n1 + n2 может
оказаться равной m + 1. Если бы для возведения в квадрат использовался некоторый чрезвычайно нерациональный алгоритм, имеющий, скажем, сложность m!, то соответствующий алгоритм умножения имел бы сложность порядка (m + 1)!. Легко видеть, что равенство
(m + 1)! = O(m!) места не имеет. Можно пытаться определить умножение через возведение в квадрат как-то иначе, но можно и не отказываться от формулы (.): при установлении линейной сводимости
обычно считается, что сложность любого приемлемого алгоритма выполнения какой-либо мультипликативной арифметической операции
(умножения, возведения в квадрат, деления и т. д.) удовлетворяет, хотя бы для всех достаточно больших m, условиям
) T(m) ¾ m,
) T(m) не убывает при возрастании m,
) T(2m) ¶ 4T(m)
(условие  отсекает алгоритмы умножения, сложность которых растет
быстрее чем m2 ). Приняв, что сложность алгоритма AS удовлетворяет
этим условиям, мы имеем
TAS (m + 1) ¶ TAS (2m) ¶ 4TAS (m),
что дает TAM (m) = O(TAS (m)) для описанного с помощью (.) алгоритма умножения. Мы используем здесь то, что операции вычитания
и деления на 2 имеют сложность O(m), и то, что TAS (m) ¾ m по условию .
Таким образом, если принимаются ограничения — для сложностей алгоритмов решения задачи S, то M ¶ S.

§ . Линейная сводимость



Пример .. Из формулы (.) нельзя сделать вывода, что задача построения транзитивно-рефлексивного замыкания графа с n вершинами (или, в другой терминологии, транзитивно-рефлексивного
замыкания булевой матрицы порядка n) линейно сводится к задаче умножения двух булевых матриц порядка n, так как само число
умножений матриц в этой формуле существенно зависит от n. Но
мы покажем, что соответствующая линейная сводимость имеет место, если принять, что для любого из рассматриваемых алгоритмов
умножения булевых матриц порядка n его сложность B(n) (примем
это упрощенное обозначение) удовлетворяет, хотя бы для всех достаточно больших n, условиям
) B(1) = 1,
) B(n) не убывает при возрастании n,
) 4B(n) ¶ B(2n) ¶ 8B(n).
Комментарий к условию . Неравенство B(2n) ¶ 8B(n) отсекает
те алгоритмы умножения булевых матриц, сложность которых растет быстрее чем n3 . Алгоритм должен построить n2 элементов матрицы-произведения, поэтому его сложность не может расти медленнее
чем n2 , и в соответствии с этим в ограничения включается неравенство 4B(n) ¶ B(2n).
Для булевой матрицы X порядка n будем, как и прежде, обозначать ее транзитивно-рефлексивное замыкание через X ∗ .
Пусть G — ориентированный граф с n вершинами и C — его матрица смежности. Предположим вначале, что n — четное число: n = 2l.
Разобьем множество вершин V = {v1 , v2 , ..., v2l } графа G на два подмножества V1 = {v1 , v2 , ..., vl } и V2 = {vl +1 , vl +2 , ..., v2l }, а множество ребер графа G — на четыре подмножества E11 , E12 , E21 , E22 : начало каждого из ребер из множества E pq принадлежит Vp , а конец — Vq , где
p, q ∈ {1, 2}. Если исходная матрица C представлена в блочном виде


C11 C12
,
C21 C22
где каждый блок — это матрица порядка l, то матрица C pq несет полную информацию о ребрах из множества E pq . Рассмотрим пути в графе G, соединяющие вершины из множества V1 . Назовем ходом путь
из вершины в вершину этого множества, представляющий собой
• либо продвижение по ребру, принадлежащему E11 ,
• либо продвижение по ребру, принадлежащему E12 , за которым следует некоторый путь по ребрам из E22 и затем продвижение по
ребру, принадлежащему E21 .



Глава . Сводимость

∗
Непосредственно видно, что (i, j)-элемент матрицы C11 ∨ (C12 ∧ C22
∧ C21 )
равен 1, если и только если существует ход, соединяющий вершины
vi , vj ∈ V1 . При этом ясно, что из vi можно добраться в vj (vi , vj ∈ V1 ) по
ребрам графа G, если и только если существует последовательность ходов, приводящая из vi в vj , т. е. если и только если (i, j)-элемент матрицы
∗
(C11 ∨ (C12 ∧ C22
∧ C21 ))∗

равен 1. Обозначим эту матрицу F11 . Мы имеем


F11 F12
∗
C =
F21 F22
для некоторых матриц F12 , F21 , F22 , при этом матрица Fpq , p, q ∈ {1, 2},
несет информацию о существовании путей из вершин множества Vp
в вершины множества Vq . Рассуждениями, сходными с приведенными
выше, можно показать, что
∗
F12 = F11 ∧ C12 ∧ C22
,
∗
F21 = C22 ∧ C21 ∧ F11 ,

∗
∗
∗
F22 = C22
∨ (C22
∧ C21 ∧ F11 ∧ C12 ∧ C22
);

эти выражения удобны для вычисления матрицы C ∗ : четыре матрицы Fp,q , p, q ∈ {1, 2}, можно найти, выполнив два построения транзитивно-рефлексивных замыканий, шесть умножений и два сложения
матриц порядка l:
∗
U = C22
,
V = C12 ∧ U,
W = U ∧ C21 ,
F11 = (C11 ∨ (V ∧ C21 ))∗ ,

F12 = F11 ∧ V ,
F21 = W ∧ F11 ,

F22 = U ∨ (F21 ∧ V ).

Мы указали рекурсивный переход от матриц порядка 2l к матрицам
порядка l. Учитывая, что C ∗ = C для матрицы первого порядка, мы
получаем алгоритм вычисления C ∗ для случаев, когда порядок n матрицы равен 2k , k ¾ 0. Пусть для умножения булевых матриц используется алгоритм со сложностью B(n), которая удовлетворяет условиям —, приведенным в начале этого примера. Для n = 2k мы имеем следующее соотношение, которому будет удовлетворять сложность

§ . Линейная сводимость



T(n) полученного алгоритма построения транзитивно-рефлексивного
замыкания:
¨
0,
если k = 0,
k
T(2 ) ¶
(.)
k −1
k −1
2(k −1)
2T(2 ) + 6B(2 ) + 2 · 2
, если k > 0.
В силу условия  имеем B(2k−1 ) ¾ 4B(2k−2 ) при k ¾ 2. Дополнительное
использование условия  дает нам B(22k−1 ) ¾ 22(k−1) при k ¾ 1. Заменяя 22(k−1) во второй строке соотношения (.) на B(2k−1 ), получаем
¨
0,
если k = 0,
k
(.)
T(2 ) ¶
k −1
k −1
2T (2 ) + 8B(2 ), если k > 0.
Докажем по индукции, что
T(2k ) ¶ 4B(2k ),

k = 0, 1, ...

(.)

Для k = 0 это неравенство очевидно, так как T(1) = 0, B(1) = 1. Пусть
k > 0 и неравенство выполнено для k − 1. Тогда 2T (2k−1 ) ¶ 8B(2k−1 ), и,
как следствие (.), мы получаем T(2k ) ¶ 16B(2k−1 ). В силу условия 
1
мы имеем B(2k−1 ) ¶ B(2k ), откуда следует (.).
4

Если n не есть число вида 2k , то от матрицы C переходим к матрице


C 0
C′ =
,
0 Is
порядка 2k , взяв единичную матрицу I s некоторого порядка, меньшего чем порядок матрицы C. Таким образом, порядок матрицы C ′
меньше, чем 2n, т. е. 2k < 2n. Из (.) следует, что
T(n) = T(2k ) ¶ 4B(2k ).
Так как 2k < 2n и функция B(n) — неубывающая, получаем 4B(2k ) ¶
¶ 4B(2n). Отсюда
T (n) ¶ 4B(2n) ¶ 4 · 8 · B(n) = 32B(n)
для всех n и
T(n) = O(B(n)),

(.)

что и требовалось.
Из сказанного следует, что если использовать для умножения квадратных булевых матриц алгоритм со сложностью, растущей медленнее, чем n3 , и удовлетворяющей условиям —, то можно строить транзитивно-рефлексивное замыкание со сложностью, растущей медленнее, чем сложность алгоритма Уоршелла (пример .). Напомним, что



Глава . Сводимость

алгоритм Штрассена умножения матриц, модифицированный для буe log2 7 ). Но для небольлева случая (пример .), имеет сложность O(n
ших значений n условия — здесь выполняться не будут. Однако соотношение (.) можно доказать при более слабых предположениях, чем использованные выше, и обсуждавшееся доказательство не потребует больших изменений. А именно, достаточно предположить, что
B(n) удовлетворяет условиям — для n > n0 , где n0 — некоторое натуральное число (см. задачу б). Получится оценка T(n) ¶ cB(n), где
c зависит от B(n0 ), но эта зависимость не влияет на (.).
Для нахождения транзитивно-рефлексивного замыкания ориентированного графа с n вершинами существует алгоритм, сложность коe log2 7 ).
торого допускает оценку O(n2,82 ), или, более точно, оценку O(n
Как показывает последний пример, если P ¶ Q, то прогресс в умении быстро решать задачу Q может в некоторых случаях обеспечить
прогресс и в умении быстро решать задачу P. Но это не всегда так.
Допустим, что n является нижней границей сложности для алгоритмов решения задачи Q и в то же время для задачи P имеется алгоритм решения со сложностью, меньшей n. Согласно определению .
мы имеем P ¶ Q, но наличие этой линейной сводимости ничего не
дает для продвижения в умении быстро решать задачу P.
Отношение линейной сводимости, очевидно, рефлексивно. Если
не рассматривать упомянутых в определении . дополнительных
условий, то это отношение будет транзитивным. В тех случаях, когда
такие условия наложены, необходима осмотрительность: если для задач P, Q и R мы имеем P ¶ Q при некоторых условиях на сложность
алгоритмов решения Q, а также Q ¶ R при соответствующих условиях
на сложность алгоритмов решения R, то чтобы на основании этого
утверждать, что P ¶ R, надо дополнительно установить, что сложности тех алгоритмов решения задачи Q, которые сопоставляются алгоритмам решения задачи R, удовлетворяют условиям, налагаемым на
сложности алгоритмов решения задачи Q при доказательстве отношения P ¶ Q. Это обстоятельство иногда безосновательно игнорируется.
§ . Линейная сводимость и нижние границы сложности
Нижеприведенная теорема является следствием определения ..
Теорема .. Пусть задачи P и Q таковы, что P ¶ Q. Пусть
f (n) — асимптотическая нижняя граница сложности алгоритмов решения задачи P, и при этом соотношение P ¶ Q устанавливается без

§ . Линейная сводимость и нижние границы сложности



наложения ограничений на сложность алгоритмов решения задачи Q.
Тогда f (n) является асимптотической нижней границей сложности
алгоритмов решения задачи Q.
Доказательство. Для каждого алгоритма AQ решения задачи Q
найдется такой алгоритм A P решения задачи P, для которого TAP (n) =
= O(TAQ (n)), или, эквивалентно, TAQ (n) = Ω(TAP (n)). Но TAP (n) =
= Ω( f (n)), следовательно, TAQ (n) = Ω( f (n)).
Если при соблюдении условия этого предложения для какого-то
алгоритма AQ решения задачи Q имеет место оценка TAQ (n) =
= O( f (n)), то этот алгоритм будет оптимальным по порядку сложности и TAQ (n) = Θ( f (n)). (При наличии ограничений на сложность
алгоритма AQ , когда фактически предполагается, что AQ принадлежит некоторому классу Q , речь должна бы идти об оптимальности
по порядку сложности в классе Q ; но если ограничения таковы, что
в класс Q попадают наиболее рациональные алгоритмы, то упоминание класса Q не обязательно.)
Пример .. Вновь рассмотрим задачу построения выпуклой оболочки конечного множества точек с помощью арифметических операций и сравнений. Многоугольник, являющийся выпуклой оболочкой,
представляется массивом своих вершин в порядке их следования при
обходе в некотором направлении, обычно против часовой стрелки,
начиная с некоторой вершины. Мы покажем, что задача сортировки
массивов вещественных чисел с помощью арифметических операций
и сравнений линейно сводится к задаче построения выпуклой оболочки в этой постановке, считая, что в этих задачах затраты измеряются общим числом арифметических операций и сравнений. Но
если порядок вершин выпуклой оболочки, которую надо построить,
может быть произвольным, то задача меняется, и про нее мы ничего
не утверждаем.
Пусть x1 , x2 , ..., xn — данный массив попарно различных вещественных чисел. Решив задачу построения выпуклой оболочки множества точек с координатами
(x1 , x12 ), (x2 , x22 ), ..., (xn , xn2 )
(см. рис. ), мы можем, двигаясь по вершинам построенного многоугольника, найти вершину с наименьшей абсциссой, а затем построить массив вершин в порядке возрастания абсцисс. Сложность этой
дополнительной части работы допускает оценку O(n). Легко видеть,
что сложность любого алгоритма построения выпуклой оболочки не



Глава . Сводимость
y

y = x2

...

...

x
Рис. . Сведение сортировки чисел x1 , x2 , ..., xn , отмеченных на оси абсцисс,
к построению выпуклой оболочки точек (x1 , x12 ), (x2 , x22 ), ..., (xn , xn2 ).

может быть меньше чем n. Таким образом, каждому алгоритму A
построения выпуклой оболочки мы сопоставляем алгоритм сортировки со сложностью O(TA (n)). Следовательно, задача сортировки вещественных чисел с помощью арифметических операций и сравнений
линейно сводится к задаче построения выпуклой оболочки.
Из результатов §  следует, что любая сортировка с помощью
сравнений массивов длины n имеет сложность не менее log2 n!. Но
при построении выпуклой оболочки используются как сравнения, так
и арифметические операции. Можно ли, привлекая помимо операций сравнения еще и арифметические операции, предложить алгоритм сортировки массивов вещественных чисел, сложность которого
по числу сравнений была бы меньше, чем log2 n!, пусть даже при том,
что потребовалось бы очень большое число арифметических операций? Ниже мы обосновываем отрицательный ответ на этот вопрос.
Дополнительное использование четырех арифметических операций означает, что сравниваться могут не только числа x1 , x2 , ..., xn ,
заданные изначально, но и значения рациональных функций от этих
чисел. В качестве знаков сравнения могут использоваться
<, >, =, 6=, ¶, ¾ .

Каждая рациональная функция F(x1 , x2 , ..., xn ) записывается как
отношение двух полиномов
F(x1 , x2 , ..., xn ) =

p(x1 , x2 , ..., xn )
q(x1 , x2 , ..., xn )

(.)

§ . Линейная сводимость и нижние границы сложности



(в этом параграфе мы рассматриваем рациональные функции и
полиномы с вещественными коэффициентами). Каждый полином
f (x1 , x2 , ..., xn ) можно рассматривать как рациональную функцию
f (x1 , x2 , ..., xn )
.
1

Предполагается, что если алгоритм предписывает сравнение, в котором участвует значение рациональной функции (.), то ее знаменатель q(x1 , x2 , ..., xn ) не обращается в  при рассматриваемых значениях x1 , x2 , ..., xn . Неравенство F1 (x1 , x2 , ..., xn ) < F2 (x1 , x2 , ..., xn ) равносильно, очевидно, неравенству F(x1 , x2 , ..., xn ) < 0, где
F(x1 , x2 , ..., xn ) = F1 (x1 , x2 , ..., xn ) − F2 (x1 , x2 , ..., xn ).
То же самое для сравнений со знаками >, =, 6=, ¶, ¾.
Далее будут использоваться два свойства рациональных функций:
(R) Множество точек (x1 , x2 , ..., xn ) ∈ Rn , для которых данная рациональная функция (.) неопределена или равна нулю, является
замкнутым; в свою очередь, те точки, в которых эта функция определена и имеет значение большее (меньшее) нуля, образуют открытое
множество. Это следует из того, что рациональная функция непрерывна на своем множестве определения.
(R) Если рациональная функция (.) определена и равна нулю
всюду на некотором непустом открытом подмножестве множества Rn ,
то ее числитель p(x1 , x2 , ..., xn ) является нулевым полиномом (см. задачу ).
Предложение .. Функция f (n) = ⌈log2 n!⌉ является нижней границей сложности по числу сравнений алгоритмов сортировки массивов длины n попарно различных вещественных чисел c помощью сравнений и четырех арифметических операций.
Доказательство.  Каждой из перестановок a = (a1 , a2 , ..., an ) ∈ Πn
сопоставим сектор Sa — подмножество пространства Rn такое, что
(x1 , x2 , ..., xn ) ∈ Sa , если и только если числа x1 , x2 , ..., xn попарно различны и их относительный порядок совпадает с относительным порядком чисел a1 , a2 , ..., an . Любой сектор является открытым множеством в Rn . Каждому массиву вещественных чисел с попарно различными элементами x1 , x2 , ..., xn соответствует точка некоторого

Идея элементарного доказательства сообщена автору С. П. Поляковым. Наиболее
раннее (довольно трудное для понимания) доказательство было опубликовано H. Фридманом в [].



Глава . Сводимость

сектора пространства Rn . В примере . говорилось, что при фиксированном n любую сортировку массивов длины n можно представить
в виде дерева, каждой не являющейся листом вершине v которого
приписано сравнение вида xi < x j , а выходящие из нее ребра имеют метки 1 («да») и 0 («нет»); при этом каждому листу l приписан
набор xi1 , xi2 , ..., xin , где (i1 , i2 , ..., in ) — некоторая перестановка чисел
1, 2, ..., n.
Алгоритм сортировки массивов длины n c помощью сравнений
и четырех арифметических операций представляется деревом D,
которое можно считать таким, что каждой не являющейся листом вершине v приписано сравнение Fv (x1 , x2 , ..., xn ) с нулем, где
Fv (x1 , x2 , ..., xn ) — некоторая рациональная функция, а выходящие из
вершины ребра имеют метки 1 («да») и 0 («нет»). При этом каждому
листу l приписаны рациональные функции
Gl1 (x1 , x2 , ..., xn ),

Gl2 (x1 , x2 , ..., xn ), ...,

Gln (x1 , x2 , ..., xn ),

(.)

значения которых для исходных x1 , x2 , ..., xn определяют требуемый
порядок xi1 , xi2 , ..., xin :
xi1 = Gl1 (x1 , x2 , ..., xn ),
xi2 = Gl2 (x1 , x2 , ..., xn ),
.......................
xin = Gln (x1 , x2 , ..., xn ).
Можно считать, что числитель каждой из функций Fv (x1 , x2 , ..., xn )
не является нулевым полиномом, — в противном случае вершину v
можно было бы удалить из дерева вместе с выходящей из нее ветвью, начинающейся с помеченного единицей ребра. Множество N
тех точек Rn , в которых обращается в нуль числитель хотя бы одной
из рациональных функций Fv (x1 , x2 , ..., xn ), в силу свойства (R) является замкнутым, причем это множество не может покрывать целиком
ни один из секторов. Иначе в силу свойства (R) произведение всех
числителей рассматриваемых рациональных функций было бы нулевым полиномом, а это означало бы, что один из сомножителей этого
произведения — нулевой полином.
Таким образом, каждое из множеств
S′i = Si \ N,

i = 1, 2, ..., n!,

есть непустое открытое множество. Покажем, что для массивов, соответствующих точкам из S′i , i = 1, 2, ..., n!, рассматриваемая сортировка
в худшем случае требует не менее ⌈log2 n!⌉ сравнений.

§ . Классы P и NP



Будем говорить, что точка (x1 , x2 , ..., xn ) некоторого сектора согласуется с листом l дерева D, если соответствующая дереву D сортировка массива x1 , x2 , ..., xn заканчивается в листе l.
В том случае, когда D имеет не менее n! листьев, мы, рассуждая
так же, как в примере ., получаем, что высота дерева D (сложность сортировки по числу сравнений) не может быть меньше чем
⌈log2 n!⌉. Допустим, что число листьев дерева D меньше чем n!. Тогда
найдется лист l такой, что имеются точки в двух разных множествах
S′i , S′j , согласующиеся с l. В силу свойства (R) найдутся непустые
открытые множества U1 ⊂ S′i , U2 ⊂ S′j такие, что любая точка, принадлежащая какому-то одному из них, согласуется с листом l. Если листу l приписан массив (.), то для некоторых целых k, s, t, не меньших единицы и не превосходящих n, таких, что s 6= t, будем иметь
Gk (x1 , x2 , ..., xn ) = x s при (x1 , x2 , ..., xn ) ∈ U1 и Gk (x1 , x2 , ..., xn ) = xt при
(x1 , x2 , ..., xn ) ∈ U2 . Но значения рациональной функции на одном из
множеств U1 , U2 однозначно определяют значения этой рациональной функции всюду на U1 ∪ U2 (это выводится из свойства (R)),
поэтому из того, что, например, Gk (x1 , x2 , ..., xn ) = x s на U1 , следует,
что Gk (x1 , x2 , ..., xn ) = x s на U2 . Но мы знаем, что Gk (x1 , x2 , ..., xn ) = xt
на U2 . Так как s 6= t, то в любом секторе x s 6= xt , в частности, это так
и в секторе, подмножеством которого является U2 . Противоречие.
Из доказанного предложения следует, что f (n) = n log n является
асимптотической нижней границей сложности алгоритмов сортировки массивов длины n попарно различных вещественных чисел c помощью сравнений и четырех арифметических операций. По теореме . эта функция является также асимптотической нижней оценкой для алгоритмов построения выпуклой оболочки.
Любой алгоритм построения выпуклой оболочки с помощью
арифметических операций и сравнений, который имеет сложность
O(n log n), является оптимальным по порядку сложности по общему
числу операций, и его сложность есть Θ(n log n). Алгоритм Грэхема
построения выпуклой оболочки (пример .) является оптимальным по порядку сложности по общему числу операций, коль скоро
используемая им сортировка имеет сложность O(n log n) по числу
сравнений.
§ . Классы P и NP
Цель этого и следующих параграфов — дать общее, без многих деталей, представление о некоторых проблемах, касающихся алгоритмов



Глава . Сводимость

полиномиально ограниченной сложности (см. § , определение .)
или, другими словами, полиномиальных алгоритмов.
Подход, согласно которому алгоритмы подразделяются на полиномиальные и все остальные, далеко не всегда является продуктивным с практической точки зрения (алгоритм со сложностью n100 , где
n — размер входа, вряд ли найдет массовое применение), но при более широком взгляде этот подход имеет свою логику. Если для решения важной задачи никак не удается найти алгоритм, сложность
которого хотя бы при каком-нибудь показателе d допускала бы оценку O(nd ), то сам вопрос о существовании такого алгоритма нельзя
назвать праздным.
Иногда бывает очень трудно установить принадлежность или соответственно непринадлежность задачи классу P, состоящему из таких задач, для которых существует полиномиальный алгоритм решения. В классе P выделяют подкласс P тех вычислительных задач,
где результатом может быть лишь 1 или 0, т. е. фактически «да» или
«нет», что типично для задач распознавания. К этим задачам относится, например, задача распознавания выполнимости булевой формулы, задача распознавания существования в графе гамильтонова цикла и т. д. Неизвестно, существуют ли полиномиальные алгоритмы их
решения, но сравнительно легко устанавливается их принадлежность
специальному классу NP. Определение класса NP будет дано ниже, из
него будет следовать, что P ⊂ NP. Если бы было доказано, что P = NP,
то в широком спектре случаев мы бы легко устанавливали принадлежность задачи распознавания классу P, т. е. устанавливали бы существование полиномиального алгоритма распознавания; его разработка — это отдельный вопрос. Но равенство P = NP по сей день не
доказано, и есть основания подозревать, что оно неверно. Возникает
?
проблема P = NP, о которой мы тоже будем говорить.
Вначале скажем о ряде ограничений, налагаемых на рассматриваемые задачи. Во-первых, речь будет идти о задачах распознавания тех
слов в данном алфавите Λ, которые принадлежат оговоренному подмножеству (языку) L множества всех слов Λ∗ в этом алфавите. Все
объекты, о которых идет речь в рассматриваемых задачах, должны
быть представлены (закодированы) словами в алфавите Λ, входом
алгоритма является одно-единственное слово в алфавите Λ. Размер
входа x — это всегда длина | x | (число букв) в слове x. Вычислительные затраты должны учитываться достаточно тщательно, неучтенной
может оставаться лишь незначительная часть операций (во всяком
случае, допускающая полиномиальную верхнюю оценку). Если имеется в виду модель вычислений РАМ, то предполагается, что вычисле-

§ . Классы P и NP



ния выполняются на базе конечного множества операций с тем или
иным числом операндов, преобразующих буквы алфавита Λ в буквы
алфавита Λ; исследуется сложность по числу этих операций — подобие битовой сложности. Требуется также учет числа присваиваний
в ходе выполнения алгоритма.
Таким образом, содержательная задача распознавания (например,
задача существования пути с фиксированными свойствами в заданном графе) должна быть для обсуждения ее принадлежности классам
P и NP переформулирована в виде задачи распознавания принадлежности заданного слова некоторому языку. Такая формализация необходима потому что одна и та же математическая идея при одном из
двух разных способов представления данных может приводить к полиномиальному алгоритму, а при другом — нет.
?
Часто при обсуждении проблемы P = NP исходят из машины Тьюринга (МТ) как модели вычислений, при этом вычислительные затраты измеряются числом тактов работы машины. Это связано с тем,
что модель МТ удобнее модели РАМ при доказательстве разного рода теорем об алгоритмах, в особенности — теорем о невозможности
алгоритмов с теми или иными свойствами. Но модель РАМ ближе,
чем МТ, к реальным вычислительным устройствам, и хотелось бы,
чтобы результаты исследования классов P и NP, проводимые на основе модели МТ, сохраняли свою значимость для модели РАМ. Их
значимость действительно сохраняется, о чем будет сказано в конце
этого параграфа, а до той поры мы, как правило, не будем делать
уточнений относительно модели вычислений. Но, повторяем, операции преобразования букв, входящих в слова, должны подсчитываться
тщательно.
По сути дела, в каждой задаче распознавания принадлежности
слова языку L обсуждается некоторый предикат u(x), областью определения которого является все множество Λ∗ , и u(x) = 1, если и только если x ∈ L. В дальнейшем нам часто будет удобно говорить не
о языках, а о предикатах (по существу, это, конечно, одно и то же, но
предикаты несколько предпочтительнее из-за того, что к ним можно
применять логические операции, кванторы и т. д.). Соответственно,
мы будем говорить о принадлежности предиката классу P и т. д. Иногда нам будет удобно рассуждать о предикатах не одной, а нескольких
таких переменных, которые принимают значения в Λ∗ . В этих случаях без специального упоминания предполагается, что в алфавит Λ
включены некоторые разделители: если, скажем, разделитель «запятая» (т. е. «,») включен в Λ, то v(x, y) имеет один аргумент x, y, где
x и y суть слова в Λ∗ , не содержащие разделителя «,» (кавычки по-



Глава . Сводимость

ставлены, чтобы не нарушать пунктуацию фразы). Соответственно,
длиной пары слов x, y является | x | + | y | + 1.
Теперь обсудим класс предикатов NP. Само его странное обозначение NP есть не что иное, как аббревиатура от английских
слов nondeterministic polynomial — недетерминированный полиномиальный. Изначальное определение класса NP, появившееся в теории
сложности в начале -х годов XX столетия, опиралось на понятие
недетерминированного алгоритма  . Позднее появилось эквивалентное определение, не прибегающее к недетерминированности.
Определение .. Заданный на Λ∗ предикат u(x) принадлежит
классу NP, если существуют предикат R(x, y) ∈ P и полином p(n) такие, что u(x) можно представить в виде
u(x) = ∃ y ∈Λ∗ ,| y |¶ p(| x |) R(x, y).

(.)

В том случае, когда u(x) = 1, слово y называется сертификатом слова x.
Пример .. Булева формула f (x1 , x2 , ..., xn ) выполнима, если существуют значения x10 , x20 , ..., xn0 ∈ {0, 1} переменных x1 , x2 , ..., xn такие, что
f (x10 , x20 , ..., xn0 ) = 1;
в противном случае булева формула невыполнима. Так, булева формула
¬(¬ x 1 ∨ x 2 )
(.)
выполнима, так как ее значение при x1 = 1, x2 = 0 равно 1, а булева
формула x1 ∧ ¬ x1 одной переменной x1 невыполнима, так как и при
x1 = 1, и при x1 = 0 значение этой формулы есть 0.
Любая булева формула может быть закодирована словом в алфавите
Λ1 = {x, 0, 1, (, ), ¬, ∧, ∨},
для этого переменные x1 , x2 , x3 , ... кодируются как x1, x10, x11, ...:
вслед за буквой x помещается номер переменной в двоичной системе. Формула (.) кодируется как ¬(¬ x1 ∨ x10), при этом, например,
слово )x1x ¬ в алфавите Λ1 не является кодом какой-либо булевой
формулы. Можно предложить простой алгоритм, который проверяет,
является ли данное слово в алфавите Λ1 кодом какой-либо булевой
формулы, а также алгоритм, который по данному коду некой булевой формулы и данным булевым значениям (нулям и единицам) тех


См., например, [].

§ . Классы P и NP



переменных, которые фактически присутствуют в этой формуле, находит ее значение. На основе этих двух алгоритмов можно построить
алгоритм, который по данному слову x ∈ Λ∗1 и слову y, являющемуся конечной последовательностью нулей и единиц, проверяет, верно
ли, что
(a) x является кодом некоторой булевой формулы,
(b) значение закодированной словом x булевой формулы при тех
значениях фактически присутствующих в ней переменных, которые
последовательно указаны в слове y, равно 1.
(Число нулей и единиц в слове y равно числу переменных, фактически присутствующих в закодированной булевой формуле: например, в булевой формуле x3 ∨ x15 фактически присутствуют две переменные, хотя для них и использованы большие индексы; сертификатом выполнимости этой формулы служит, например, слово 11.) Такой алгоритм можно сделать полиномиальным. Это говорит о том,
что при указанном способе кодирования булевых формул предикат,
распознающий выполнимость булевой формулы, принадлежит классу NP, — сертификатом является слово y, указывающее значения переменных, при которых значение булевой формулы равно 1, а значение предиката R(x, y), входящего в (.), вычисляется с помощью
алгоритма, проверяющего (a) и (b). Полином p(n) можно взять равным n, так как | y | ¶ | x | в силу того, что y содержит значения только
тех переменных, которые фактически присутствуют в булевой формуле.
Неизвестно, принадлежит ли классу P предикат на словах из Λ∗1 ,
распознающий выполнимость. Алгоритмы проверки выполнимости,
основанные на переборе всех возможных комбинаций значений переменных x1 , x2 , ..., xn , не являются полиномиальными.
Рассмотренный пример дает мотивацию определения . и проясняет смысл понятия «сертификат». Отметим два важных момента.
) Перебор всех возможных слов y, | y | ¶ p(| x |), для проверки
равенства u(x) = 1 с помощью (.) может потребовать рассмотрения экспоненциального по отношению к | x | числа возможностей. Но
определение . требует лишь, чтобы при u(x) = 1 сертификат существовал, вопрос же о сложности его построения не затрагивается.
) Если u ∈ NP, то равенство u(x) = 0 означает, что соответствующего сертификата для слова y не существует. Другими словами,
принадлежность x множеству истинности предиката подтверждается
сертификатом, а непринадлежность — отсутствием сертификата. По-



Глава . Сводимость

этому возможные значения 1 и 0 не являются симметричными или
равноправными; как показано в примере ., предикат, распознающий выполнимость булевой формулы, принадлежит NP, но мы не
можем на основе только этого утверждать, что и предикат, распознающий невыполнимость булевой формулы, принадлежит NP (какое
слово могло бы быть сертификатом невыполнимой формулы?).
Предложение .. P ⊆ NP.
Доказательство. Определим R(x, y) = u(x) в (.) при любом слове y и будем считать пустое слово сертификатом любого x такого,
что u(x) = 1; в качестве полинома p берем нулевой полином.
Продолжим рассмотрение примеров.
Пример .. Согласно результатам Агравала, Кайала и Саксены
(пример .), классу P принадлежит предикат, определенный на словах в алфавите {0, 1} и принимающий значение 1, если и только если
слово является записью простого числа. Рассмотрим близкую задачу.
Для заданных n, k ∈ N+ , k < n, выяснить, имеется ли у числа n делитель l такой, что 1 < l ¶ k. Числа n и k задаются в двоичной системе;
используя разделитель «;», мы можем кодировать пару n, k словом
в алфавите
Λ2 = {0, 1, ; }.
Если слово x кодирует указанным образом пару n, k, то в качестве
сертификата можно взять двоичную запись некоторого конкретного
делителя l, 1 < l < k. Тогда входящий в (.) предикат R(x, y) должен
принимать значение 1, если и только если
(a) x является кодом пары n, k, удовлетворяющей сформулированным выше условиям,
(b) y является двоичной записью некоторого числа l такого, что
l ¶ k и при этом l | k.
Существует алгоритм проверки условий (a), (b), вычислительные затраты которого ограничены величиной C(| x | + | y |)2 , где C — некоторая константа. Можно в (.) положить p(n) = n, так как l ¶ k. Это
говорит о том, что рассматриваемый предикат на Λ∗2 принадлежит
классу NP. Неизвестно, принадлежит ли он также классу P.
Пример .. В связи с изучением классов P и NP рассматривается большое число задач на графах, при этом графы, как правило,
задаются матрицами смежности. В алфавите Λ2 матрица смежности

§ . Существование задач распознавания, не принадлежащих P



кодируется словом, в котором строки матрицы выписаны одна за другой через разделитель «;». Легко видеть, что классу NP принадлежит
предикат, принимающий значение 1, если и только если слово является кодом графа, обладающего гамильтоновым циклом, т. е. циклом, проходящим по одному разу через все вершины графа (рис. );

а)

б)

Рис. . а) Гамильтонов цикл; б) граф без гамильтонова цикла.

сертификатом может, например, являться последовательность двоичных номеров вершин гамильтонова цикла. Эти номера выписываются
в одно слово через разделитель «;».
Аналогичным образом, классу NP принадлежит предикат, принимающий значение 1, если и только если слово является кодом графа,
обладающего кликой с заданным числом m вершин. При этом кликой называется набор m вершин, любые две из которых соединены
ребром (в изображенном на рис. а графе имеется несколько клик
с тремя вершинами, но нет ни одной с четырьмя вершинами). Исходные данные кодируются словом в алфавите Λ2 : сначала идет матрица
смежности, записанная так, как было сказано выше, затем, после разделителя «;», — число m в двоичной системе. Эта задача принадлежит
классу NP, сертификатом может быть слово, составленное из двоичных номеров вершин клики, перечисленных через разделитель «;».
Относительно обоих этих предикатов на Λ∗2 неизвестно, принадлежат ли они классу P.
§ . Существование задач распознавания, не принадлежащих P.
Связь моделей МТ и РАМ
Возникает вопрос, существуют ли вообще задачи распознавания принадлежности слов некоторому языку, разрешимые алгоритмически,
но не принадлежащие P. Один из первых примеров задачи такого рода в  г. был обнаружен М. Фишером и М. Рабином. Этот пример
связан с так называемой арифметикой Пресбургера. Рассматривают-



Глава . Сводимость

ся логические формулы, записанные с соблюдением обычных синтаксических правил с помощью некоторого числа переменных, знаков +, =, логических связок ∨, ∧, ¬ и скобок; при этом каждая переменная должна быть связана одним из кванторов ∀, ∃, а множеством
значений переменных является N. Каждая такая формула, трактуемая
как утверждение о неотрицательных целых числах, имеет значение
«истина» или «ложь» (1 или 0). Арифметика Пресбургера — это совокупность всех истинных формул указанного вида. Так, формулы
∀ x ∃ y (x + y = x),

∀ x ∀ y (x + y = y + x) ∧ ¬(∀ x ∃ y (x + y = y))

принадлежат арифметике Пресбургера, а формула ∀ x ∃ y (x + y = y) —
нет. Как и ранее, мы будем использовать переменные, имеющие вид
буквы x, за которой следует некоторое двоичное число (номер переменной). В алфавите
Λ3 = {x, 0, 1, +, =, ∨, ∧, ¬, ∀, ∃, (, )}

формула ∀ x ∃ y (x + y = x) запишется в виде ∀ x1∃ x10(x1 + x10 = x1)
и т. д. М. Пресбургером было в  г. доказано существование алгоритма, который дает ответ на вопрос, является ли данное слово в алфавите Λ3 формулой арифметики Пресбургера (разумеется, основная
задача, решаемая этим алгоритмом, состоит в различении синтаксически правильных формул, принимающих значение 1 и соответственно 0; слова, не являющиеся синтаксически правильными формулами,
легко распознаются и отвергаются).
Теорема, доказанная в  г. Фишером и Рабином, может быть
сформулирована так (мы не приводим доказательства  ).
Теорема Фишера—Рабина. Существует константа c > 0 такая,
что для любого алгоритма A, распознающего среди всех слов из Λ∗3 те,
которые являются формулами арифметики Пресбургера, существует
целое n0 такое, что для любого n > n0 найдется слово из Λ∗3 длины n,
cn
для работы с которым алгоритму A потребуется более 22 вычислительных шагов.
Из теоремы Фишера—Рабина следует, что арифметика Пресбургера как предикат на Λ∗3 не принадлежит классу P.
В доказательстве теоремы Фишера—Рабина вычислительные шаги
соответствуют рассмотрению MT в качестве модели вычислений.
С помощью модели МТ доказывается, например, и теорема о том,
что если t(n) — вычислимая с помощью некоторой машины Тьюринга


См. [].

§ . Существование задач распознавания, не принадлежащих P



функция натурального аргумента, принимающая натуральные значения, то существует такой язык в некотором алфавите, что сложность
любого алгоритма (в виде машины Тьюринга) распознавания принадлежности слова этому языку будет больше t(n) для всех достаточно
больших n.  В определенном смысле эта теорема является более общей, чем теорема Фишера—Рабина, но она очень абстрактна. Теорема
Фишера—Рабина примечательна тем, что в ней идет речь о некотором
содержательном в математическом смысле языке (предикате).
Модель МТ, однако, выглядит избыточно затратной в сравнении
с моделью РАМ в силу, например, того, что если некоторый символ хранится в ячейке a ленты и для определения хода дальнейших
вычислений надо сравнить этот символ с символом, расположенным
в ячейке b, которая находится далеко от ячейки a, то передвижение
головки машины Тьюринга из a в b потребует большого числа тактов работы и, следовательно, больших затрат, а в случае модели РАМ
сверх самой операции сравнения здесь нет затрат вообще.
Приведем соображение, которое можно оформить в виде теоремы  , показывающее, что если некоторые вычисления имеют полиномиальную сложность при использовании РАМ, то они будут иметь
полиномиальную сложность и при использовании МТ. Для простоты будем считать, что речь идет о преобразовании слов в алфавите
Λ = {0, 1} и соответственно о битовой сложности вычислений. Будем
также считать, что на каждое присваивание тратится некоторое учитываемое время, в том числе на присваивание вида a := b, при котором не выполняется никаких сравнений и изменений бит. Это дает
возможность предполагать, что для сложности T(n) по числу битовых
операций произвольного алгоритма и его пространственной сложности S(n), измеряемой числом используемых дополнительных ячеек,
в худшем случае выполняется соотношение S(n) ¶ C · T(n) при некоторой положительной константе C.
Пусть f : Λ∗ → Λ и fPAM — некоторый алгоритм вычисления f с помощью РАМ, имеющий битовую сложность TfPAM (n), которая полиномиально ограничена по длине n = | x | входа x (считаем, что в каждой ячейке РАМ размещается 0 или 1). Пусть TfPAM (n) < p(n), где
p — некоторый полином. Тогда количество ячеек, используемых fPAM
при работе со словом x, сверх тех, в которых изначально хранится x, не превосходит Cp(| x |) при некоторой положительной констан
См., например, [, разд. ], [, разд. .]. Впервые эта теорема была доказана,
вероятно, М. Блюмом.

См. [, разд. .].



Глава . Сводимость

те C. Если использовать МТ вместо РАМ, то возникающие дополнительные затраты на переходы от одной ячейки ленты к другой можно сделать меньшими, чем | x | + Cp(| x |) при каждой битовой операции. Таким образом, общее число тактов работы МТ не превзойдет
p(| x |)(| x | + Cp(| x |)), и сложность вычислений на МТ будет ограничена полиномом p(n)(n + Cp(n)).
§ . Полиномиальная сводимость. NP-полные задачи
Одна и та же математическая задача распознавания может быть формализована с использованием разных алфавитов и разных способов
кодирования. Тем не менее, если речь, например, идет о некоторой арифметической задаче, то можно ожидать, что основание q ∈ N,
q ¾ 2, выбранной позиционной системы счисления не будет влиять
на принадлежность соответствующего предиката классу P, так как
размеры ⌈logq1 (n + 1)⌉, ⌈logq2 (n + 1)⌉ записей числа n в двух разных
системах счисления являются величинами одного порядка, и сам переход от одной записи к другой может быть выполнен за время, ограниченное полиномом от размера входа.
Такого рода связь может существовать и между совершенно разными задачами распознавания, формализованными с помощью предикатов на словах.
Определение .. Пусть v и ṽ — предикаты на словах в алфавитах
e . Говорят, что v полиномиально сводится к ṽ, и пишут v ¶ p ṽ, если
Λ, Λ
e ∗ , что v(x) = ṽ( f (x)).
существует такая функция f ∈ P, f : Λ∗ −→ Λ
Из того, что для f ∈ P длина слова f (x) как функция от длины слова x полиномиально ограничена, а также из того, что композиция двух полиномов p3 (t) = p1 (p2 (t)) вновь является полиномом
(при этом если p1 (t), p2 (t) имеют неотрицательные коэффициенты,
то и p3 (t) тоже), мы получаем, что отношение ¶ p транзитивно и что
ṽ ∈ P =⇒ v ∈ P
при v ¶ p ṽ.
В -х годах прошлого столетия С. Кук доказал замечательную теорему о существовании в NP таких предикатов на словах, к каждому
из которых полиномиально сводится любой предикат из NP. Принятая терминология такова:
Определение .. Предикат u ∈ NP называется NP-полным, если
v ¶ p u для каждого v ∈ NP.

§ . Полиномиальная сводимость. NP-полные задачи



Перед формулировкой теоремы Кука напомним, что любую булеву
формулу от x1 , x2 , ..., xn можно задать в конъюнктивной нормальной
форме (КНФ):
D1 ∧ D2 ∧ ... ∧ Dm ,

Di = (li1 ∨ li2 ∨ ... ∨ li,ki ),

i = 1, 2, ..., m,

(.)

при этом lij является литералом, т. е. некоторой переменной x s или
переменной с отрицанием ¬ x s . Каждую формулу, заданную в КНФ,
можно изобразить словом из Λ∗1 , как обсуждалось в примере ..
Предикат, принимающий значение 1 на тех и только тех словах из
Λ∗1 , которые являются кодами КНФ выполнимых формул, назовем Sat
(от английского слова satisﬁability, одно из значений которого — выполнимость).
Теорему Кука мы приводим без доказательства  :
Теорема Кука. Предикат Sat является NP-полным.
Если показано, что некоторый предикат u является NP-полным,
и при этом для некоторого другого предиката v ∈ NP установлено,
что u ¶ p v, то из этого, очевидно, следует, что v тоже NP-полный.
Пример .. Прямым следствием теоремы Кука является то, что
рассмотренный в примере . предикат выполнимости произвольной, не обязательно заданной в КНФ, формулы является NP-полным.
Полиномиальная сводимость предиката Sat к этому предикату очевидна: в качестве функции f , фигурирующей в определении .,
можно взять функцию, которая преобразует слово x из Λ∗1 в скобку
«)» или еще в какой-нибудь символ, не являющийся кодом какой-либо булевой формулы, всякий раз, когда слово x не является кодом
какой-либо КНФ, и преобразует x в x в противном случае (можно
описать принадлежащий P алгоритм вычисления f (x)).
Когда говорят о принадлежащих классам P и NP задачах распознавания и о NP-полных задачах, а не о предикатах и языках, то при
этом предполагают, что способ кодирования входных данных ясен из

Мы опускаем доказательство этой теоремы, называемой в некоторых источниках
также теоремой Кука—Левина, из-за того, что оно требует привлечения специфической техники доказательств утверждений о машинах Тьюринга; такого рода доказательства выглядят естественно в определенном контексте, который отличается от контекста этого курса. Отчасти это послужило и причиной того, что в §  мы оставили без
доказательства теорему Фишера—Рабина. Доказательство теоремы Кука имеется, например, в [], [], []. Прозрачное изложение идей доказательства принадлежности
классу NP предиката, распознающего выполнимость произвольной булевой формулы,
и полиномиальной сводимости такого предиката к Sat можно найти в [].



Глава . Сводимость

контекста и определен, по крайней мере, с точностью до полиномиальной сводимости. Обсуждая в дальнейшем задачи из примеров
предыдущего параграфа, мы будем иметь в виду рассмотренные там
способы кодирования.
Пример .. Покажем сводимость задачи выполнимости КНФ
к задаче о клике с указанным числом вершин (пример .). Пусть
КНФ F имеет вид (.). Построим граф G F с k1 + k2 + ... + k m вершинами, для которых используем обозначения
lij ,

i = 1, 2, ..., m,

j = 1, 2, ..., k i ,

при этом вершины lij и lvw соединяем ребром, если и только если
выполнены два условия:
• i 6= v,
• конкретные литералы, скрывающиеся в (.) за обозначениями
lij и lvw , не являются отрицанием друг друга (скажем, если lij — это
¬ x1 , а lvw — это x1 , то эти две вершины ребром не соединяются).
Построение матрицы смежности графа G F может быть выполнено за
полиномиально ограниченное время.
Из определения клики и способа построения графа G F следует,
что клика из m вершин в этом графе существует, если и только если
формула (.) выполнима. В самом деле, при наличии такой клики
полагаем x s = 0, когда литерал ¬ x s соответствует одной из вершин
клики, а в остальных случаях x s = 1. В результате каждое Di в (.)
равно 1.
Наоборот, если заданная формула (.) выполнима, то при соответствующих значениях всех переменных x1 , x2 , ..., xn для каждого
i ¶ m можно выбрать j такое, что lij — это литерал со значением 1.
Сделав такой выбор, мы получаем набор вершин, образующий клику
с m вершинами.
Если исходная КНФ имеет вид
(¬ x1 ∨ ¬ x2 ) ∧ (x2 ) ∧ (x1 ∨ x2 ),
то мы получаем граф G F с пятью вершинами (рис. ), в котором
обнаруживается клика (l11 , l21 , l32 ) с тремя вершинами. Это соответствует тому, что исходная формула принимает значение 1 при x1 = 0,
x2 = 1.
Задача распознавания существования в графе клики с заданным
числом вершин является NP-полной.

§ . Полиномиальная сводимость. NP-полные задачи
l21

а)

l31

l11

l21

б)

l12

l32



l31

l12

l11

l32

Рис. . Построение графа G F для F = (¬ x1 ∨ ¬ x2 ) ∧ (x2 ) ∧ (x1 ∨ x2 ): а) выбор
вершин, б) проведение ребер.

Доказано также, что задача распознавания гамильтоновости графа
является NP-полной  . Упомянем еще одну очень известную NP-полную задачу, называемую задачей о рюкзаке. Задано конечное множество U, размер s(u) ∈ N+ и стоимость v(u) ∈ N+ каждого u ∈P
U, а также
a, b ∈ N+ . Существует ли такое подмножество U ′ ⊂ U, что
s(u) ¶ a,
P
u∈U ′
v(u) ¾ b?
u∈U ′

?

Из теоремы Кука следует, что для решения проблемы P = NP достаточно со всей тщательностью рассмотреть какой-нибудь один NP-полный предикат, например, тот же предикат Sat, и ответить на вопрос
о его принадлежности классу P. Если он принадлежит классу P, то
P = NP в силу NP-полноты рассматриваемого предиката, если не принадлежит, то P 6= NP, так как найден предикат, принадлежащий NP
и не принадлежащий P. Но этот заманчивый план до сих пор реализовать не удалось, усилия многих исследователей не привели к решению этой проблемы, хотя и устоялось мнение, что, скорее всего,
P 6= NP. Это предположение влечет за собой рекомендацию: если доказано, что решаемая практическая задача (при надлежащей формализации в виде предиката на словах в алфавите) является NP-полной, то
было бы опрометчивостью рассчитывать на нахождение в короткие
сроки полиномиального алгоритма ее решения, и лучше попробовать
решить эту задачу приближенно.
Многие задачи фактического построения некоторого математического объекта вписываются в следующую схему: дано x; если существует y такое, что x вместе с y удовлетворяют фиксированному условию R(x, y), то найти такое y. Соответствующая задача рас

Огромное число примеров NP-полных задач собрано в [].



Глава . Сводимость

познавания выглядит так: дано x; требуется определить, существует
ли y такое, что x вместе с y удовлетворяют фиксированному условию
R(x, y). Мы полагаем, что x и y — это коды некоторых математических объектов, т. е. слова в некотором алфавите Λ.
Пусть задача распознавания связана указанным образом с задачей
построения, пусть R(x, y) ∈ P и полином p таков, что если существует какое-то решение задачи построения, то существует и такое решение y, что | y | ¶ p(| x |). Тогда задача распознавания принадлежит NP
в соответствии с определением ., причем в качестве сертификата
для x выступает это решение y.
В примерах из §  по рассмотренным задачам распознавания легко восстанавливаются соответствующие им задачи построения (построить набор логических значений переменных; построить делитель
данного числа; построить клику в графе, имеющую определенное количество вершин, и т. д.). Для доказательства принадлежности классу NP задачи распознавания мы брали в качестве сертификата само
решение соответствующей вычислительной задачи.
Такой выбор сертификатов в ряде доказательств, видимо, и служит
причиной довольно распространенного представления, что класс P
образуют вычислительные задачи, решаемые за полиномиально ограниченное время, а класс NP — вычислительные задачи, для каждой из
которых за полиномиально ограниченное время можно проверить,
является ли данное слово y ее решением. На самом деле, конечно,
в классы P и NP входят только задачи распознавания, но упомянутое представление, будучи, строго говоря, неправильным, в известной мере согласуется с реальным положением вещей.
Быстрый алгоритм распознавания наличия какого-то математического объекта, кодируемого словом из Λ∗ , может в некоторых случаях позволить быстро решать и задачу фактического построения этого
объекта. Проиллюстрируем это примером.
Пример .. Мы знаем, что задача распознавания простоты натурального числа n принадлежит классу P, — алгоритм Агравала, Кайала и Саксены (пример .) имеет битовую сложность O(m11 ), где
m — битовая длина n. Вопрос о существовании полиномиального алгоритма факторизации (разложения на простые множители) остается
без ответа до сих пор при том, что алгоритмы факторизации имеют
огромную важность, например, для криптографии. Вернемся в связи
с этим вопросом к принадлежащей NP задаче, рассмотренной в примере .: для заданных n, k ∈ N+ , k < n, выяснить, имеется ли у числа n делитель l такой, что 1 < l ¶ k. Полиномиальный алгоритм реше-

Задачи



ния этой задачи тоже неизвестен, но можно показать, что открытие
такого алгоритма — назовем его A — автоматически дало бы полиномиальный алгоритм факторизации (кстати сказать, существование A
автоматически следовало бы из равенства P = NP, если бы оно вдруг
было доказано). Для этого можно воспользоваться бинарным поиском.
Пусть уже установлено, что n не имеет делителей, меньших n1 ,
где n1 < n, и пусть n2 таково, что n1 < n2 < n, и мы интересуемся наименьшим принадлежащим отрезку [n1 , nl2 ] простым
множителем чисm
n +n

2
, мы сузим диапазон
ла n. Тогда, применяя A к n, n3 , где n3 = 1
2
поиска примерно вдвое: в зависимости от результата применения A
мы перейдем от отрезка [n1 , n2 ] либо к отрезку [n1 , n3 ], либо к отрезку [n3 + 1, n2 ]. Первоначально же полагаем n1 = 2, n2 = n. Применив
алгоритм A не более m = ⌈log2 (n + 1)⌉ раз, мы найдем наименьший
простой множитель t числа n. Повторяем те же вычисления для

n′ =

n
t

(.)

и т. д. Общее число простых множителей числа n с учетом их кратности ограничено сверху величиной log2 n, и, значит, величиной m.
Битовые затраты каждого деления (.) не превосходят Cm2 , где
C — некоторая константа. Если битовая сложность алгоритма A есть
O(md ), то сложность описанного алгоритма факторизации будет допускать оценку O(md+2 ), т. е. этот алгоритм будет полиномиальным.
Задачи
. Задача умножения квадратных булевых матриц линейно
сводится к задаче построения транзитивно-рефлексивного замыкания (предполагается, что для сложностей рассматриваемых алгоритмов построения транзитивно-рефлексивного замыкания выполнено
T(3n) = O(T(n))).
Указание. Пусть M1 и M2 — две булевы матрицы порядка n. Пусть X — булева матрица порядка 3n:


0 M1
0


0
M2  .
0
0 0
0
Чему равны X 2 , X 3 ? Воспользоваться формулой (.) для транзитивно-рефлексивного замыкания.



Глава . Сводимость

. Здесь речь идет о линейной сводимости P ¶ Q задач, связанных с мультипликативными операциями над квадратными числовыми матрицами порядка n. Рассматриваются лишь такие алгоритмы
решения задачи Q, для сложности по числу арифметических операций каждого из которых выполняется соотношение T(kn) = O(T(n)),
k = 2, 3.
Требуется показать, что задача умножения произвольных квадратных матриц линейно сводится к задаче
а) умножения симметричных квадратных матриц;
б) умножения верхних треугольных матриц;
в) обращения невырожденных матриц.
Указание. Так же, как в предыдущей задаче, здесь можно прибегнуть
к матрицам размера, большего n, используя исходные матрицы как блоки
для построения новых матриц. В пункте в) полезно предварительно установить вид матрицы
− 1

In M 1
0


In M 2  ,
0
0
0
In
где M1 , M2 — исходные матрицы, In — единичная матрица порядка n.

. а) Доказать свойство (R) рациональных функций, сформулированное в § .
Указание. Достаточно доказать, что если полином p(x1 , x2 , ..., xn ) тождественно равен нулю на некотором непустом открытом множестве U ⊂ Rn , то
этот полином нулевой. При n = 1 утверждение очевидно. Пусть n > 1 и точка v = (v1 , v2 , ..., vn ) ∈ Rn такова, что p(v1 , v2 , ..., vn ) 6= 0. Пусть u ∈ U . Множество U — открытое, поэтому у точки u существует окрестность некоторого
радиуса r > 0, целиком принадлежащая U . Пусть l — расстояние от u до v ,
а c1 , c2 , ..., cn — координаты вектора единичной длины, направленного из u
в v . Если t пробегает множество R, то формулы
x1 = u1 + c1 t,

x2 = u2 + c2 t, ...,

x n = un + cn t

(.)

задают прямую в Rn , причем при t = 0 получается точка u, а при t = l — точка v . Остается рассмотреть для полинома p̄(t) одной переменной t , получающегося подстановкой (.) в p(x1 , x2 , ..., xn ), его значения в точке t = l и на
интервале −r < t < r .

б) Для каких целых n ¾ 1 справедливо утверждение, что если произвольный полином с вещественными коэффициентами от
x1 , x2 , ..., xn обращается в нуль на бесконечном подмножестве множества Rn , то этот полином является нулевым?
. Функция f (n) = ⌈log2 n!⌉ является нижней границей сложности по числу сравнений алгоритмов сортировки массивов длины n

Задачи



попарно различных рациональных чисел c помощью сравнений и четырех арифметических операций (в предложении . речь шла о сортировке вещественных чисел).
. Функция f (n) = ⌈log2 (n + 1)⌉ является нижней границей сложности по числу сравнений алгоритмов поиска места элемента в упорядоченном массиве длины n попарно различных вещественных чисел c помощью сравнений и четырех арифметических операций.
. Пусть известен алгоритм, который по данным c, m, c > 1,
1
(построить
m ∈ N+ , строит m значащих двоичных цифр числа
c
m значащих цифр некоторого числа x, 0 < x < 1, — это в данном
контексте означает отыскать первую ненулевую цифру после запятой в двоичной записи этого числа, а затем отбросить все цифры
после m цифр, отсчитанных от найденной), и пусть сложность этого
алгоритма есть O( f (m)), где f (m) — некоторая функция такая, что дополнительно известен алгоритм умножения произвольных a, b ∈ N+ ,
сложность которого тоже есть O( f (m)), где m = max{λ(a), λ(b)}. На
основе этих двух алгоритмов сконструировать алгоритм построения
частного и остатка от деления положительных целых a и b, имеющий
сложность O( f (m)), m = max{λ(a), λ(b)}.
Указание. Нужно построить q и r такие, что a = qb + r , 0 ¶ r < b, или
1
1
a = q + s, 0 ¶ s < 1. Возникновение погрешности при вычислении
может
b
b

привести к тому, что найденное q будет отличаться на 1 от точного значения; несколько добавочных проб помогут найти точные q и r , не изменяя
оценки O( f (m)) для сложности.

1

1

. Пусть c > 0 и y0 удовлетворяет неравенствам
¶ y0 ¶ ; пусть
2c
c
последовательность y0 , y1 , y2 , ... получена по рекуррентной формуле
yi = 2 yi−1 − ci yi2−1 ,

i = 1, 2, ...
1

Тогда последовательность y0 , y1 , ... сходится к .
c
. (Продолжение предыдущей задачи.) Пусть c ∈ N+ . Справедливо следующее утверждение  . Пусть y0 удовлетворяет неравенствам
1
1
¶ y0 ¶ и последовательность y0 , y1 , y2 , ... получена по рекуррент2c
c
ной формуле
yi = 2 ỹi−1 − ci ỹi2−1 ,


См. [, разд. .].

i = 1, 2, ...,

(.)



Глава . Сводимость

где
• целое ci таково, что λ(ci ) = λ(c), и если λ(c) > 2i , то первые 2i цифр
числа ci совпадают с соответствующими цифрами числа c, а последующие цифры суть нули, если же λ(c) ¶ 2i , то ci = c;
• ỹ0 получается из y0 отбрасыванием всех цифр после первой значащей цифры;
• после вычисления значения yi , i > 0, по рекуррентной формуле (.) в нем отбрасываются все цифры, идущие после первых 2i значащих цифр, — это дает значение ỹi .
Тогда первые 2i − 3 значащие цифры числа yi совпадают с соответ1
при i > 1. Считая этот факт установствующими цифрами числа
c
ленным и используя решение задачи , доказать, что задача деления одного целого числа на другое с остатком линейно сводится
к задаче умножения двух целых чисел. (Размером входа считается
m = max{λ(a), λ(b)}, где a и b — исходные числа, при этом считаем,
что m есть число вида 2k ; всюду подразумеваются битовые затраты;
если это нужно, можно считать, что сложность f (m) умножения удовлетворяет условиям f (m) ¶ f (2m) ¶ 4 f (m)).
Указание. Соответствующий алгоритм построения частного и остатка уже
описан в этой задаче и задаче . Достаточно доказать, что алгоритм приближенного обращения c, описанный в этой задаче, имеет сложность R(2k )
такую, что R(2k ) ¶ γ f (2k ) для некоторой константы γ. Подобрать γ так, чтобы
доказательство проводилось индукцией, и индуктивный переход был основан
на неравенстве
R(2k ) ¶ R(2k−1 ) + 2 f (2k−1 ) + δ2k−1 ,
где константа δ определяется, в частности, тем, какой алгоритм сложения
чисел используется.

. Верно ли, что для доказательства того, что P = NP, достаточно
показать, что хотя бы одна задача из NP принадлежит P?
. Существуют ли в NP задачи, не являющиеся NP-полными?
. Если бы оказалось, что полиномиального алгоритма распознавания простоты натурального числа не существует (забудем об
алгоритме Агравала, Кайала и Саксены), то из этого бы следовало,
что P 6= NP.
. Дизъюнктивная нормальная форма (ДНФ) определяется как
C1 ∨ C2 ∨ ... ∨ Cm ,

Ci = (li1 ∧ li2 ∧ ... ∧ liki ),

i = 1, 2, ..., m,

при этом каждое lij является литералом. Задача выполнимости ДНФ
принадлежит P.

Задачи



. Найти ошибку или пробел в следующем доказательстве того,
что Sat ∈ P. Очевидно, что любую КНФ можно преобразовать в эквивалентную ДНФ (см. задачу ), поэтому задача выполнимости КНФ
сводится к задаче выполнимости ДНФ, а эта задача принадлежит P.
. Для выполнимой булевой формулы назовем соответствующий
набор значений переменных выполняющим. Если P = NP, то существует полиномиальный алгоритм, который строит выполняющий набор
для данной булевой формулы, если эта формула выполнима, и пустое
слово, если формула невыполнима.

Приложение A

Основные алгоритмы сортировки и поиска

A. Сортировка
Для простоты считаем, что требуется упорядочить по возрастанию
числовой массив x1 , x2 , ..., xn с попарно различными элементами. Размер входа — число n. Мы называем сегментом массива x1 , x2 , ..., xn
любую его часть xi , xi+1 , ..., xk−1 , xk , 1 ¶ i ¶ k ¶ n, которая по условию
или по построению является упорядоченной.
. Пузырьковая сортировка. Последовательным просмотром всех
x1 , x2 , ..., xn определяется xi такое, что xi > xi+1 ; затем xi и xi+1 меняются местами, просмотр продолжается с элемента xi+1 и т. д. Тем
самым в результате первого просмотра всего массива наибольший
элемент передвинется на последнее место. Следующие просмотры начинаются опять сначала, после уменьшения на единицу количества
просматриваемых элементов. Массив будет упорядочен после просмотра, который охватывал только первый и второй элементы, или
же раньше, если при некотором просмотре не обнаружено xi такого,
что xi > xi+1 .
. Сортировка выбором. Выполняется n − 1 шаг. На i-м шаге (i =
= 1, 2, ..., n − 1) среди элементов xi , xi+1, ..., xn отыскивается наименьший и переставляется с xi .
. Сортировка простыми вставками (два варианта). Пусть после нескольких шагов сортировки элементы x1 , x2 , ..., xi уже упорядочены (образуют сегмент): x1 < x2 < ... < xi . Тогда на следующем шаге
элемент xi вставляется в этот сегмент таким образом, что элементы
x1 , x2 , ..., xi+1 оказываются упорядоченными (сегмент расширяется).
В конечном счете получаем сегмент x1 , x2 , ..., xn . В первом варианте
сортировки место вставки определяется последовательными сравнениями xi+1 с xi , xi−1 , ..., во втором — последовательными сравнениями xi+1 с x1 , x2 , ...

Основные алгоритмы сортировки и поиска



. Сортировка бинарными вставками. Отличается от сортировки простыми вставками тем, что место xi в сегменте x1 , x2 , ..., xi−1
определяется алгоритмом бинарного поиска (см. A, п. ).
. Сортировка слияниями. Разнообразные виды этой сортировки
используют слияние сегментов. Сначала мы рассмотрим процедуру
слияния, а затем опишем два варианта сортировки, основанной на
этой процедуре.
Сëèÿíèå. Пусть для элементов массива e1 , e2 , ..., em выполнено
e1 < e2 < ... < ek и ek+1 < ek+2 < ... < em , k ¶ m. Массив f1 , f2 , ..., fm , который является результатом слияния массивов e1 , e2 , ..., ek и ek+1 , ek+2 , ...
..., em , можно получить за m шагов. После i-го шага элементы
f1 , f2 , ..., fi уже имеют нужные значения, целые p и q (p + q = i) показывают, сколько элементов из числа e1 , e2 , ..., ek и ek+1 , ek+2 , ..., em
уже использовано.
Рåêóðñèâíûé âàðèàíò ñîðòèðîâêè ñëèÿíèÿìè. При n = 1 массив упорядочен. Пусть n > 1, тогда массив x1 , x2 , ..., xn разбивается на два примерно равных по длине подмассива x1 , x2 , ..., x⌊n/2⌋
и x⌊n/2⌋+1 , x⌊n/2⌋+2 , ..., xn . Сортировка применяется рекурсивно к этим
подмассивам, после чего выполняется слияние.
Сîðòèðîâêà ôîí Нåéìàíà. Первоначально элементы массива
x1 , x2 , ..., xn рассматриваются как упорядоченные одноэлементные сегменты. Затем в массиве y1 , y2 , ..., yn образуются упорядоченные сегменты длины 2, получающиеся слиянием x1 и x2 , x3 и x4 , x5 и x6 , ...
Последний сегмент будет иметь один или два элемента в зависимости от четности n. Полученные сегменты сливаются в упорядоченные
сегменты длины 4 (кроме последнего, который тоже упорядочен, но,
возможно, имеет длину 1, 2 или 3), они последовательно попадают
в массив x1 , x2 , ..., xn . Процесс укрупнения сегментов продолжается
дальше. В некий момент массив x1 , x2 , ..., xn или y1 , y2 , ..., yn содержит
только один упорядоченный сегмент.
. Быстрая сортировка. Эта сортировка основывается на процедуре разбиения массива. Перед описанием сортировки мы рассмотрим эту процедуру.
Рàçáèåíèå. Берется первый элемент массива и сравнивается со
всеми остальными. Меньшие его элементы помещаются в начальную
часть массива, бо́льшие — в конечную. Сам первоначально взятый
элемент помещается между этими двумя частями, это — то место, которое ему надлежит занимать в упорядоченном массиве. Дополнительный массив для этой процедуры не требуется, достаточно двух
переменных p и q, показывающих, сколько элементов в начальной



Приложение A

и конечной частях уже занято. Элемент, взятый первым, расположен
на (p + 1)-м месте и сравнивается со следующим за ним. Равенство
p + q = n − 1 означает, что разбиение завершено.
Сîðòèðîâêà. Выполняется разбиение; в результате элемент, ранее
располагавшийся в массиве первым, занимает нужное место (с некоторым номером k, 1 ¶ k ¶ n). Затем быстрая сортировка применяется
рекурсивно к сегментам x1 , x2 , ..., xk−1 и xk+1 , xk+2 ..., xn .
A. Поиск
Числовой массив x1 , x2 , ..., xn имеет попарно различные элементы.
В п.  элементы предполагаются упорядоченными по возрастанию.
. Поиск наименьшего. Просматриваются последовательно x2 ,
x3 , ..., xn и каждый новый элемент xi сравнивается с уже найденным
наименьшим среди x1 , x2 , ..., xi−1 .
. Поиск m-го наименьшего. Элементы x1 , x2 , ..., xn переставляются в соответствии с процедурой разбиения (см. алгоритм быстрой сортировки). Пусть элемент, бывший в исходном массиве первым, после выполнения процедуры стал k-м, 1 ¶ k ¶ n. Если m = k, то
задача решена. Если m < k, то разыскивается m-e наименьшее среди x1 , x2 , ..., xk−1 ; если m > k, то разыскивается (m − k)-е наименьшее
среди xk+1 , xk+2, ..., xn .
. Одновременный поиск наименьшего и наибольшего. Элементы x1 , x2 , ..., xn просматриваются последовательными парами:
x1 , x2 , затем x3 , x4 и т. д. (последний элемент может остаться без
пары). При рассмотрении k-й пары x2k−1 , x2k в ней выбираются наименьший и наибольший элементы, которые сравниваются с уже
найденными наименьшим и, соответственно, наибольшим среди
x1 , x2 , ..., x2k−2 . Если n нечетно, то на последнем шаге xn сравнивается с уже найденными наименьшим и наибольшим среди x1 , x2 , ...
..., xn−1 .
. Бинарный поиск места элемента. Кроме упорядоченного массива x1 < x2 < ... < xn дано число y, для которого априори может осуществляться любая из возможностей
y ¶ x1 ,

x1 < y ¶ x2 , ...,

x n −1 < y ¶ x n ,

xn < y.

Этим возможностям присваиваются номера 1, 2, ..., n + 1. Требуется найти номер фактически осуществившейся возможности. Первоначальный диапазон поиска — от 1 до n + 1. Каждый шаг би-

Основные алгоритмы сортировки и поиска



нарного поиска сужает диапазон примерно вдвое: если перед очередным шагом диапазон был от p до q, то y сравнивается с xr ,
r = ⌊(p + q)/2⌋. При xr < y диапазон дальнейшего поиска — от r + 1
до q (в дальнейшем рассматривается сегмент xr +1 , xr +2 , ..., xq−1), в
противном случае — от p до r (в дальнейшем рассматривается сегмент x p , x p+1 , ..., xr ). И так далее до совпадения границ диапазона.

Приложение B

Оценивание сумм значений монотонных
функций

Предложение B.. Пусть f — неубывающая или невозрастающая
непрерывная на отрезке [n0 , n1 ] функция, n0 , n1 ∈ Z. Тогда
Z n1
Z n1
n1
X
f (k) ¶

f (x) dx + f (n0 ) ¶

n0

f (x) dx + f (n1 )

в случае неубывающей f и
Z n1
f (x) dx + f (n1 ) ¶
n0

n1
X

(B.)

n0

k = n0

Z

n1

f (k) ¶

f (x) dx + f (n0 )

(B.)

n0

k = n0

в случае невозрастающей f .
Доказательство. Пусть f — неубывающая функция. Рис.  поnP
nP
1 −1
1 −1
R n1
казывает, что
f (k) ¶ n f (x) dx (значение
f (k) равно сумме
0

k = n0

...

Рис. .

nP
1 −1
k = n0

f (k) ¶

n1 − 1
n1

...

n0
n0 + 1
n0 + 2

k = n0

R n1
n0

f (x) dx .

Оценивание сумм значений монотонных функций



площадей выделенных прямоугольников с вертикальными сторонами f (n0 ), f (n0 + 1), ..., f (n1 − 1)). Соответственно, рис.  показывает,

...

n1
P

Рис. .

f (k) ¾

k = n0 + 1

что

n1
P

f (k) ¾

R n1

k = n 0 +1

n0

n1 − 1
n1

n0
n0 + 1
n0 + 2

...

R n1
n0

f (x) dx .
n1
P

f (x) dx (значение

f (k) равно сумме пло-

k = n 0 +1

щадей выделенных прямоугольников с вертикальными сторонами
f (n0 + 1), f (n0 + 2), ... f (n1 )). Это дает нам (B.). Неравенства (B.)
доказываются аналогично.
p
Рассмотрим некоторые примеры. Функция x не убывает на правой полуоси. Имеем
Zn
Zn
n p
X
p
p
p
x dx + 1 ¶
k¶
x dx + n,
1

1

k =1

т. е.
2 p 3 1
( n) + ¶
3
3

n p
X
k =1

k¶

2 p 3 p
2
( n) + n − ,
3
3

и, как следствие,
n p
X
k =1

p
2 p
k = ( n)3 + O( n).
3

Аналогично выводится, что при любом вещественном α ¾ 0 и n → ∞
n
P
nα+1
. (Справедлива ли эта формула при всех
выполняется
kα ∼
k =0

α 6= −1?)

α+1


Функция

Приложение B
1
не возрастает при x ¾ 1. Имеем
x

Z

n
1

1
dx
+ ¶
x
n

это дает нам
ln n ¶

n
X
k =1

n
X
k =1

и, как следствие,

n
X
k =1

1
¶
k

Z

n
1

dx
+ 1,
x

1
¶ ln n + 1,
k

1
= ln n + O(1).
k

Приложение C

Проблема орбит

C. Показательная функция и логарифмическая оценка
В этом разделе приложения рассказывается об одной вычислительной задаче и об эффективном решении ее некоторого частного случая; почти все факты приводятся без доказательств. В разделе C мы
рассмотрим оставшийся случай с бо́льшими подробностями.
Речь идет об одном из вариантов известной «проблемы орбит».
Даны две квадратные матрицы A и B одинакового порядка с элементами из поля Q. Существуют ли натуральные m такие, что Am = B?
Если да, то надо указать все такие m. Рассмотрение собственных значений матриц A и B приводит к вопросу о распознавании существования и поиске натуральных m таких, что
am = b

(C.)

для данных алгебраических чисел a и b.
Напомним, что число a ∈ C называется алгебраическим, если существует полином над полем Q, для которого a является корнем.
В качестве такого полинома удобно рассматривать унитарный  полином, т. е. полином с единичным старшим коэффициентом. Можно
показать, что для всякого алгебраического числа существует единственный унитарный неприводимый над Q полином, для которого
a является корнем. Алгебраическое число a ∈ C называется целым алгебраическим, если соответствующий неприводимый унитарный по
лином является полиномом над Z, т. е. имеет целые
p коэффициенты .
Нетрудно, например, убедиться,
что число (1 + 5)/2 — целое алгебp
раическое, а число (3 + 4 −1)/5 — нецелое алгебраическое.


Используются также термины приведенный, нормированный.
Для избежания терминологической путаницы между целыми алгебраическими числами и обычными целыми, т. е. элементами Z, последние в теории алгебраических
чисел часто называют целыми рациональными числами.




Приложение C

Если | a | 6= 1, то с исследованием и решением уравнения (C.) серьезных трудностей не возникает, так как модуль значения показательной функции am монотонно возрастает или монотонно убывает,
и можно получить логарифмическое ограничение на m. Задача становится интересной при | a | = 1 и при дополнительном условии, что
a не является корнем из 1. (Если a есть корень из единицы, то задача
тривиальна.)
Как это следует из элементарной теории алгебраических чисел,
вопрос можно переформулировать так: дан неприводимый над Q полином f (x), deg f (x) = n, и некоторый полином q(x) над Q степени
deg q(x) < n; существуют ли такие натуральные m, что
am = q(a)

(C.)

при любых a ∈ C, для которых f (a) = 0, и если да, то как найти такие m? Мы сосредоточимся на последнем вопросе, опуская мелкие
подробности перехода к нему от проблемы орбит.
Особенность постановки вопроса об уравнении (C.) состоит в
том, что речь идет не об одном фиксированном корне полинома f (x),
но обо всех его корнях. Легко показать, что если равенство (C.) верно для одного какого-то корня a0 полинома f (x), то оно верно для
всех корней этого полинома. В самом деле, если для некоторого фиксированного m полиномы x m − q(x) и f (x) имеют общий корень a0 ,
то эти полиномы имеют нетривиальный общий делитель. Наибольший общий делитель этих полиномов может быть найден алгоритмом
Евклида и, следовательно, должен иметь рациональные коэффициенты. Из этого и из неприводимости f (x) над Q следует, что наибольший общий делитель равен f (x). Отсюда получаем, что x m − q(x) делится на f (x). Это означает, что каждый корень f (x) является также
корнем x m − q(x).
Таким образом, задача о всей совокупности корней эквивалентна задаче об одном фиксированном корне, и задача об одном фиксированном корне эквивалентна задаче о любом другом корне. Это
обстоятельство позволяет справиться со случаем целого алгебраического a. К решению подводит серия результатов о корнях унитарных
полиномов над Z, начавшаяся с работ Кронекера и завершившаяся
в  —-е годы XX века исследованиями А. Шинцеля, Г. Цассенхауза,
П. Бланксби и Х. Монтгомери  . Выяснено, что если унитарный полином над Z степени n таков, что его корни не являются корнями из


Cм. [], []. Результаты Кронекера, Шинцеля и Цассенхауза изложены в [,
разд. .].

Проблема орбит



единицы, то у него найдется по меньшей мере один корень a, для
которого | a | > 1. Бланксби и Монтгомери показали, что по меньшей
мере для одного корня выполняется неравенство
|a| ¾ 1 +

1
.
30n2 ln(6n)

(C.)

Из этого позднее было выведено, что если корни неприводимого унитарного полинома f (x) степени n c целочисленными коэффициентами не являются корнями из единицы, то для любого натурального
решения m уравнения (C.) выполнено неравенство
m ¶ n + 60n2 ln(6n)(ln(n + 1) + ln| q(x) |),

(C.)

где | q(x) | обозначает длину вектора коэффициентов полинома q(x):
если q(x) = ck x k + ... + c1 x + c0 , то
Æ
| q(x) | = c2k + ... + c21 + c20 .
Решения уравнения (C.) для различных корней a полинома f (x)
совпадают. Доказанное может быть сформулировано следующим образом.
Предложение C.. Пусть f (x) — неприводимый над Q полином
степени n, корни которого не являются корнями из единицы. Пусть
q(x) — некоторый полином над Q , степень которого меньше n. Тогда для любого корня a полинома f (x) существует не более одного
натурального решения уравнения (C.), при этом решения m уравнения (C.) для различных корней a полинома f (x) совпадают, и имеет
место оценка (C.).
Несложно показать, что верны следующие утверждения:
. Пусть h(x) ∈ Q и r(x) — остаток от деления h(x) на f (x). Пусть
a ∈ C, f (a) = 0. Тогда h(a) = r(a).
. Пусть q1 (x), q2 (x), q3 (x), ... суть остатки от деления x, x 2 , x 3 , ...
на f (x). Тогда
• при k > 1 полином qk (x) равен остатку от деления xqk−1 (x) на
f (x);
• равенство (C.) имеет место, если и только если q(x) = qm (x).
Из этих утверждений следует, что после того, как установлена граница M для возможного значения m, распознавание существования
и поиск натурального решения уравнения (C.) можно выполнить,
затратив O(nM) арифметических операций над рациональными числами.



Приложение C

C. Неудачно выбранный размер входа
Обратимся к уравнению (C.), предполагая, что среди коэффициентов
унитарного неприводимого над Q полинома f (x) имеется по крайней
мере один нецелый рациональный; без специальных оговорок считаем, что корни f (x) не являются корнями из единицы. Возникает
вопрос: можно ли и для этого случая получить подобную (C.) верхнюю оценку величины m? На протяжении ряда лет считалось, что
ответ положительный  и что существует полином трех переменных
P(x1 , x2 , x3 ) такой, что даже при наличии среди коэффициентов f (x)
нецелых рациональных чисел имеет место оценка
m < P(n, log2 | f |, log2 | q |),

(C.)

но затем выяснилось, что это неверно  . Проблема заслуживает детального рассмотрения, поскольку ряд ее моментов является принципиальным. Вывод о существовании полинома P(x1 , x2 , x3 ) был сделан на основании утверждения о том, что если среди коэффициентов
f (x) есть нецелые числа, то имеет место неравенство
m ¶ (n − 1) log2 | f |.

(C.)

Неравенство (C.) опровергается несложно (сразу заметно, что правая часть этого неравенства не зависит от вида полинома q(x), что
подозрительно). Мы, тем не менее, сосредоточим усилия на другом — покажем, что верхняя оценка (C.) не может иметь места не
только при полиномиальной, но и, например, при показательной
x
x 3

x1 2

функции того или иного вида (скажем, вида 2 ) и вообще при
любой непрерывной функции P(x1 , x2 , x3 ). Это, в частности, лишает
возможности характеризовать вычислительную сложность алгоритма
как полиномиальную, экспоненциальную и т. д.
Указанное обстоятельство в значительной мере является следствием плохо выбранных параметров n, | f (x) | и | q(x) | размера входа.
Если мы зафиксируем n и f (x), а затем будем слегка изменять значения коэффициентов полинома q(x) (тем самым два параметра размера остаются фиксированными, а третий изменяется очень мало),
то при этом могут возникать уравнения вида (C.), имеющие натуральные решения m, и эти m для разных уравнений могут, как будет показано, отличаться друг от друга сколь угодно сильно. Мы укажем натуральное n, неприводимый полином f (x) ∈ Q[x] степени n,



См. []; в этой же работе получена оценка (C.) как следствие оценки (C.).
См. [].

Проблема орбит



последовательность q1 (x), q2 (x), ... ∈ Q[x] полиномов степени меньшей, чем n, и вещественные A, B, A < B, такие, что A < | qk (x) | < B,
k = 1, 2, ..., и при этом каждое из уравнений
am = qk (a),

f (a) = 0,

(C.)

имеет решение m = k. Возьмем
a=

p
3 + 4 −1
,
5

(C.)
q

6

p
86

36

тогда f (x) = x 2 − x + 1, n = 2 и | f (x) | = 1 +
+1=
. Пусть
5
25
5
b1 , b2 , ... и c1 , c2 , ... — последовательности рациональных чисел таких,
что ak = bk a + ck , и пусть qk (x) = bk x + ck ∈ Q[x] (таким образом, q(x)
6
равен остатку от деления x k на f (x) = x 2 − x + 1). Очевидно, что
5
b1 = 1, c1 = 0.
Используя утверждения , , сформулированные в конце предыдущего раздела этого приложения, индукцией по k легко доказывается,
что
6
bk+1 = bk + ck , ck+1 = −bk
5

для k > 0. Последняя система двух рекуррентных уравнений решается легко, так как второе уравнение позволяет заменить в первом ck
на −bk−1 и получить для bk линейное рекуррентное уравнение второго порядка с постоянными коэффициентами. В итоге имеем (см. приложение G)
p
p

 

p 
5
5
3 + 4 −1 k
3 − 4 −1 k
bk =
= sin(k θ )
−
−1
8

5

5

4

и
ck = −

5
8

p

p
p


 

3 − 4 −1 k −1
5
3 + 4 −1 k −1
−1
= − sin((k − 1)θ ),
−

5

5

4

p

где θ ∈ R выбрано так, чтобы выполнялось a = eθ −1 . Получаем
p
Æ
5p
5
sin2 k θ + sin2 (k − 1)θ ≤
2.
| qk | = bk2 + c2k =
4

4

p
Для функции h(x) = sin2 x + sin2 (x − θ ) положим µ = min (h(x)) ≥ 0.
0≤ x <2π

4
Так как sin(θ ) = , то θ не является целым кратным π, поэтому µ > 0.
5

Таким образом,

5
4

5
4

| qk | = h(k θ ) ≥ µ > 0.



Приложение C
5

5p

Положим A = µ, B =
2. Для любой функции F(x1 , x2 , x3 ), непре4
4
рывной на множестве
p
n
o
86
V = (x1 , x2 , x3 ): x1 = 2, x2 =
, A < x3 < B ,
5

мы можем выбрать целое k, большее максимума функции F(x1 , x2 , x3 )
на V, и это приведет к уравнению (C.) с решением m, большим
F(n, | f (x) |, | q(x) |).
Таким образом, нами доказана следующая теорема.
Теорема C.. Пусть алгоритм распознавания существования и поиска решения m уравнения (C.) состоит в получении верхней границы M для m и в последующей проверке всех значений m = 1, 2, ..., M.
Тогда сложность этого алгоритма по числу таких проверок не допускает оценки сверху вида F(n, | f (x) |, | q(x) |), где F — какая-либо непрерывная функция трех переменных.
Отсутствие непрерывной функции, ограничивающей затраты, является, как уже упоминалось, следствием неудачно выбранных параметров размера входа. Можно показать  , что если среди коэффициентов унитарного неприводимого полинома f (x) имеется хотя бы
один, не являющийся целым рациональным, и если C, D ∈ Z таковы,
что Ca является целым алгебраическим для любого корня a полинома
f (x) и Dq(x) ∈ Z[x], то для решения m уравнения (C.) выполнено
m ¶ (n − 1) log2 C + log2 D.

(C.)

Границы (C.) и (C.) приводят к алгоритму решения проблемы
орбит.
В качестве C может быть взято наименьшее общее кратное знаменателей коэффициентов полинома f (x), в качестве D — наименьшее
общее кратное знаменателей коэффициентов полинома q(x).
Неверно, что C всегда можно взять меньшим  , чем | f (x) |. В этом
6
5

можно убедиться, вернувшись к f (x) = x 2 − x + 1.




См. уже упоминавшуюся работу [].
В [] авторы исходили из предположения, что всегда можно взять C < | f (x) |.

Приложение D

Оптимальность схемы Горнера

Теорема D.. Пусть n — произвольное неотрицательное целое число. Не существует алгоритма, который, используя только сложение,
вычитание и умножение, позволяет вычислять значение
an x n + ... + a1 x + a0

(D.)

по числам x, a0 , a1 , ..., an так, что количество сложений или умножений всегда оказывается меньше n.
В терминах нижних границ это утверждение можно, очевидно,
переформулировать следующим образом.
Пусть P — класс алгоритмов, вычисляющих значение (D.) с помощью операций сложения, вычитания и умножения. Будем рассматривать число n как размер входа x, a0 , a1 , ..., an . Тогда n является нижней границей как аддитивной сложности (измеряемой числом сложений и вычитаний в худшем случае), так и мультипликативной сложности (измеряемой числом умножений в худшем случае) алгоритмов
класса P .
Несколько предварительных соглашений и замечаний. Во-первых,
будем для определенности считать, что все коэффициенты полинома, а также значение x принадлежат полю рациональных чисел Q,
хотя достаточно было бы потребовать, например, чтобы они принадлежали произвольному бесконечному полю. Во-вторых, ограничимся
операциями сложения и умножения; позднее мы покажем, что привлечение вычитаний не является существенным. В-третьих, заметим,
что любой алгоритм, который использует только операции сложения
и умножения и который вычисляет значение произвольного полинома фиксированной степени n по заданному x, можно записать в виде
линейной (неветвящейся) программы, одной и той же для всех полиномов степени n (так как в используемом наборе операций нет
операций сравнения). В качестве программных переменных мы будем использовать p с тем или иным целым индексом. Шагом про-



Приложение D

граммы является некоторое присваивание. Подготовительный раздел
программы содержит присваивания
p−n−1 := an ;

...;

p−1 := a0 ;

p0 := x

(D.)

и, возможно, ряд присваиваний вида pk := ..., k < −n − 1, с конкретными числами в правой части (т. е. можно запасти константы, нужные в вычислениях). Вычислительный раздел программы состоит из
присваиваний вида
pi := pk , k < i,
(D.)
и
pi := pk ⋄ pl ,

k, l < i, ⋄ ∈ {+, ·}.

(D.)

Значение индекса в левой части будем считать номером шага, предполагая, что все используемые в программе значения индекса заполняют целиком некоторый отрезок множества целых чисел. Шаг
вида (D.) будем называть аддитивным или мультипликативным
в зависимости от вида ⋄ (+ или ·). Шаг вида (D.) будем называть
нейтральным. Каждую программу такого вида, вычисляющую значение (D.) и обладающую тем свойством, что, не меняя ее вычислительного раздела, а лишь варьируя правые части в (D.), мы можем
получать значения любых полиномов степени n в любых точках, мы
назовем n-программой.
Наша цель состоит в доказательстве того, что каким бы ни было неотрицательное целое n, любая n-программа содержит не менее n аддитивных и не менее n мультипликативных шагов.
Если в n-программе изменить шаги с номерами 0, −1, ..., −n − 1,
подставляя в правые части присваиваний (D.) вместо чисел x, a0 ,
a1 , ..., an их буквенные обозначения, и интерпретировать +, · в вычислительном разделе как знаки полиномиальных операций, то в результате выполнения n-программы значениями p1 , p2 , ... будут полиномы (т. е. буквенные выражения, «картинки»). В частности, будет
построен полином an x n + ... + a1 x + a0 , причем an , ..., a1 , a0 и x являются переменными этого полинома (степень по x которого равна n, а степень, например, по an равна 1). При таком подходе каждая
n-программа вычисления значения полинома превращается в программу построения полинома
P(x, a0 , a1 , ..., an ) = an x n + ... + a1 x + a0 ∈ Q[x, a0 , a1 , ..., an ]

(D.)

с помощью операций сложения и умножения, исходя из переменных
x, a0 , a1 , ..., an . Программу обсуждаемого вида, содержащую в под-

Оптимальность схемы Горнера



готовительном разделе формализованные указанным способом шаги с номерами −n − 1, −n, ..., 0, назовем формальной n-программой.
Если мы докажем, что любая формальная n-программа содержит не
менее n аддитивных и не менее n мультипликативных шагов, то поставленная цель будет достигнута.
Лемма D.. Пусть n ¾ 0, S — формальная n-программа, t — положительное целое, не превосходящее наибольшего значения индекса переменной p в S. Пусть среди шагов S с номерами 1, 2, ..., t нет аддитивных, в которых по крайней мере один операнд правой части
зависит от an (имеет положительную степень по an как полином
от x, a0 , a1 , ..., an ). Тогда после выполнения S каждый из полиномов
p1 , p2 , ..., pt либо не зависит от an , либо кратен an (может быть
записан в виде an Q , где Q ∈ Q[x, a0 , a1 , ..., an ]).
Доказательство. Индукция по t.
Для t = 1 утверждение очевидно.
Пусть t > 1 и утверждение леммы верно для 1, 2, ..., t − 1. Для шага
с номером t имеется три возможности:
pt := pk ,

pt := pk + pl ,

pt := pk · pl ,

k, l ¶ t − 1. При осуществлении первой возможности требуемое непосредственно следует из предположения индукции. При второй возможности из сказанного в условии леммы относительно аддитивных
шагов следует, что pt не зависит от an . При третьей возможности
любой из полиномов pk , pl может быть либо кратным an , либо не
зависеть от an ; в обоих случаях получаем то, что нам нужно.
Лемма D.. Каждая формальная n-программа S, n ¾ 0, построения
полинома P вида (D.) содержит не менее n аддитивных шагов.
Доказательство. Индукция по n.
Для n = 0 утверждение очевидно.
Пусть n > 0 и утверждение леммы верно для 0, 1, ..., n − 1. Предположим, что S содержит менее n аддитивных шагов. Ясно, что в S имеется по крайней мере один аддитивный шаг такой, что по крайней
мере один из его операндов зависит от an . В силу леммы D. первый
такой шаг будет иметь по крайней мере один операнд, являющийся
кратным an полиномом. Пусть этот шаг имеет вид pi := pk + pl , и значением pk (именно этот операнд мы берем только для определенности) является полином an Q, Q ∈ Q[x, a0 , a1 , ..., an ]. Если в S заменить
шаг p−n−1 := an на p−n−1 := 0, а шаг pi := pk + pl — на pi := pl , то, очевидно, получится формальная (n − 1)-программа построения полино-



Приложение D

ма an−1 x n−1 + ... + a1 x + a0 , содержащая менее чем n − 1 аддитивных
шагов. Противоречие.
Исследуя число мультипликативных шагов, мы докажем утверждение более сильное, чем то, которое непосредственно нас интересует.
Во-первых, мы будем рассматривать формальные n-программы,
которые строят полином, возможно лишь «по модулю x n+1 » равный P(x, a0 , a1 , ..., an ), т. е. некоторый полином вида Ux n+1 + an x n + ...
... + a1 x + a0 , где U ∈ Q[x, a0 , a1 , ..., an ], и при этом конкретный вид U
может быть любым, и он нас не будет интересовать. Мы согласны, таким образом, получить любой полином W (x, a0 , a1 , ..., an ) такой, что
разность W(x, a0 , a1 , ..., an ) − P(x, a0 , a1 , ..., an ) делится на x n+1 :
W (x, a0 , a1 , ..., an ) ≡ P(x, a0 , a1 , ..., an ) (mod x n+1 )

(D.)

(этим мы фактически расширяем понятие формальной n-программы). Во-вторых, мы будем исследовать число существенно мультипликативных шагов, т. е. таких шагов вида pi := pk · pl , для которых
k, l ¾ −n − 1; последнее означает, что операнды таких шагов не являются заранее запасенными константами. Ясно, что если для построения любого полинома W (x, a0 , a1 , ..., an ), удовлетворяющего (D.),
не существует формальной n-программы, содержащей менее n существенно мультипликативных шагов, то, в частности, не существует
и формальной n-программы для построения P(x, a0 , a1 , ..., an ), содержащей менее n мультипликативных шагов.
Лемма D.. Пусть n ¾ 0, S — формальная n-программа, t — положительное целое, не превосходящее наибольшего значения индекса переменной p в S. Пусть среди шагов S с номерами 1, 2, ..., t нет существенно мультипликативных, в которых по крайней мере один операнд правой части зависит от an . Тогда после выполнения S каждый
из полиномов p1 , p2 , ..., pt либо не зависит от an , либо имеет вид
can + Q , где c ∈ Q \ {0} и полином Q не зависит от an .
Доказательство аналогично доказательству леммы D..
Лемма D.. Каждая формальная n-программа S построения какого-либо W , удовлетворяющего (D.) при P = an x n + ... + a1 x + a0 , содержит не менее n существенно мультипликативных шагов.
Доказательство. Индукция по n.
Для n = 0 утверждение очевидно.
Пусть n > 0 и утверждение леммы верно для 0, 1, ..., n − 1. Пусть
S — формальная n-программа построения некоторого полинома

Оптимальность схемы Горнера



W (x, a0 , a1 , ...an ), удовлетворяющего (D.). Предположим, что в S
меньше чем n существенно мультипликативных шагов. Покажем,
что в таком случае можно построить формальную (n − 1)-программу,
в которой меньше чем n − 1 существенно мультипликативных шагов,
и тем самым получить противоречие с предположением индукции.
В силу леммы D. формальная n-программа S содержит по крайней мере один существенно мультипликативный шаг, по крайней мере
один из операндов которого зависит от an . Пусть
pi := pk · pl

(D.)

будет самым первым таким шагом, и пусть значением pk является полином вида can + Q(x, a0 , a1 , ..., an−1 ), c 6= 0. Тогда удаление из S всех шагов с номерами, большими i − 1, и замена шага
p−n−1 := an шагом p−n−1 := 0 дает программу S′ , получающую полином Q(x, a0 , a1 , ..., an−1 ) в качестве значения переменной pk . Пусть
m — наименьшее значение индекса переменной p, встречающееся в S′ .
Добавим к S′ шаг pm−1 := c′ , где c′ = −1/c, и шаг pi := pm−1 · pk , который,
заметим, не является существенно мультипликативным. Получаемая
1
программа строит полином − Q(x, a0 , a1 , ..., an−1 ); существенно мульc
типликативных шагов в ней на единицу меньше, чем среди шагов
с номерами 1, 2, ..., i в S. Обозначим эту программу через S′′ .
Дальнейшие преобразования программы S имеют целью получение такой программы, которая содержит не более n − 1 существенно
мультипликативных шагов и при этом находит некоторый полином,
по модулю x n равный an−1 x n−1 + ... + a1 x + a0 . Мы видим, что если
бы значением p−n−1 было не an , а тот полином, который строится
с помощью S′′ , то i-й шаг S привел бы к присваиванию переменной pi значения 0, а после окончания выполнения всех шагов мы бы
получили
W ′ = W (x, a0 , a1 , ..., an−1 , c′ Q(x, a0 , a1 , ..., an−1 )).

В силу (D.) подстановка an = c′ Q(x, a0 , a1 , ..., an−1 ) в W даст нам
W ′ = P(x, a0 , a1 , ..., an−1 , c′ Q(x, a0 , a1 , ..., an−1 )) +

+ U ′ (x, a0 , a1 , ..., an−1 )x n+1 .

Принимая во внимание равенство P = an x n + ... + a1 x + a0 , получаем
W ′ ∈ Q[x, a0 , a1 , ... an−1 ] и
W ′ ≡ an−1 x n−1 + ... + a1 x + a0 (mod x n ).

Отбросим предварительный раздел формальной n-программы S и
запишем шаги ее вычислительного раздела вслед за S′′ , преобразуя



Приложение D

эти шаги следующим образом:
(a) если шаг не является шагом (D.) или существенно мультипликативным шагом вида pt := pr · ps , t ¶ k, то увеличиваем на i индекс
в левой части и увеличиваем на i каждый из положительных индексов в правой части (неположительные индексы не изменяются);
(b) в правых частях всюду заменяем p−n−1 на pi ;
(c) каждый существенно мультипликативный шаг вида pt := pr · ps ,
t ¶ k, заменяем нейтральным шагом pt +i := pt ;
(d) шаг (D.) заменяем нейтральным шагом p2i := p−n−1 .
Прибегая к замене (c), мы пользуемся независимостью от an полиномов, являющихся значениями pr и ps , это позволяет не дублировать
существенно мультипликативные шаги, содержащиеся в S′′ ; завершающая замена (d) приводит нас к формальной (n − 1)-программе построения W ′ , имеющей менее n − 1 существенно мультипликативных
шагов.
В силу сказанного ранее, из лемм D., D. следует теорема D.  .
Заметим, что замена каждого вычитания сложением с дополнительным домножением второго операнда на −1 не меняет числа существенно мультипликативных шагов. Поэтому доказательство теоремы D. сохраняет силу при рассмотрении сложения и вычитания
в качестве аддитивных операций.
Известен алгоритм, который для вычисления значения произвольного полинома n-й степени требует n сложений и n умножений, это
алгоритм («схема») Горнера:
an x n + an−1 x n−1 + ... + a1 x + a0 = (...(an x + an−1 )x + ... + a1 )x + a0 .
Таким образом, мы получили следующий результат:
Если рассматривать n в качестве размера входа
x, a0 , a1 , ..., an ,
то как по числу сложений, так и по числу умножений схема Горнера
является оптимальным в худшем случае алгоритмом вычисления значения an x n + ... + a1 x + a0 с помощью операций сложения и умножения.
Разумеется, полиномы какого-либо частного вида, как, например,
x n , могут вычисляться с меньшими затратами.

В  г. В. Я. Пан доказал утверждение теоремы D. в несколько более общей форме — см., например, [, разд. .., упр. ]. Главные идеи доказательства, приведенного выше в этом приложении, взяты из [].

Приложение E

Об одном свойстве сумм неотрицательных
случайных величин

Здесь доказывается теорема . из § .
Пусть ξ1 , ξ2 , ... — последовательность неотрицательных случайных величин на некотором вероятностном пространстве. Пусть числовая последовательность h1 , h2 , ... такова, что для каждого k ¾ 1
выполнено E(ξk |ξ1 , ξ2 , ..., ξk−1 ) ¶ hk при всех значениях ξ1 , ξ2 , ..., ξk−1 .
Зафиксируем неотрицательное число q и введем целочисленную случайную величину
§
n
ª
X
τ = min n:
ξk ¾ q .
k =1

Пусть τ < ∞ всюду на рассматриваемом вероятностном пространP

τ
стве. Тогда E
hk ¾ q.
k =1

Рассмотрим случайные величины χk , k = 1, 2, ..., где χ1 = 1, а при
k > 1 выполняется χk = 1, если ξ1 + ξ2 + ... + ξk−1 < q, и χk = 0 в противном случае. Заметим, что
¨
1, если τ ¾ k,
χk =
0, если τ < k,
и 1 = χ1 ¾ χ2 ¾ ...
Положим pk = P(τ = k) = P(χk = 1) − P(χk+1 = 1), k = 1, 2, ... Ясно,
что P(χk = 1) = 1 − p1 − p2 − ... − pk−1 . Имеем

E

X
τ

 X
∞ X
k
hk =
h j P(τ = k) =
k =1 j =1

k =1

∞
X

=
k =1

(P(χk = 1) − P(χk+1 = 1))

k
X
j =1

hj =



Приложение E
∞
X

=

P(χk = 1)

j =1

k =1
∞
X

=

P(χk = 1)

∞
X

k
X
j =1

k =1

=

k
X

P(χk = 1)

k
X

k =1

j =1

∞
X

k
X

=

P(χk = 1)

j =1

k =1

= h1 P(χ1 = 1) +

hj −
hj −
hj −
hj −

∞
X

∞
X

P(χk+1 = 1)
P(χk = 1)
P(χk = 1)

hj =

X
k
j =1

k =2
∞
X

k −1
X
j =1

k =2
∞
X

hj =

j =1

k =1
∞
X

k
X

P(χk = 1)

k
X
j =1

k =2


h j − hk =

hj +

∞
X

P(χk = 1)hk =

k =2

hk P(χk = 1) =

k =2
∞
X

=

hk P(χk = 1).

k =1

Таким образом,

E

X
τ



hk =

∞
X

hk P(χk = 1).

(E.)

k =1

k =1

Введем случайные величины ηk = χk ξk , k = 1, 2, ...; из определения
случайных величин χk следует, что
∞
X

ηk ¾ q.

(E.)

k =1

Докажем, что для k = 1, 2, ...

Eηk ¶ hk P(χk = 1).

(E.)

Рассмотрим полную группу событий W1 , W2 : в W1 попадают те элементы вероятностного пространства, для которых ξ1 + ξ2 + ... + ξk−1 < q,
в W2 — для которых ξ1 + ξ2 + ... + ξk−1 ¾ q. С учетом определения случайной величины χk , равной 1 на множестве W1 и 0 на множестве W2 ,
получаем по формуле полного математического ожидания:

Eη k = E(χ k ξ k ) =
= E(χk ξk |W1 )P(W1 ) + E(χk ξk |W2 )P(W2 ) =
= E(ξk |W1 )P(W1 ) =
= E(ξk |W1 )P(χk = 1),

Об одном свойстве сумм случайных величин



т. е.

Eηk = E(ξk |W1 )P(χk = 1).

(E.)

Так как по условию неравенство E(ξk |ξ1 , ξ2 , ..., ξk−1 ) ¶ hk выполняется при всех значениях ξ1 , ξ2 , ..., ξk−1 , то оно выполняется на W1 .
С учетом (E.) имеем E(ξk |W1 )P(χk = 1) ¶ hk , откуда следует (E.).
Из (E.), (E.), (E.) получаем
 X
∞
X
∞
∞

X
τ
X
q = Eq ¶ E
Eη k ¶
ηk =
hk P(χk = 1) = E
hk ,
k =1

k =1

k =1

k =1



что и требовалось .



Сходное, но менее подробное доказательство имеется в [, гл. III, § , теорема ],
но там в условии теоремы пропущено требование конечности τ (см. задачу ).

Приложение F

О сортировке, оптимальной по числу
сравнений в худшем случае

Долгое время считалось правдоподобным предположение, что сортировкой, оптимальной по числу сравнений в худшем случае, является
сортировка бинарными вставками, о сложности TB (n) которой, вместе с этим, было известно, что TB (5) = 8, при том, что наибольшая
из обоснованных нижних границ для числа сравнений, необходимых
для сортировки пяти элементов, есть ⌈log2 5!⌉ = 7. Это порождало гипотезу, что сложность Topt (n) оптимальной сортировки для некоторых
значений n больше, чем ⌈log2 n!⌉, и первое такое значение n равно
пяти. Но в  г. Г. Б. Демутом был найден алгоритм сортировки пяти
элементов, который требует всего семь сравнений.
Этот алгоритм можно легко изобразить с помощью рисунков, на
которых те точки, которые соответствуют сравнивавшимся элементам, соединяются стрелкой, ведущей от большего элемента к меньшему. Сравниваем первый элемент со вторым и третий с четвертым,
а потом сравниваем меньшие найденные
элементы; на это уйдет три сравнения
(рис. ). Этим, в частности, для трех элементов из пяти мы устанавливаем их относительный порядок. Затем для пятого элемента, который еще не сравнивался, мы наРис. . Сортировка пяти
ходим место среди трех уже упорядоченэлементов: ситуация
ных элементов бинарным поиском; на это
после трех сравнений.
уйдет два сравнения. Тем самым мы приходим к одному из двух случаев, изображенных на рис. . И в том, и в другом случае для завершения сортировки с помощью бинарного поиска места элемента достаточно
двух сравнений: в случае, изображенном на рис. а, вставка производится в массив из двух элементов, в случае, изображенном на
рис. б, — из трех элементов. В итоге семи сравнений оказывается
достаточно.

О сортировке, оптимальной по числу сравнений
а)



б)

Рис. . Сортировка пяти элементов, ситуация после нахождения места пятого элемента среди трех упорядоченных элементов: а) пятый элемент меньше
всех трех упорядоченных элементов; б) пятый элемент больше наименьшего из трех упорядоченных элементов. (В обоих случаях еще двух сравнений
достаточно для завершения сортировки.)

Указанный алгоритм сортировки пяти элементов был позднее
обобщен на произвольное число элементов, эта сортировка получила название сортировки слияниями и вставками. Через TF (n) обычно обозначается сложность этой сортировки по числу сравнений.
Обнаружено, что TF (n) = ⌈log2 n!⌉ для n = 1, 2, ..., 11. Но при этом
TF (12) = 30, хотя ⌈log2 12!⌉ = 29, и возникает вопрос, всегда ли возможна сортировка двенадцати элементов не более чем двадцатью девятью сравнениями? Аналогичные вопросы могут возникнуть и для
бо́льших значений n.
Как говорилось в § , имеется алгоритм, который, исходя из n > 0,
строит оптимальный по числу сравнений алгоритм сортировки массивов из n элементов (алгоритм строит алгоритм). Этот алгоритм
построения оптимального алгоритма сортировки требует огромной
работы, даже если применить все средства экономии перебора. Но,
тем не менее, на этом пути с помощью компьютера показано, что
Topt (12) = 30, что больше, чем ⌈log2 12!⌉. Но дальше продвинуться не
удалось, и по сегодняшний день, видимо, неизвестно число Topt (13):
n:
⌈log2 n!⌉:
TB (n):
TF (n):
Topt (n):













































































?

Исследования, не связанные с компьютерным вычислением Topt (n),
показали, что имеется бесконечно много значений n, для которых
TF (n) > Topt (n). Значение 47 — наименьшее из известных  .


См. [, разд. ..].

Приложение G

Метод построения общего решения
линейного рекуррентного уравнения
с постоянными коэффициентами

Напомним метод построения общего решения линейного рекуррентного уравнения с постоянными коэффициентами  . Начнем со случая
однородного уравнения
ad y(n) + ad−1 y(n − 1) + ... + a0 y(n − d) = 0.

(G.)

Пусть λ1 , λ2 , ..., λs — все различные корни характеристического уравнения
ad λd + ad−1 λd−1 + ... + a0 = 0
(G.)
и m1 , m2 , ..., m s — кратности этих корней, m1 m2 + ... + m s = d. Общим
решением уравнения (G.) является
s
X
k =1

(Ck,mk −1 nmk −1 + ... + Ck1 n + Ck0 )λnk ,

(G.)

где все Cij — произвольные постоянные.
Общее решение неоднородного линейного рекуррентного уравнения с постоянными коэффициентами
ad y(n) + ad−1 y(n − 1) + ... + a0 y(n − d) = f (n),

(G.)

где f (n) — известная функция, является суммой общего решения соответствующего однородного уравнения (G.) и какого-нибудь частного решения неоднородного уравнения (G.).
Если правая часть f (n) уравнения (G.) представлена в виде
f (n) = g(n) + ... + h(n) и если известны частные решения v(n), ...
..., w(n) для уравнений, левые части которых совпадают с левой
частью уравнения (G.), а правые части равны соответственно


См., например, [, гл. V, § ], [, гл. ].

Построение общего решения рекуррентного уравнения



g(n), ..., h(n), то v(n) + ... + w(n) будет частным решением уравнения (G.).
Если правая часть f (n) неоднородного уравнения (G.) представляет собой квазиполином, т. е. равна p(n)µn , где p(n) — полином
некоторой степени l ¾ 0, а µ — некоторое (комплексное) число, то
(G.) имеет частное решение в виде квазиполинома q(n)µn , и при
этом полином q(n) имеет степень l + m, где m — кратность µ как корня характеристического уравнения (G.) (если µ не является корнем
этого уравнения, то считаем кратность нулевой: m = 0). Коэффициенты полинома q(n) находятся методом неопределенных коэффициентов.
Частные решения с заданными начальными значениями находятся
подстановкой в общее решение начальных значений и определением
постоянных из возникшей системы линейных алгебраических уравнений. (C помощью этого метода выводится и формула Бине (.).)

Приложение H

Об одном семействе алгебраических
уравнений

В примере . мы столкнулись с рекуррентным уравнением
y(n) − y(n − 1) − ... − y(n − k) = 1,

(H.)

y(0) = y(1) = ... = y(k − 1) = 0. В качестве частного решения этого
−1
. Нам предстонеоднородного уравнения при k > 1 можно взять
k−1
ит теперь заняться общим решением соответствующего однородного
уравнения, характеристическим уравнением которого служит
λk − λk−1 − ... − λ − 1 = 0.

(H.)

Свойства корней уравнения (H.) описываются следующим предложением.
Предложение H.. При k > 1 уравнение (H.) имеет k различных
корней. При этом в точности один из них — мы будем называть его
главным корнем уравнения (H.) и обозначать через αk — по модулю
превосходит единицу. Главный корень — вещественное число, удовле1
творяющее условию  2 − ¶ αk < 2.
k

Доказательство. Поскольку предстоит использовать некоторую
технику теории аналитических функций, мы перейдем к привычному
обозначению z для комплексной переменной и будем рассматривать
уравнение z k − z k−1 − ... − z − 1 = 0, левую часть которого обозначим
через vk (z). Положим Vk (z) = (z − 1)vk (z) = z k+1 − 2z k + 1.
Уравнение Vk (z) = 0 в сравнении с vk (z) = 0 имеет дополнительный
корень z = 1; мы докажем утверждение предложения для Vk (z) = 0,


См. [, гл. , пп. —], [], [, разд. .., упр. ]. В [] доказано также, что
все корни, отличные от главного корня αk , по модулю не превосходят αk − 1 < 1.

Об одном семействе алгебраических уравнений



k > 1, откуда будет следовать требуемое. Доказательство мы проведем
в три этапа, установив справедливость следующих утверждений:
(i) для любого k > 1 все корни уравнения Vk (x) = 0 простые (т. е.
имеют кратность 1);
1
(ii) круг любого радиуса r, 1 < r < 2 − , с центром в z = 0 содерk
жит ровно k корней уравнения Vk (z) = 0;
(iii) уравнение Vk (z) = 0 имеет
мере один веществен
h по меньшей
1
ный корень на полуинтервале 2 − , 2 .
k

Для доказательства утверждения (i) заметим, прежде всего, что
íîä(Vk (z), Vk′ (z)) = íîä(Vk (z), z k−1((k + 1)z − 2k)).
2k

Но Vk (z) не обращается в  при z = 0 и при z =
. Отсюда следует,
k+1
что íîä(Vk (z), Vk′ (z)) = 1. Это говорит о том, что корни Vk (z) простые.
Для доказательства утверждения (ii) положим Wk (z) = z k+1 − 2z k .
Если на некоторой окружности выполняется неравенство | Wk (z) | > 1,
то внутри этой окружности полиномы Vk (z) и Wk (z) по теореме Руше 
имеют одинаковое число корней. Рассмотрим окружность Sσ радиуса
1 + σ, 0 < σ < 1, с центром в z = 0. Так как
| Wk (z) | = | z k+1 − 2z k | ¾ | 2z k | − | z k+1 |,

то на окружности Sσ выполняется | Wk (z) | ¾ (1 + σ)k (1 − σ). Далее,
очевидно, (1 + σ)k ¾ 1 + k σ, и мы получаем, что если σ удовлетворяет
неравенству
(1 + k σ)(1 − σ) > 1,
(H.)
то условия теоремы Руше выполнены, и полином Vk (z) имеет внутри Sσ столько же корней, сколько их имеет Wk (x), т. е. k. Неравенство (H.) выполнено для всех значений σ, принадлежащих интервалу с концами, являющимися корнями квадратного уравнения
1
k σ2 − (k − 1)σ = 0, — эти корни суть 0 и 1 − . Это доказывает утверk
ждение (ii).
Наконец, утверждение (iii) следует из того, что vk (1) < 0, vk (2) > 0
и
при
этом
уравнение vk (z) = 0 не имеет корней на интервале


1
1, 2 −
.
k



См., например, [, гл. , § ] или [, п. .]. Применительно к полиномиальному
случаю эта теорема допускает следующую формулировку. Пусть полином V (z) предe
ставлен в виде суммы W(z) + W(z)
двух полиномов, и на контуре некоторой области
e
значение | W(z)
| меньше значения | W(z) |. Тогда внутри этой области число корней
полиномов V (z) и W(z) одинаково.



Приложение H

Рекуррентное уравнение (H.) имеет, таким образом, общее решение
1
y(n) = Ck αnk + Ck−1 αnk−1 + ... + C1 α1n −
k−1

(αk — главный корень характеристического уравнения (H.), все
остальные корни α1 , α2 , ..., αk−1 по модулю не превосходят единицу). Нас интересует частное решение, удовлетворяющее условию
y(0) = y(1) = ... = y(k − 1) = 0. И без нахождения всех Ci ясно, что
Ck 6= 0, — иначе последовательность y(k), y(k + 1), ... была бы ограниченной.
На рис.  показано расположение корней уравнений Vk (z) = 0,
k = 2, 3, 4.
Im z

Im z

1

1
Re z

−1

0

1

Re z
−1

2

0

−1

1

2

−1

а) z2 − z − 1 = 0

б) z3 − z2 − z − 1 = 0

Im z
1
Re z
−1

0

1

2

−1

в) z4 − z3 − z2 − z − 1 = 0

Рис. .

Итак, нам удалось обойтись без фактического нахождения корней
характеристического уравнения. Более того, речь шла не об одном
конкретном уравнении, а о семействе, в которое входят уравнения
сколь угодно высоких степеней.
Мы получили доказательство предложения . из § .

Литература

[] С. А. Абрамов. Исследование алгоритмов одновременного нахождения наибольшего и наименьшего элементов массива // ЖВМ
и МФ. . Т. , № . С.  — .
[] С. А. Абрамов. Элементы анализа программ. Частичные функции
на множестве состояний. М.: Наука, .
[] С. А. Абрамов, Г. Г. Гнездилова. Алгоритм управления вопросником в автоматизированной обучающей системе // Вестн. Моск.
ун-та. Сер. . Вычисл. мат. и киб. . № . С. — .
[] В. Б. Алексеев. Введение в теорию сложности алгоритмов: Учебное пособие для студентов. М.: Издательский отдел ф-та ВМиК
МГУ, .
[] А. Ахо, Дж. Хопкрофт, Дж. Ульман. Построение и анализ вычислительных алгоритмов. М.: Мир, .
[] Н. Г. де Брейн. Асимптотические методы в анализе. М.: ИЛ, .
[] А. А. Васин, В. В. Морозов. Теория игр и модели математической
экономики. Учебное пособие. М.: МАКС Пресс, .
[] Введение в криптографию / Под общей редакцией В. В. Ященко.
М.: МЦНМО: ЧеРо, .
[] Н. К. Верещагин, А. Шень. Начала теории множеств. М.: МЦНМО,
.
[] М. Н. Вялый. Сложность вычислительных задач // Математическое просвещение, вып. . M.: МЦНМО, . С. —.
[] С. Б. Гашков, В. Н. Чубариков. Арифметика. Алгоритмы. Сложность вычислений. М.: Высшая школа, .
[] А. О. Гельфонд. Исчисление конечных разностей. М.: Наука, .



Литература

[] М. Гэри, Д. Джонсон. Вычислительные машины и труднорешаемые задачи. М.: Мир, .
[] В. А. Ильин, Г. Д. Ким. Линейная алгебра и аналитическая геометрия. М.: Изд-во Моск. ун-та, .
[] А. А. Карацуба, Ю. П. Офман. Умножение многозначных чисел на
автоматах // Докл. АН СССР. . Т. , № . С.  —.
[] А. А. Карацуба. Основы аналитической теории чисел. М.: Наука,
.
[] А. А. Карацуба. Сложность вычислений // Труды Математического института РАН. . Т. . С.  —.
[] Д. Кнут. Искусство программирования для ЭВМ. Т. . Основные
алгоритмы. М.—СПб.—Киев: ИД «Вильямс», .
[] Д. Кнут. Искусство программирования для ЭВМ. Т. . Получисленные алгоритмы. М.—СПб.—Киев: ИД «Вильямс», .
[] Д. Кнут. Искусство программирования для ЭВМ. Т. . Сортировка и поиск. М.—СПб.—Киев: ИД «Вильямс», .
[] Т. Кормен, Ч. Лейзерсон, Р. Ривест. Алгоритмы: построение и анализ. М.: МЦНМО, .
[] А. И. Кострикин. Введение в алгебру. М.: Наука, .
[] В. H. Крупский. Введение в сложность вычислений. М.: Факториал-Пресс, .
[] С. С. Лавров. Программирование. Математические основы, средства, теория. СПб: БХВ-Петербург, .
[] В. H. Латышев. Комбинаторная теория колец: сложность алгебраических алгоритмов. М.: Изд-во Моск. ун-та, .
[] Дж. Макконелл. Анализ алгоритмов. Вводный курс. М.: Техносфера, .
[] Ф. Мостеллер.  занимательных вероятностных задач с решениями. М.: URSS, .
[] А. М. Островский. Решение уравнений и систем уравнений. М.:
ИЛ, .

Литература



[] В. В. Прасолов. Многочлены. М.: МЦНМО, .
[] Ф. Препарата, М. Шеймос. Вычислительная геометрия: введение.
М.: Мир, .
[] Э. Рейнгольд, Ю. Нивергельт, Н. Део. Комбинаторные алгоритмы.
Теория и практика. М.: Мир, .
[] В. К. Романко. Разностные уравнения. М.: БИНОМ. Лаборатория
знаний, .
[] А. А. Сапоженко. Некоторые вопросы сложности алгоритмов:
учебное пособие. М.: Издательский отдел ф-та ВМиК МГУ, .
[] А. Г. Свешников, А. Н. Тихонов. Теория функций комплексной переменной. М.: Физматлит, .
[] В. Серпинский.  задач по теории чисел. Москва—Ижевск: Регулярная и хаотическая динамика, .
[] А. Л. Тоом. О сложности схемы из функциональных элементов,
реализующей умножение целых чисел // Докл. АН СССР. .
Т. , № . С.  — .
[] Дж. Хартманис, Дж. Э. Хопкрофт. Обзор теории сложности //
Кибернетический сборник. . Вып. . С. —.
[] П. Л. Чебышев. Полное собрание сочинений. Т. . М.—Л.: АН
СССР, .
[] И. Р. Шафаревич. Избранные главы алгебры. М.: Журнал «Математическое образование», .
[] Математическая энциклопедия. Т. . М.: Издательство «Советская энциклопедия», .
[] S. A. Abramov, M. Bronstein. Hypergeometric dispersion and the orbit
problem // Proceedings of the  International Symposium
on Symbolic and Algebraic Computation. New York: ACM, .
P.  —.
[] M. Agrawal, N. Kayal, N. Saxena. PRIMES is in P // Ann. of Math.
(). . V. , № . P. —.
[] S. Baase, A. van Gelder. Computer algorithms: introduction to design
and analysis. Boston, MA: Addison-Wesley, .



Литература

[] E. Bach, J. Shallit. Algorithmic number theory. V. . Efficient
algorithms. Cambridge, MA: MIT Press, .
[] P. E. Blanksby, H. L. Montgomery. Algebraic integers near the unit
circle // Acta Arith. . V. . P.  —.
[] G. Brassard, P. Bratley. Fundamentals of algorithms. Englewood
Cliffs, NJ: Prentice Hall, .
[] D. Coppersmith, S. Winograd. Matrix multiplication via arithmetic
progressions // J. Symbolic Comput. . V. , № . P. —.
[] M. J. Fischer, M. O. Rabin. Super-exponential complexity of Presburger
arithmetic // Complexity of computation (Proc. SIAM-AMS Sympos.,
New York, ). Providence, RI: AMS, . (SIAM-AMS Proc.;
Vol. VII). P. — .
[] N. Friedman. Some results on the effect of arithmetics on comparison
problems // Proc. th IEEE Ann. Symp. on Switching and Automata
Theory. Los Alamitos, CA: IEEE Computer Society, . P.  —.
[] J. von zur Gathen, J. Gerhard. Modern computer algebra. New York:
Cambrige University Press, .
[] R. Kannan, R. J. Lipton. Polynomial-time algorithm for the orbit
problem // J. Assoc. Comput. Mach. . V. , № . P.  — .
[] D. E. Knuth. Big omicron and big omega and big theta // ACM
SIGACT News. . V. , iss. . P.  —.
[] J. C. Lagarias. The 3x + 1 problem and its generalizations // The
American Mathematical Monthly. . V. , № . P.  —.
[] E. P. Miles, Jr. Generalized Fibonacci numbers and associated matrices // The American Mathematical Monthly. . V. , № .
P.  —.
[] R. Motwani, P. Raghavan. Randomized algorithms. Cambridge: Cambridge University Press, .
[] I. Pohl. A sorting problem and its complexity // Comm. ACM. .
V. , № . P. — .

Литература



[] E. M. Reingold, A. I. Stocks. Simple proofs of lower bounds for
polynomial evaluation // Complexity of computer computations
(Proc. Sympos., IBM Thomas J. Watson Res. Center, Yorktown
Heights, N. Y., ). New York: Plenum, . P. —.
[] A. Schinzel, H. Zassenhaus. A reﬁnement of two theorems of
Kronecker // Michigan Math. J. . V. . P. — .
[] R. Sedgewick, P. Flajolet. An introduction to the analysis of algorithms.
Boston, MA: Addison-Wesley, .

Предметный указатель

Алгоритм
— Агравала—Кайала—Саксены
(AKS) 
— бинарный возведения в степень (RS) , 
— Грэхема (G) , 
— Евклида (E) , , 
— — расширенный (EE) , ,

— Карацубы (KM) 
— кратных карт 
— наивного деления с остатком
(ND) 
— — умножения (NM) 
— оптимальный 
— — по порядку сложности 
— пробных делений (TD) , 
— рандомизированный , , 
— сложения (Add) 
— Тоома (TM) 
— Уоршелла , 
— Шенхаге—Штрассена 
— Шеймоса—Хоя (SH) 
— Штрассена умножения матриц
(St) 
Асимптотики символ
— o , 
— O , 
e 
— O
— Θ , 
— Ω , 
— ∼ 
Задача NP-полная 
Затраты алгоритма (функции затрат) 

Класс
— P 
— P 
— NP 
Модель вычислений , , 
Нижняя граница сложности 
— асимптотическая 
Оценка точная , 
Поиск 
— бинарный места элемента (BS)
, 
— наименьшего элемента , ,

— наименьшего и наибольшего
элементов , , 
— m-го наименьшего элемента

Полиномиальная ограниченность

Принцип Яо 
?
Проблема P = NP , 
Размер входа 
Сегмент массива 
Сертификат 
Сводимость
— линейная 
— полиномиальная 
Сложность 
— аддитивная 

Предметный указатель
Сложность алгебраическая 
— битовая 
— в среднем 
— в худшем случае 
— временная 
— мультипликативная 
— пространственная 
— словесная 
Сортировка 
— быстрая (QS) , 
— — рандомизированная 
— вставками
— — бинарными (B) , 
— — простыми (I1 , I2 ) , 
— выбором , 


—
—
—
—

оптимальная (opt) 
пузырьковая , , 
слияниями и вставками (F) 
слияниями рекурсивная (MS)
, , 
— фон Неймана (vN) , 
Стратегия «разделяй и властвуй»

Схемы Горнера оптимальность 
Теорема
— Кука 
— о рекуррентном неравенстве

— Фишера—Рабина 

Оглавление

Предисловие . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Введение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Наиболее часто используемые обозначения . . . . . . . . . . . . . . .

3
5
8

Глава . Сложности алгоритмов как функции числовых аргументов. Сложность в худшем случае
§ . Затраты алгоритма для данного входа, алгебраическая
сложность . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
§ . Асимптотические оценки (формализм) . . . . . . . . . . . . . 18
§ . Асимптотические оценки (два примера) . . . . . . . . . . . . 23
§ . Длина числа как возможный размер входа . . . . . . . . . . 31
Задачи . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
Глава . Сложность в среднем
§ . Понятие сложности в среднем . . . . . . . . . . . . . . . . . . . 42
§ . Сортировка и конечные вероятностные пространства.
Применение формулы полного математического ожидания46
§ . Пример медленного роста сложности в среднем в сравнении со сложностью в худшем случае . . . . . . . . . . . . . 53
§ . Функция затрат рандомизированного алгоритма . . . . . . 58
Задачи . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
Глава . Оценивание числа шагов (итераций) алгоритма
§ . Функции, убывающие по ходу выполнения алгоритма .
§ . Качество оценок . . . . . . . . . . . . . . . . . . . . . . . . . . .
§ . Завершимость работы алгоритма . . . . . . . . . . . . . . . .
§ . Вложенные циклы (дополнительные примеры) . . . . . .
§ . Нецелые размеры входа и непрерывные оценочные
функции . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Задачи . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.

74
83
89
95

. 97
100

Глава . Нижняя граница сложности алгоритмов некоторого класса. Оптимальные алгоритмы
§ . Понятие нижней границы сложности . . . . . . . . . . . . . 106
§ . Оптимальные алгоритмы . . . . . . . . . . . . . . . . . . . . . 109

Оглавление



§ . Асимптотические нижние границы. Алгоритм, оптимальный по порядку сложности . . . . . . . . . . . . . . . . .
§ . Нижняя граница сложности в среднем . . . . . . . . . . . .
§ . Нижние границы сложности рандомизированных алгоритмов. Принцип Яо . . . . . . . . . . . . . . . . . . . . . . . .
Задачи . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Глава . Битовая сложность
§ . Битовые операции . . . . . . . . . . . . . . . . .
§ . Наивная арифметика: умножение . . . . . .
§ . Наивная арифметика: деление с остатком .
§ . Модулярная арифметика . . . . . . . . . . . . .
§ . Булева арифметика . . . . . . . . . . . . . . . .
Задачи . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

114
118
126
129
133
137
140
145
150
154

Глава . Рекуррентные соотношения как средство анализа сложности алгоритмов
§ . Простейшие рекуррентные уравнения . . . . . . . . . . . . . 158
§ . Об одном классе нелинейных рекуррентных соотношений163
§ . Асимптотические оценки решений рекуррентных неравенств . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
§ . Добавление нулей . . . . . . . . . . . . . . . . . . . . . . . . . . 172
Задачи . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
Глава . Сводимость
§ . Линейная сводимость . . . . . . . . . . . . . . . . . . . . . . . .
§ . Линейная сводимость и нижние границы сложности . .
§ . Классы P и NP . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
§ . Существование задач распознавания, не принадлежащих P. Связь моделей МТ и РАМ . . . . . . . . . . . . . . . .
§ . Полиномиальная сводимость. NP-полные задачи . . . . .
Задачи . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

185
190
195
201
204
209

Приложение A. Основные алгоритмы сортировки и поиска . . . 214
Приложение B. Оценивание сумм значений монотонных функций 218
Приложение C. Проблема орбит . . . . . . . . . . . . . . . . . . . . . . 221
Приложение D. Оптимальность схемы Горнера . . . . . . . . . . . . 227
Приложение E. Об одном свойстве сумм неотрицательных случайных величин . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
Приложение F. О сортировке, оптимальной по числу сравнений
в худшем случае . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236



Оглавление

Приложение G. Метод построения общего решения линейного рекуррентного уравнения с постоянными коэффициентами . . . 238
Приложение H. Об одном семействе алгебраических уравнений 240
Литература . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243
Предметный указатель . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248

Сергей Александрович Абрамов
Лåêöèè î ñëîæíîñòè àëãîðèòìîâ
Издательство Московского центра
непрерывного математического образования
, Москва, Большой Власьевский пер., . Тел. () --
Подписано в печать .. г. Формат 60×90 /. Бумага офсетная.
Печать офсетная. Печ. л. . Тираж . Заказ
.
Отпечатано с готовых диапозитивов в ППП «Типография „Наука“».
, Москва, Шубинский пер., д. .
Книги издательства МЦНМО можно приобрести в магазине «Математическая книга»,
Большой Власьевский пер., д. . Тел. () --. E-mail: biblio@mccme.ru

